apiVersion: v1
data:
  core-site.xml: "<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<?xml-stylesheet type=\"text/xsl\"
    href=\"configuration.xsl\"?>\n<!--\n  Licensed under the Apache License, Version
    2.0 (the \"License\");\n  you may not use this file except in compliance with
    the License.\n  You may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\n
    \ Unless required by applicable law or agreed to in writing, software\n  distributed
    under the License is distributed on an \"AS IS\" BASIS,\n  WITHOUT WARRANTIES
    OR CONDITIONS OF ANY KIND, either express or implied.\n  See the License for the
    specific language governing permissions and\n  limitations under the License.
    See accompanying LICENSE file.e\n-->\n\n<!-- Put site-specific property overrides
    in this file. -->\n\n<configuration>\n  <property>\n    <name>fs.defaultFS</name>\n
    \   <value>hdfs://fom-hadoop-01.fritz.box:9000</value>\n  </property>\n  <property>\n\t
    \ <name>io.file.buffer.size</name>\n\t  <value>131072</value>\n  </property>\n
    \ <property>\n\t  <name>hadoop.http.staticuser.user</name>\n\t  <value>hdfs</value>\n
    \ </property>\n  <property>\n\t  <name>hadoop.proxyuser.hdfs.groups</name>\n\t
    \ <value>*</value>\n  </property>\n  <property>\n\t  <name>hadoop.proxyuser.hdfs.hosts</name>\n\t
    \ <value>*</value>\n  </property>\n  <property>\n\t  <name>hadoop.proxyuser.hbase.groups</name>\n\t
    \ <value>*</value>\n  </property>\n  <property>\n\t  <name>hadoop.proxyuser.hbase.hosts</name>\n\t
    \ <value>*</value>\n  </property>\n  <property>\n\t  <name>hadoop.proxyuser.nfsserver.groups</name>\n\t
    \ <value>*</value>\n  </property>\n  <property>\n\t  <name>hadoop.proxyuser.nfsserver.hosts</name>\n\t
    \ <value>*</value>\n  </property>\n  <property>\n\t  <name>hadoop.proxyuser.root.groups</name>\n\t
    \ <value>*</value>\n  </property>\n  <property>\n\t  <name>hadoop.proxyuser.root.hosts</name>\n\t
    \ <value>*</value>\n  </property>\n  <property>\n\t  <name>hadoop.proxyuser.hue.groups</name>\n\t
    \ <value>*</value>\n  </property>\n  <property>\n\t  <name>hadoop.proxyuser.hue.hosts</name>\n\t
    \ <value>*</value>\n  </property>\n  <property>\n\t  <name>hadoop.proxyuser.hue-labor.groups</name>\n\t
    \ <value>*</value>\n  </property>\n  <property>\n\t  <name>hadoop.proxyuser.hue-labor.hosts</name>\n\t
    \ <value>*</value>\n  </property>\n  <property>\n\t  <name>hadoop.proxyuser.oozie.groups</name>\n\t
    \ <value>*</value>\n  </property>\n  <property>\n\t  <name>hadoop.proxyuser.oozie.hosts</name>\n\t
    \ <value>*</value>\n  </property>\n  <property>\n\t  <name>hadoop.proxyuser.oozie.users</name>\n\t
    \ <value>*</value>\n  </property>\n  <property>\n\t  <name>hadoop.proxyuser.hive.groups</name>\n\t
    \ <value>*</value>\n  </property>\n  <property>\n\t  <name>hadoop.proxyuser.hive.hosts</name>\n\t
    \ <value>*</value>\n  </property>\n  <property>\n\t  <name>hadoop.proxyuser.spark.groups</name>\n\t
    \ <value>*</value>\n  </property>\n  <property>\n\t  <name>hadoop.proxyuser.spark.hosts</name>\n\t
    \ <value>*</value>\n  </property>\n  <property>\n\t  <name>hadoop.proxyuser.yarn.groups</name>\n\t
    \ <value>*</value>\n  </property>\n  <property>\n\t  <name>hadoop.proxyuser.yarn.hosts</name>\n\t
    \ <value>*</value>\n  </property>\n</configuration>\n"
  hdfs-site.xml: "<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<?xml-stylesheet type=\"text/xsl\"
    href=\"configuration.xsl\"?>\n<!--\n  Licensed under the Apache License, Version
    2.0 (the \"License\");\n  you may not use this file except in compliance with
    the License.\n  You may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\n
    \ Unless required by applicable law or agreed to in writing, software\n  distributed
    under the License is distributed on an \"AS IS\" BASIS,\n  WITHOUT WARRANTIES
    OR CONDITIONS OF ANY KIND, either express or implied.\n  See the License for the
    specific language governing permissions and\n  limitations under the License.
    See accompanying LICENSE file.\n-->\n\n<!-- Put site-specific property overrides
    in this file. -->\n\n<configuration>\n\t<property>\n\t\t<name>dfs.replication</name>\n\t\t<value>3</value>\n\t</property>\n\t<property>\n\t\t<name>dfs.permissions</name>\n\t\t<value>false</value>\n\t</property>\n\t<property>\n\t\t<name>dfs.disk.balancer.enabled</name>\n\t\t<value>true</value>\n\t</property>\n\t<property>\n\t\t<name>dfs.namenode.acls.enabled</name>\n\t\t<value>true</value>\n\t</property>\n\t<property>\n\t\t<name>hadoop.security.group.mapping</name>\n\t\t<value>org.apache.hadoop.security.ShellBasedUnixGroupsMapping</value>\n\t</property>\n\t<property>\n\t\t<name>dfs.datanode.data.dir</name>\n\t\t<value>/opt/hdfs/dn</value>\n\t</property>\n\t<property>\n\t\t<name>dfs.datanode.data.dir.perm</name>\n\t\t<value>750</value>\n\t</property>\n\t<property>\n\t\t<name>dfs.namenode.name.dir</name>\n\t\t<value>/opt/hdfs/nn</value>\n\t</property>\n\t<property>\n\t\t<name>dfs.blocksize</name>\n\t\t<value>268435456</value>\n\t</property>\n\t<property>\n\t\t<name>ipc.maximum.data.length</name>\n\t\t<value>134217728</value>\n\t</property>\n\t<property>\n\t\t<name>dfs.client.datanode-restart.timeout</name>\n\t\t<value>30</value>\n\t</property>\n\t<property>\n\t\t<name>dfs.host.exclude</name>\n\t\t<value>/opt/hadoop/etc/dfs.exclude</value>\n\t</property>\n\t<property>\n\t\t<name>dfs.hosts</name>\n\t\t<value>/opt/hadoop/etc/dfs.hosts</value>\n\t</property>\n\t<property>\n\t\t<name>dfs.namenode.secondary.http-address</name>\n\t\t<value>192.168.0.202:9868</value>\n\t</property>\n</configuration>\n"
  hive-site.xml: "<?xml version=\"1.0\" encoding=\"UTF-8\" standalone=\"no\"?>\n<?xml-stylesheet
    type=\"text/xsl\" href=\"configuration.xsl\"?><!--\n   Licensed to the Apache
    Software Foundation (ASF) under one or more\n   contributor license agreements.
    \ See the NOTICE file distributed with\n   this work for additional information
    regarding copyright ownership.\n   The ASF licenses this file to You under the
    Apache License, Version 2.0\n   (the \"License\"); you may not use this file except
    in compliance with\n   the License.  You may obtain a copy of the License at\n\n
    \      http://www.apache.org/licenses/LICENSE-2.0\n\n   Unless required by applicable
    law or agreed to in writing, software\n   distributed under the License is distributed
    on an \"AS IS\" BASIS,\n   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
    express or implied.\n   See the License for the specific language governing permissions
    and\n   limitations under the License.\n--><configuration>\n  <!-- WARNING!!!
    This file is auto generated for documentation purposes ONLY! -->\n  <!-- WARNING!!!
    Any changes you make to this file will be ignored by Hive.   -->\n  <!-- WARNING!!!
    You must make your changes in hive-site.xml instead.         -->\n  <!-- Hive
    Execution Parameters -->\n  <property>\n    <name>hive.exec.script.wrapper</name>\n
    \   <value/>\n    <description/>\n  </property>\n  <property>\n    <name>hive.exec.plan</name>\n
    \   <value/>\n    <description/>\n  </property>\n  <property>\n    <name>hive.exec.stagingdir</name>\n
    \   <value>.hive-staging</value>\n    <description>Directory name that will be
    created inside table locations in order to support HDFS encryption. This is replaces
    ${hive.exec.scratchdir} for query results with the exception of read-only tables.
    In all cases ${hive.exec.scratchdir} is still used for other temporary files,
    such as job plans.</description>\n  </property>\n  <property>\n    <name>hive.exec.scratchdir</name>\n
    \   <value>/tmp/hive</value>\n    <description>HDFS root scratch dir for Hive
    jobs which gets created with write all (733) permission. For each connecting user,
    an HDFS scratch dir: ${hive.exec.scratchdir}/&lt;username&gt; is created, with
    ${hive.scratch.dir.permission}.</description>\n  </property>\n  <property>\n    <name>hive.repl.rootdir</name>\n
    \   <value>/user/hive/repl/</value>\n    <description>HDFS root dir for all replication
    dumps.</description>\n  </property>\n  <property>\n    <name>hive.repl.cm.enabled</name>\n
    \   <value>false</value>\n    <description>Turn on ChangeManager, so delete files
    will go to cmrootdir.</description>\n  </property>\n  <property>\n    <name>hive.repl.cmrootdir</name>\n
    \   <value>/user/hive/cmroot/</value>\n    <description>Root dir for ChangeManager,
    used for deleted files.</description>\n  </property>\n  <property>\n    <name>hive.repl.cm.retain</name>\n
    \   <value>24h</value>\n    <description>\n      Expects a time value with unit
    (d/day, h/hour, m/min, s/sec, ms/msec, us/usec, ns/nsec), which is hour if not
    specified.\n      Time to retain removed files in cmrootdir.\n    </description>\n
    \ </property>\n  <property>\n    <name>hive.repl.cm.interval</name>\n    <value>3600s</value>\n
    \   <description>\n      Expects a time value with unit (d/day, h/hour, m/min,
    s/sec, ms/msec, us/usec, ns/nsec), which is sec if not specified.\n      Inteval
    for cmroot cleanup thread.\n    </description>\n  </property>\n  <property>\n
    \   <name>hive.repl.replica.functions.root.dir</name>\n    <value>/user/hive/repl/functions/</value>\n
    \   <description>Root directory on the replica warehouse where the repl sub-system
    will store jars from the primary warehouse</description>\n  </property>\n  <property>\n
    \   <name>hive.repl.approx.max.load.tasks</name>\n    <value>10000</value>\n    <description>\n
    \     Provide an approximation of the maximum number of tasks that should be executed
    before \n      dynamically generating the next set of tasks. The number is approximate
    as Hive \n      will stop at a slightly higher number, the reason being some events
    might lead to a \n      task increment that would cross the specified limit.\n
    \   </description>\n  </property>\n  <property>\n    <name>hive.repl.partitions.dump.parallelism</name>\n
    \   <value>100</value>\n    <description>Number of threads that will be used to
    dump partition data information during repl dump.</description>\n  </property>\n
    \ <property>\n    <name>hive.repl.dumpdir.clean.freq</name>\n    <value>0s</value>\n
    \   <description>\n      Expects a time value with unit (d/day, h/hour, m/min,
    s/sec, ms/msec, us/usec, ns/nsec), which is sec if not specified.\n      Frequency
    at which timer task runs to purge expired dump dirs.\n    </description>\n  </property>\n
    \ <property>\n    <name>hive.repl.dumpdir.ttl</name>\n    <value>7d</value>\n
    \   <description>\n      Expects a time value with unit (d/day, h/hour, m/min,
    s/sec, ms/msec, us/usec, ns/nsec), which is day if not specified.\n      TTL of
    dump dirs before cleanup.\n    </description>\n  </property>\n  <property>\n    <name>hive.repl.dump.metadata.only</name>\n
    \   <value>false</value>\n    <description>Indicates whether replication dump
    only metadata information or data + metadata.</description>\n  </property>\n  <property>\n
    \   <name>hive.repl.dump.include.acid.tables</name>\n    <value>false</value>\n
    \   <description>\n      Indicates if repl dump should include information about
    ACID tables. It should be \n      used in conjunction with 'hive.repl.dump.metadata.only'
    to enable copying of \n      metadata for acid tables which do not require the
    corresponding transaction \n      semantics to be applied on target. This can
    be removed when ACID table \n      replication is supported.\n    </description>\n
    \ </property>\n  <property>\n    <name>hive.repl.bootstrap.dump.open.txn.timeout</name>\n
    \   <value>1h</value>\n    <description>\n      Expects a time value with unit
    (d/day, h/hour, m/min, s/sec, ms/msec, us/usec, ns/nsec), which is hour if not
    specified.\n      Indicates the timeout for all transactions which are opened
    before triggering bootstrap REPL DUMP. If these open transactions are not closed
    within the timeout value, then REPL DUMP will forcefully abort those transactions
    and continue with bootstrap dump.\n    </description>\n  </property>\n  <property>\n
    \   <name>hive.repl.add.raw.reserved.namespace</name>\n    <value>false</value>\n
    \   <description>\n      For TDE with same encryption keys on source and target,
    allow Distcp super user to access \n      the raw bytes from filesystem without
    decrypting on source and then encrypting on target.\n    </description>\n  </property>\n
    \ <property>\n    <name>hive.scratch.dir.permission</name>\n    <value>700</value>\n
    \   <description>The permission for the user specific scratch directories that
    get created.</description>\n  </property>\n  <property>\n    <name>hive.exec.submitviachild</name>\n
    \   <value>false</value>\n    <description/>\n  </property>\n  <property>\n    <name>hive.exec.submit.local.task.via.child</name>\n
    \   <value>true</value>\n    <description>\n      Determines whether local tasks
    (typically mapjoin hashtable generation phase) runs in \n      separate JVM (true
    recommended) or not. \n      Avoids the overhead of spawning new JVM, but can
    lead to out-of-memory issues.\n    </description>\n  </property>\n  <property>\n
    \   <name>hive.exec.script.maxerrsize</name>\n    <value>100000</value>\n    <description>\n
    \     Maximum number of bytes a script is allowed to emit to standard error (per
    map-reduce task). \n      This prevents runaway scripts from filling logs partitions
    to capacity\n    </description>\n  </property>\n  <property>\n    <name>hive.exec.script.allow.partial.consumption</name>\n
    \   <value>false</value>\n    <description>\n      When enabled, this option allows
    a user script to exit successfully without consuming \n      all the data from
    the standard input.\n    </description>\n  </property>\n  <property>\n    <name>stream.stderr.reporter.prefix</name>\n
    \   <value>reporter:</value>\n    <description>Streaming jobs that log to standard
    error with this prefix can log counter or status information.</description>\n
    \ </property>\n  <property>\n    <name>stream.stderr.reporter.enabled</name>\n
    \   <value>true</value>\n    <description>Enable consumption of status and counter
    messages for streaming jobs.</description>\n  </property>\n  <property>\n    <name>hive.exec.compress.output</name>\n
    \   <value>false</value>\n    <description>\n      This controls whether the final
    outputs of a query (to a local/HDFS file or a Hive table) is compressed. \n      The
    compression codec and other options are determined from Hadoop config variables
    mapred.output.compress*\n    </description>\n  </property>\n  <property>\n    <name>hive.exec.compress.intermediate</name>\n
    \   <value>false</value>\n    <description>\n      This controls whether intermediate
    files produced by Hive between multiple map-reduce jobs are compressed. \n      The
    compression codec and other options are determined from Hadoop config variables
    mapred.output.compress*\n    </description>\n  </property>\n  <property>\n    <name>hive.intermediate.compression.codec</name>\n
    \   <value/>\n    <description/>\n  </property>\n  <property>\n    <name>hive.intermediate.compression.type</name>\n
    \   <value/>\n    <description/>\n  </property>\n  <property>\n    <name>hive.exec.reducers.bytes.per.reducer</name>\n
    \   <value>256000000</value>\n    <description>size per reducer.The default is
    256Mb, i.e if the input size is 1G, it will use 4 reducers.</description>\n  </property>\n
    \ <property>\n    <name>hive.exec.reducers.max</name>\n    <value>1009</value>\n
    \   <description>\n      max number of reducers will be used. If the one specified
    in the configuration parameter mapred.reduce.tasks is\n      negative, Hive will
    use this one as the max number of reducers when automatically determine number
    of reducers.\n    </description>\n  </property>\n  <property>\n    <name>hive.exec.pre.hooks</name>\n
    \   <value/>\n    <description>\n      Comma-separated list of pre-execution hooks
    to be invoked for each statement. \n      A pre-execution hook is specified as
    the name of a Java class which implements the \n      org.apache.hadoop.hive.ql.hooks.ExecuteWithHookContext
    interface.\n    </description>\n  </property>\n  <property>\n    <name>hive.exec.post.hooks</name>\n
    \   <value/>\n    <description>\n      Comma-separated list of post-execution
    hooks to be invoked for each statement. \n      A post-execution hook is specified
    as the name of a Java class which implements the \n      org.apache.hadoop.hive.ql.hooks.ExecuteWithHookContext
    interface.\n    </description>\n  </property>\n  <property>\n    <name>hive.exec.failure.hooks</name>\n
    \   <value/>\n    <description>\n      Comma-separated list of on-failure hooks
    to be invoked for each statement. \n      An on-failure hook is specified as the
    name of Java class which implements the \n      org.apache.hadoop.hive.ql.hooks.ExecuteWithHookContext
    interface.\n    </description>\n  </property>\n  <property>\n    <name>hive.exec.query.redactor.hooks</name>\n
    \   <value/>\n    <description>\n      Comma-separated list of hooks to be invoked
    for each query which can \n      tranform the query before it's placed in the
    job.xml file. Must be a Java class which \n      extends from the org.apache.hadoop.hive.ql.hooks.Redactor
    abstract class.\n    </description>\n  </property>\n  <property>\n    <name>hive.client.stats.publishers</name>\n
    \   <value/>\n    <description>\n      Comma-separated list of statistics publishers
    to be invoked on counters on each job. \n      A client stats publisher is specified
    as the name of a Java class which implements the \n      org.apache.hadoop.hive.ql.stats.ClientStatsPublisher
    interface.\n    </description>\n  </property>\n  <property>\n    <name>hive.ats.hook.queue.capacity</name>\n
    \   <value>64</value>\n    <description>\n      Queue size for the ATS Hook executor.
    If the number of outstanding submissions \n      to the ATS executor exceed this
    amount, the Hive ATS Hook will not try to log queries to ATS.\n    </description>\n
    \ </property>\n  <property>\n    <name>hive.exec.parallel</name>\n    <value>false</value>\n
    \   <description>Whether to execute jobs in parallel</description>\n  </property>\n
    \ <property>\n    <name>hive.exec.parallel.thread.number</name>\n    <value>8</value>\n
    \   <description>How many jobs at most can be executed in parallel</description>\n
    \ </property>\n  <property>\n    <name>hive.mapred.reduce.tasks.speculative.execution</name>\n
    \   <value>true</value>\n    <description>Whether speculative execution for reducers
    should be turned on. </description>\n  </property>\n  <property>\n    <name>hive.exec.counters.pull.interval</name>\n
    \   <value>1000</value>\n    <description>\n      The interval with which to poll
    the JobTracker for the counters the running job. \n      The smaller it is the
    more load there will be on the jobtracker, the higher it is the less granular
    the caught will be.\n    </description>\n  </property>\n  <property>\n    <name>hive.exec.dynamic.partition</name>\n
    \   <value>true</value>\n    <description>Whether or not to allow dynamic partitions
    in DML/DDL.</description>\n  </property>\n  <property>\n    <name>hive.exec.dynamic.partition.mode</name>\n
    \   <value>strict</value>\n    <description>\n      In strict mode, the user must
    specify at least one static partition\n      in case the user accidentally overwrites
    all partitions.\n      In nonstrict mode all partitions are allowed to be dynamic.\n
    \   </description>\n  </property>\n  <property>\n    <name>hive.exec.max.dynamic.partitions</name>\n
    \   <value>1000</value>\n    <description>Maximum number of dynamic partitions
    allowed to be created in total.</description>\n  </property>\n  <property>\n    <name>hive.exec.max.dynamic.partitions.pernode</name>\n
    \   <value>100</value>\n    <description>Maximum number of dynamic partitions
    allowed to be created in each mapper/reducer node.</description>\n  </property>\n
    \ <property>\n    <name>hive.exec.max.created.files</name>\n    <value>100000</value>\n
    \   <description>Maximum number of HDFS files created by all mappers/reducers
    in a MapReduce job.</description>\n  </property>\n  <property>\n    <name>hive.exec.default.partition.name</name>\n
    \   <value>__HIVE_DEFAULT_PARTITION__</value>\n    <description>\n      The default
    partition name in case the dynamic partition column value is null/empty string
    or any other values that cannot be escaped. \n      This value must not contain
    any special character used in HDFS URI (e.g., ':', '%', '/' etc). \n      The
    user has to be aware that the dynamic partition value should not contain this
    value to avoid confusions.\n    </description>\n  </property>\n  <property>\n
    \   <name>hive.lockmgr.zookeeper.default.partition.name</name>\n    <value>__HIVE_DEFAULT_ZOOKEEPER_PARTITION__</value>\n
    \   <description/>\n  </property>\n  <property>\n    <name>hive.exec.show.job.failure.debug.info</name>\n
    \   <value>true</value>\n    <description>\n      If a job fails, whether to provide
    a link in the CLI to the task with the\n      most failures, along with debugging
    hints if applicable.\n    </description>\n  </property>\n  <property>\n    <name>hive.exec.job.debug.capture.stacktraces</name>\n
    \   <value>true</value>\n    <description>\n      Whether or not stack traces
    parsed from the task logs of a sampled failed task \n      for each failed job
    should be stored in the SessionState\n    </description>\n  </property>\n  <property>\n
    \   <name>hive.exec.job.debug.timeout</name>\n    <value>30000</value>\n    <description/>\n
    \ </property>\n  <property>\n    <name>hive.exec.tasklog.debug.timeout</name>\n
    \   <value>20000</value>\n    <description/>\n  </property>\n  <property>\n    <name>hive.output.file.extension</name>\n
    \   <value/>\n    <description>\n      String used as a file extension for output
    files. \n      If not set, defaults to the codec extension for text files (e.g.
    \".gz\"), or no extension otherwise.\n    </description>\n  </property>\n  <property>\n
    \   <name>hive.testing.short.logs</name>\n    <value>false</value>\n    <description>internal
    usage only, used only in test mode. If set true, when requesting the operation
    logs the short version (generated by LogDivertAppenderForTest) will be returned</description>\n
    \ </property>\n  <property>\n    <name>hive.testing.remove.logs</name>\n    <value>true</value>\n
    \   <description>internal usage only, used only in test mode. If set false, the
    operation logs, and the operation log directory will not be removed, so they can
    be found after the test runs.</description>\n  </property>\n  <property>\n    <name>hive.exec.mode.local.auto</name>\n
    \   <value>false</value>\n    <description>Let Hive determine whether to run in
    local mode automatically</description>\n  </property>\n  <property>\n    <name>hive.exec.mode.local.auto.inputbytes.max</name>\n
    \   <value>134217728</value>\n    <description>When hive.exec.mode.local.auto
    is true, input bytes should less than this for local mode.</description>\n  </property>\n
    \ <property>\n    <name>hive.exec.mode.local.auto.input.files.max</name>\n    <value>4</value>\n
    \   <description>When hive.exec.mode.local.auto is true, the number of tasks should
    less than this for local mode.</description>\n  </property>\n  <property>\n    <name>hive.exec.drop.ignorenonexistent</name>\n
    \   <value>true</value>\n    <description>Do not report an error if DROP TABLE/VIEW/Index/Function
    specifies a non-existent table/view/function</description>\n  </property>\n  <property>\n
    \   <name>hive.ignore.mapjoin.hint</name>\n    <value>true</value>\n    <description>Ignore
    the mapjoin hint</description>\n  </property>\n  <property>\n    <name>hive.file.max.footer</name>\n
    \   <value>100</value>\n    <description>maximum number of lines for footer user
    can define for a table file</description>\n  </property>\n  <property>\n    <name>hive.resultset.use.unique.column.names</name>\n
    \   <value>true</value>\n    <description>\n      Make column names unique in
    the result set by qualifying column names with table alias if needed.\n      Table
    alias will be added to column names for queries of type \"select *\" or \n      if
    query explicitly uses table alias \"select r1.x..\".\n    </description>\n  </property>\n
    \ <property>\n    <name>fs.har.impl</name>\n    <value>org.apache.hadoop.hive.shims.HiveHarFileSystem</value>\n
    \   <description>The implementation for accessing Hadoop Archives. Note that this
    won't be applicable to Hadoop versions less than 0.20</description>\n  </property>\n
    \ <property>\n    <name>hive.metastore.db.type</name>\n    <value>DERBY</value>\n
    \   <description>\n      Expects one of [derby, oracle, mysql, mssql, postgres].\n
    \     Type of database used by the metastore. Information schema &amp; JDBCStorageHandler
    depend on it.\n    </description>\n  </property>\n  <property>\n    <name>hive.metastore.warehouse.dir</name>\n
    \   <value>/user/hive/warehouse</value>\n    <description>location of default
    database for the warehouse</description>\n  </property>\n  <property>\n    <name>hive.metastore.warehouse.external.dir</name>\n
    \   <value/>\n    <description>Default location for external tables created in
    the warehouse. If not set or null, then the normal warehouse location will be
    used as the default location.</description>\n  </property>\n  <property>\n    <name>hive.metastore.uris</name>\n
    \   <value/>\n    <description>Thrift URI for the remote metastore. Used by metastore
    client to connect to remote metastore.</description>\n  </property>\n  <property>\n
    \   <name>hive.metastore.uri.selection</name>\n    <value>RANDOM</value>\n    <description>\n
    \     Expects one of [sequential, random].\n      Determines the selection mechanism
    used by metastore client to connect to remote metastore.  SEQUENTIAL implies that
    the first valid metastore from the URIs specified as part of hive.metastore.uris
    will be picked.  RANDOM implies that the metastore will be picked randomly\n    </description>\n
    \ </property>\n  <property>\n    <name>hive.metastore.client.capability.check</name>\n
    \   <value>true</value>\n    <description>Whether to check client capabilities
    for potentially breaking API usage.</description>\n  </property>\n  <property>\n
    \   <name>hive.metastore.client.cache.enabled</name>\n    <value>false</value>\n
    \   <description>Whether to enable metastore client cache</description>\n  </property>\n
    \ <property>\n    <name>hive.metastore.client.cache.expiry.time</name>\n    <value>120s</value>\n
    \   <description>\n      Expects a time value with unit (d/day, h/hour, m/min,
    s/sec, ms/msec, us/usec, ns/nsec), which is sec if not specified.\n      Expiry
    time for metastore client cache\n    </description>\n  </property>\n  <property>\n
    \   <name>hive.metastore.client.cache.initial.capacity</name>\n    <value>50</value>\n
    \   <description>Initial capacity for metastore client cache</description>\n  </property>\n
    \ <property>\n    <name>hive.metastore.client.cache.max.capacity</name>\n    <value>50</value>\n
    \   <description>Max capacity for metastore client cache</description>\n  </property>\n
    \ <property>\n    <name>hive.metastore.client.cache.stats.enabled</name>\n    <value>false</value>\n
    \   <description>Whether to enable metastore client cache stats</description>\n
    \ </property>\n  <property>\n    <name>hive.metastore.fastpath</name>\n    <value>false</value>\n
    \   <description>Used to avoid all of the proxies and object copies in the metastore.
    \ Note, if this is set, you MUST use a local metastore (hive.metastore.uris must
    be empty) otherwise undefined and most likely undesired behavior will result</description>\n
    \ </property>\n  <property>\n    <name>hive.metastore.fshandler.threads</name>\n
    \   <value>15</value>\n    <description>Number of threads to be allocated for
    metastore handler for fs operations.</description>\n  </property>\n  <property>\n
    \   <name>hive.metastore.hbase.file.metadata.threads</name>\n    <value>1</value>\n
    \   <description>Number of threads to use to read file metadata in background
    to cache it.</description>\n  </property>\n  <property>\n    <name>hive.metastore.uri.resolver</name>\n
    \   <value/>\n    <description>If set, fully qualified class name of resolver
    for hive metastore uri's</description>\n  </property>\n  <property>\n    <name>hive.metastore.connect.retries</name>\n
    \   <value>3</value>\n    <description>Number of retries while opening a connection
    to metastore</description>\n  </property>\n  <property>\n    <name>hive.metastore.failure.retries</name>\n
    \   <value>1</value>\n    <description>Number of retries upon failure of Thrift
    metastore calls</description>\n  </property>\n  <property>\n    <name>hive.metastore.port</name>\n
    \   <value>9083</value>\n    <description>Hive metastore listener port</description>\n
    \ </property>\n  <property>\n    <name>hive.metastore.client.connect.retry.delay</name>\n
    \   <value>1s</value>\n    <description>\n      Expects a time value with unit
    (d/day, h/hour, m/min, s/sec, ms/msec, us/usec, ns/nsec), which is sec if not
    specified.\n      Number of seconds for the client to wait between consecutive
    connection attempts\n    </description>\n  </property>\n  <property>\n    <name>hive.metastore.client.socket.timeout</name>\n
    \   <value>600s</value>\n    <description>\n      Expects a time value with unit
    (d/day, h/hour, m/min, s/sec, ms/msec, us/usec, ns/nsec), which is sec if not
    specified.\n      MetaStore Client socket timeout in seconds\n    </description>\n
    \ </property>\n  <property>\n    <name>hive.metastore.client.socket.lifetime</name>\n
    \   <value>0s</value>\n    <description>\n      Expects a time value with unit
    (d/day, h/hour, m/min, s/sec, ms/msec, us/usec, ns/nsec), which is sec if not
    specified.\n      MetaStore Client socket lifetime in seconds. After this time
    is exceeded, client\n      reconnects on the next MetaStore operation. A value
    of 0s means the connection\n      has an infinite lifetime.\n    </description>\n
    \ </property>\n  <property>\n    <name>javax.jdo.option.ConnectionPassword</name>\n
    \   <value>mine</value>\n    <description>password to use against metastore database</description>\n
    \ </property>\n  <property>\n    <name>hive.metastore.ds.connection.url.hook</name>\n
    \   <value/>\n    <description>Name of the hook to use for retrieving the JDO
    connection URL. If empty, the value in javax.jdo.option.ConnectionURL is used</description>\n
    \ </property>\n  <property>\n    <name>javax.jdo.option.Multithreaded</name>\n
    \   <value>true</value>\n    <description>Set this to true if multiple threads
    access metastore through JDO concurrently.</description>\n  </property>\n  <property>\n
    \   <name>javax.jdo.option.ConnectionURL</name>\n    <value>jdbc:derby://fom-hadoop-03.fritz.box:1527/metastore_db;create=true</value>\n
    \   <description>\n      JDBC connect string for a JDBC metastore.\n      To use
    SSL to encrypt/authenticate the connection, provide database-specific SSL flag
    in the connection URL.\n      For example, jdbc:postgresql://myhost/db?ssl=true
    for postgres database.\n    </description>\n  </property>\n  <property>\n    <name>hive.metastore.dbaccess.ssl.properties</name>\n
    \   <value/>\n    <description>\n      Comma-separated SSL properties for metastore
    to access database when JDO connection URL\n      enables SSL access. e.g. javax.net.ssl.trustStore=/tmp/truststore,javax.net.ssl.trustStorePassword=pwd.\n
    \   </description>\n  </property>\n  <property>\n    <name>hive.hmshandler.retry.attempts</name>\n
    \   <value>10</value>\n    <description>The number of times to retry a HMSHandler
    call if there were a connection error.</description>\n  </property>\n  <property>\n
    \   <name>hive.hmshandler.retry.interval</name>\n    <value>2000ms</value>\n    <description>\n
    \     Expects a time value with unit (d/day, h/hour, m/min, s/sec, ms/msec, us/usec,
    ns/nsec), which is msec if not specified.\n      The time between HMSHandler retry
    attempts on failure.\n    </description>\n  </property>\n  <property>\n    <name>hive.hmshandler.force.reload.conf</name>\n
    \   <value>false</value>\n    <description>\n      Whether to force reloading
    of the HMSHandler configuration (including\n      the connection URL, before the
    next metastore query that accesses the\n      datastore. Once reloaded, this value
    is reset to false. Used for\n      testing only.\n    </description>\n  </property>\n
    \ <property>\n    <name>hive.metastore.server.max.message.size</name>\n    <value>104857600</value>\n
    \   <description>Maximum message size in bytes a HMS will accept.</description>\n
    \ </property>\n  <property>\n    <name>hive.metastore.server.min.threads</name>\n
    \   <value>200</value>\n    <description>Minimum number of worker threads in the
    Thrift server's pool.</description>\n  </property>\n  <property>\n    <name>hive.metastore.server.max.threads</name>\n
    \   <value>1000</value>\n    <description>Maximum number of worker threads in
    the Thrift server's pool.</description>\n  </property>\n  <property>\n    <name>hive.metastore.server.tcp.keepalive</name>\n
    \   <value>true</value>\n    <description>Whether to enable TCP keepalive for
    the metastore server. Keepalive will prevent accumulation of half-open connections.</description>\n
    \ </property>\n  <property>\n    <name>hive.metastore.wm.default.pool.size</name>\n
    \   <value>4</value>\n    <description>\n      The size of a default pool to create
    when creating an empty resource plan;\n      If not positive, no default pool
    will be created.\n    </description>\n  </property>\n  <property>\n    <name>hive.metastore.archive.intermediate.original</name>\n
    \   <value>_INTERMEDIATE_ORIGINAL</value>\n    <description>\n      Intermediate
    dir suffixes used for archiving. Not important what they\n      are, as long as
    collisions are avoided\n    </description>\n  </property>\n  <property>\n    <name>hive.metastore.archive.intermediate.archived</name>\n
    \   <value>_INTERMEDIATE_ARCHIVED</value>\n    <description/>\n  </property>\n
    \ <property>\n    <name>hive.metastore.archive.intermediate.extracted</name>\n
    \   <value>_INTERMEDIATE_EXTRACTED</value>\n    <description/>\n  </property>\n
    \ <property>\n    <name>hive.metastore.kerberos.keytab.file</name>\n    <value/>\n
    \   <description>The path to the Kerberos Keytab file containing the metastore
    Thrift server's service principal.</description>\n  </property>\n  <property>\n
    \   <name>hive.metastore.kerberos.principal</name>\n    <value>hive-metastore/_HOST@EXAMPLE.COM</value>\n
    \   <description>\n      The service principal for the metastore Thrift server.
    \n      The special string _HOST will be replaced automatically with the correct
    host name.\n    </description>\n  </property>\n  <property>\n    <name>hive.metastore.client.kerberos.principal</name>\n
    \   <value/>\n    <description>The Kerberos principal associated with the HA cluster
    of hcat_servers.</description>\n  </property>\n  <property>\n    <name>hive.metastore.sasl.enabled</name>\n
    \   <value>false</value>\n    <description>If true, the metastore Thrift interface
    will be secured with SASL. Clients must authenticate with Kerberos.</description>\n
    \ </property>\n  <property>\n    <name>hive.metastore.thrift.framed.transport.enabled</name>\n
    \   <value>false</value>\n    <description>If true, the metastore Thrift interface
    will use TFramedTransport. When false (default) a standard TTransport is used.</description>\n
    \ </property>\n  <property>\n    <name>hive.metastore.thrift.compact.protocol.enabled</name>\n
    \   <value>false</value>\n    <description>\n      If true, the metastore Thrift
    interface will use TCompactProtocol. When false (default) TBinaryProtocol will
    be used.\n      Setting it to true will break compatibility with older clients
    running TBinaryProtocol.\n    </description>\n  </property>\n  <property>\n    <name>hive.metastore.token.signature</name>\n
    \   <value/>\n    <description>The delegation token service name to match when
    selecting a token from the current user's tokens.</description>\n  </property>\n
    \ <property>\n    <name>hive.cluster.delegation.token.store.class</name>\n    <!--
    <value>org.apache.hadoop.hive.thrift.MemoryTokenStore</value> -->\n    <value>org.apache.hadoop.hive.thrift.ZooKeeperTokenStore</value>\n
    \   <description>The delegation token store implementation. Set to org.apache.hadoop.hive.thrift.ZooKeeperTokenStore
    for load-balanced cluster.</description>\n  </property>\n  <property>\n    <name>hive.cluster.delegation.token.store.zookeeper.connectString</name>\n
    \   <value>fom-hadoop-03.fritz.box:2181,fom-hadoop-04.fritz.box:2181,fom-hadoop-05.fritz.box:2181</value>\n
    \   <description>\n      The ZooKeeper token store connect string. You can re-use
    the configuration value\n      set in hive.zookeeper.quorum, by leaving this parameter
    unset.\n    </description>\n  </property>\n  <property>\n    <name>hive.cluster.delegation.token.store.zookeeper.znode</name>\n
    \   <value>/hivedelegation</value>\n    <description>\n      The root path for
    token store data. Note that this is used by both HiveServer2 and\n      MetaStore
    to store delegation Token. One directory gets created for each of them.\n      The
    final directory names would have the servername appended to it (HIVESERVER2,\n
    \     METASTORE).\n    </description>\n  </property>\n  <property>\n    <name>hive.cluster.delegation.token.store.zookeeper.acl</name>\n
    \   <value/>\n    <description>\n      ACL for token store entries. Comma separated
    list of ACL entries. For example:\n      sasl:hive/host1@MY.DOMAIN:cdrwa,sasl:hive/host2@MY.DOMAIN:cdrwa\n
    \     Defaults to all permissions for the hiveserver2/metastore process user.\n
    \   </description>\n  </property>\n  <property>\n    <name>hive.metastore.cache.pinobjtypes</name>\n
    \   <value>Table,StorageDescriptor,SerDeInfo,Partition,Database,Type,FieldSchema,Order</value>\n
    \   <description>List of comma separated metastore object types that should be
    pinned in the cache</description>\n  </property>\n  <property>\n    <name>datanucleus.connectionPoolingType</name>\n
    \   <value>HikariCP</value>\n    <description>\n      Expects one of [bonecp,
    dbcp, hikaricp, none].\n      Specify connection pool library for datanucleus\n
    \   </description>\n  </property>\n  <property>\n    <name>datanucleus.connectionPool.maxPoolSize</name>\n
    \   <value>10</value>\n    <description>\n      Specify the maximum number of
    connections in the connection pool. Note: The configured size will be used by\n
    \     2 connection pools (TxnHandler and ObjectStore). When configuring the max
    connection pool size, it is\n      recommended to take into account the number
    of metastore instances and the number of HiveServer2 instances\n      configured
    with embedded metastore. To get optimal performance, set config to meet the following
    condition\n      (2 * pool_size * metastore_instances + 2 * pool_size * HS2_instances_with_embedded_metastore)
    = \n      (2 * physical_core_count + hard_disk_count).\n    </description>\n  </property>\n
    \ <property>\n    <name>datanucleus.rdbms.initializeColumnInfo</name>\n    <value>NONE</value>\n
    \   <description>initializeColumnInfo setting for DataNucleus; set to NONE at
    least on Postgres.</description>\n  </property>\n  <property>\n    <name>datanucleus.schema.validateTables</name>\n
    \   <value>false</value>\n    <description>validates existing schema against code.
    turn this on if you want to verify existing schema</description>\n  </property>\n
    \ <property>\n    <name>datanucleus.schema.validateColumns</name>\n    <value>false</value>\n
    \   <description>validates existing schema against code. turn this on if you want
    to verify existing schema</description>\n  </property>\n  <property>\n    <name>datanucleus.schema.validateConstraints</name>\n
    \   <value>false</value>\n    <description>validates existing schema against code.
    turn this on if you want to verify existing schema</description>\n  </property>\n
    \ <property>\n    <name>datanucleus.storeManagerType</name>\n    <value>rdbms</value>\n
    \   <description>metadata store type</description>\n  </property>\n  <property>\n
    \   <name>datanucleus.schema.autoCreateAll</name>\n    <value>false</value>\n
    \   <description>Auto creates necessary schema on a startup if one doesn't exist.
    Set this to false, after creating it once.To enable auto create also set hive.metastore.schema.verification=false.
    Auto creation is not recommended for production use cases, run schematool command
    instead.</description>\n  </property>\n  <property>\n    <name>hive.metastore.schema.verification</name>\n
    \   <value>true</value>\n    <description>\n      Enforce metastore schema version
    consistency.\n      True: Verify that version information stored in is compatible
    with one from Hive jars.  Also disable automatic\n            schema migration
    attempt. Users are required to manually migrate schema after Hive upgrade which
    ensures\n            proper metastore schema migration. (Default)\n      False:
    Warn if the version information stored in metastore doesn't match with one from
    in Hive jars.\n    </description>\n  </property>\n  <property>\n    <name>hive.metastore.schema.verification.record.version</name>\n
    \   <value>false</value>\n    <description>\n      When true the current MS version
    is recorded in the VERSION table. If this is disabled and verification is\n       enabled
    the MS will be unusable.\n    </description>\n  </property>\n  <property>\n    <name>hive.metastore.schema.info.class</name>\n
    \   <value>org.apache.hadoop.hive.metastore.MetaStoreSchemaInfo</value>\n    <description>\n
    \     Fully qualified class name for the metastore schema information class \n
    \     which is used by schematool to fetch the schema information.\n       This
    class should implement the IMetaStoreSchemaInfo interface\n    </description>\n
    \ </property>\n  <property>\n    <name>datanucleus.transactionIsolation</name>\n
    \   <value>read-committed</value>\n    <description>Default transaction isolation
    level for identity generation.</description>\n  </property>\n  <property>\n    <name>datanucleus.cache.level2</name>\n
    \   <value>false</value>\n    <description>Use a level 2 cache. Turn this off
    if metadata is changed independently of Hive metastore server</description>\n
    \ </property>\n  <property>\n    <name>datanucleus.cache.level2.type</name>\n
    \   <value>none</value>\n    <description/>\n  </property>\n  <property>\n    <name>datanucleus.identifierFactory</name>\n
    \   <value>datanucleus1</value>\n    <description>\n      Name of the identifier
    factory to use when generating table/column names etc. \n      'datanucleus1'
    is used for backward compatibility with DataNucleus v1\n    </description>\n  </property>\n
    \ <property>\n    <name>datanucleus.rdbms.useLegacyNativeValueStrategy</name>\n
    \   <value>true</value>\n    <description/>\n  </property>\n  <property>\n    <name>datanucleus.plugin.pluginRegistryBundleCheck</name>\n
    \   <value>LOG</value>\n    <description>Defines what happens when plugin bundles
    are found and are duplicated [EXCEPTION|LOG|NONE]</description>\n  </property>\n
    \ <property>\n    <name>hive.metastore.batch.retrieve.max</name>\n    <value>300</value>\n
    \   <description>\n      Maximum number of objects (tables/partitions) can be
    retrieved from metastore in one batch. \n      The higher the number, the less
    the number of round trips is needed to the Hive metastore server, \n      but
    it may also cause higher memory requirement at the client side.\n    </description>\n
    \ </property>\n  <property>\n    <name>hive.metastore.batch.retrieve.table.partition.max</name>\n
    \   <value>1000</value>\n    <description>Maximum number of objects that metastore
    internally retrieves in one batch.</description>\n  </property>\n  <property>\n
    \   <name>hive.metastore.init.hooks</name>\n    <value/>\n    <description>\n
    \     A comma separated list of hooks to be invoked at the beginning of HMSHandler
    initialization. \n      An init hook is specified as the name of Java class which
    extends org.apache.hadoop.hive.metastore.MetaStoreInitListener.\n    </description>\n
    \ </property>\n  <property>\n    <name>hive.metastore.pre.event.listeners</name>\n
    \   <value/>\n    <description>List of comma separated listeners for metastore
    events.</description>\n  </property>\n  <property>\n    <name>hive.metastore.event.listeners</name>\n
    \   <value/>\n    <description>A comma separated list of Java classes that implement
    the org.apache.hadoop.hive.metastore.MetaStoreEventListener interface. The metastore
    event and corresponding listener method will be invoked in separate JDO transactions.
    Alternatively, configure hive.metastore.transactional.event.listeners to ensure
    both are invoked in same JDO transaction.</description>\n  </property>\n  <property>\n
    \   <name>hive.metastore.transactional.event.listeners</name>\n    <value/>\n
    \   <description>A comma separated list of Java classes that implement the org.apache.hadoop.hive.metastore.MetaStoreEventListener
    interface. Both the metastore event and corresponding listener method will be
    invoked in the same JDO transaction.</description>\n  </property>\n  <property>\n
    \   <name>hive.notification.sequence.lock.max.retries</name>\n    <value>5</value>\n
    \   <description>Number of retries required to acquire a lock when getting the
    next notification sequential ID for entries in the NOTIFICATION_LOG table.</description>\n
    \ </property>\n  <property>\n    <name>hive.notification.sequence.lock.retry.sleep.interval</name>\n
    \   <value>500</value>\n    <description>\n      Expects a time value with unit
    (d/day, h/hour, m/min, s/sec, ms/msec, us/usec, ns/nsec), which is msec if not
    specified.\n      Sleep interval between retries to acquire a notification lock
    as described part of property NOTIFICATION_SEQUENCE_LOCK_MAX_RETRIES\n    </description>\n
    \ </property>\n  <property>\n    <name>hive.metastore.event.db.listener.timetolive</name>\n
    \   <value>86400s</value>\n    <description>\n      Expects a time value with
    unit (d/day, h/hour, m/min, s/sec, ms/msec, us/usec, ns/nsec), which is sec if
    not specified.\n      time after which events will be removed from the database
    listener queue\n    </description>\n  </property>\n  <property>\n    <name>hive.metastore.event.db.notification.api.auth</name>\n
    \   <value>false</value>\n    <description>\n      Should metastore do authorization
    against database notification related APIs such as get_next_notification.\n      If
    set to true, then only the superusers in proxy settings have the permission\n
    \   </description>\n  </property>\n  <property>\n    <name>hive.metastore.authorization.storage.checks</name>\n
    \   <value>false</value>\n    <description>\n      Should the metastore do authorization
    checks against the underlying storage (usually hdfs) \n      for operations like
    drop-partition (disallow the drop-partition if the user in\n      question doesn't
    have permissions to delete the corresponding directory\n      on the storage).\n
    \   </description>\n  </property>\n  <property>\n    <name>hive.metastore.authorization.storage.check.externaltable.drop</name>\n
    \   <value>true</value>\n    <description>\n      Should StorageBasedAuthorization
    check permission of the storage before dropping external table.\n      StorageBasedAuthorization
    already does this check for managed table. For external table however,\n      anyone
    who has read permission of the directory could drop external table, which is surprising.\n
    \     The flag is set to false by default to maintain backward compatibility.\n
    \   </description>\n  </property>\n  <property>\n    <name>hive.metastore.event.clean.freq</name>\n
    \   <value>0s</value>\n    <description>\n      Expects a time value with unit
    (d/day, h/hour, m/min, s/sec, ms/msec, us/usec, ns/nsec), which is sec if not
    specified.\n      Frequency at which timer task runs to purge expired events in
    metastore.\n    </description>\n  </property>\n  <property>\n    <name>hive.metastore.event.expiry.duration</name>\n
    \   <value>0s</value>\n    <description>\n      Expects a time value with unit
    (d/day, h/hour, m/min, s/sec, ms/msec, us/usec, ns/nsec), which is sec if not
    specified.\n      Duration after which events expire from events table\n    </description>\n
    \ </property>\n  <property>\n    <name>hive.metastore.event.message.factory</name>\n
    \   <value>org.apache.hadoop.hive.metastore.messaging.json.JSONMessageFactory</value>\n
    \   <description>Factory class for making encoding and decoding messages in the
    events generated.</description>\n  </property>\n  <property>\n    <name>hive.metastore.execute.setugi</name>\n
    \   <value>true</value>\n    <description>\n      In unsecure mode, setting this
    property to true will cause the metastore to execute DFS operations using \n      the
    client's reported user and group permissions. Note that this property must be
    set on \n      both the client and server sides. Further note that its best effort.
    \n      If client sets its to true and server sets it to false, client setting
    will be ignored.\n    </description>\n  </property>\n  <property>\n    <name>hive.metastore.partition.name.whitelist.pattern</name>\n
    \   <value/>\n    <description>Partition names will be checked against this regex
    pattern and rejected if not matched.</description>\n  </property>\n  <property>\n
    \   <name>hive.metastore.integral.jdo.pushdown</name>\n    <value>false</value>\n
    \   <description>\n      Allow JDO query pushdown for integral partition columns
    in metastore. Off by default. This\n      improves metastore perf for integral
    columns, especially if there's a large number of partitions.\n      However, it
    doesn't work correctly with integral values that are not normalized (e.g. have\n
    \     leading zeroes, like 0012). If metastore direct SQL is enabled and works,
    this optimization\n      is also irrelevant.\n    </description>\n  </property>\n
    \ <property>\n    <name>hive.metastore.try.direct.sql</name>\n    <value>true</value>\n
    \   <description>\n      Whether the Hive metastore should try to use direct SQL
    queries instead of the\n      DataNucleus for certain read paths. This can improve
    metastore performance when\n      fetching many partitions or column statistics
    by orders of magnitude; however, it\n      is not guaranteed to work on all RDBMS-es
    and all versions. In case of SQL failures,\n      the metastore will fall back
    to the DataNucleus, so it's safe even if SQL doesn't\n      work for all queries
    on your datastore. If all SQL queries fail (for example, your\n      metastore
    is backed by MongoDB), you might want to disable this to save the\n      try-and-fall-back
    cost.\n    </description>\n  </property>\n  <property>\n    <name>hive.metastore.direct.sql.batch.size</name>\n
    \   <value>0</value>\n    <description>\n      Batch size for partition and other
    object retrieval from the underlying DB in direct\n      SQL. For some DBs like
    Oracle and MSSQL, there are hardcoded or perf-based limitations\n      that necessitate
    this. For DBs that can handle the queries, this isn't necessary and\n      may
    impede performance. -1 means no batching, 0 means automatic batching.\n    </description>\n
    \ </property>\n  <property>\n    <name>hive.metastore.try.direct.sql.ddl</name>\n
    \   <value>true</value>\n    <description>\n      Same as hive.metastore.try.direct.sql,
    for read statements within a transaction that\n      modifies metastore data.
    Due to non-standard behavior in Postgres, if a direct SQL\n      select query
    has incorrect syntax or something similar inside a transaction, the\n      entire
    transaction will fail and fall-back to DataNucleus will not be possible. You\n
    \     should disable the usage of direct SQL inside transactions if that happens
    in your case.\n    </description>\n  </property>\n  <property>\n    <name>hive.direct.sql.max.query.length</name>\n
    \   <value>100</value>\n    <description>\n      The maximum\n       size of a
    query string (in KB).\n    </description>\n  </property>\n  <property>\n    <name>hive.direct.sql.max.elements.in.clause</name>\n
    \   <value>1000</value>\n    <description>\n      The maximum number of values
    in a IN clause. Once exceeded, it will be broken into\n       multiple OR separated
    IN clauses.\n    </description>\n  </property>\n  <property>\n    <name>hive.direct.sql.max.elements.values.clause</name>\n
    \   <value>1000</value>\n    <description>The maximum number of values in a VALUES
    clause for INSERT statement.</description>\n  </property>\n  <property>\n    <name>hive.metastore.orm.retrieveMapNullsAsEmptyStrings</name>\n
    \   <value>false</value>\n    <description>Thrift does not support nulls in maps,
    so any nulls present in maps retrieved from ORM must either be pruned or converted
    to empty strings. Some backing dbs such as Oracle persist empty strings as nulls,
    so we should set this parameter if we wish to reverse that behaviour. For others,
    pruning is the correct behaviour</description>\n  </property>\n  <property>\n
    \   <name>hive.metastore.disallow.incompatible.col.type.changes</name>\n    <value>true</value>\n
    \   <description>\n      If true (default is false), ALTER TABLE operations which
    change the type of a\n      column (say STRING) to an incompatible type (say MAP)
    are disallowed.\n      RCFile default SerDe (ColumnarSerDe) serializes the values
    in such a way that the\n      datatypes can be converted from string to any type.
    The map is also serialized as\n      a string, which can be read as a string as
    well. However, with any binary\n      serialization, this is not true. Blocking
    the ALTER TABLE prevents ClassCastExceptions\n      when subsequently trying to
    access old partitions.\n      \n      Primitive types like INT, STRING, BIGINT,
    etc., are compatible with each other and are\n      not blocked.\n      \n      See
    HIVE-4409 for more details.\n    </description>\n  </property>\n  <property>\n
    \   <name>hive.metastore.limit.partition.request</name>\n    <value>-1</value>\n
    \   <description>\n      This limits the number of partitions that can be requested
    from the metastore for a given table.\n      The default value \"-1\" means no
    limit.\n    </description>\n  </property>\n  <property>\n    <name>hive.table.parameters.default</name>\n
    \   <value/>\n    <description>Default property values for newly created tables</description>\n
    \ </property>\n  <property>\n    <name>hive.ddl.createtablelike.properties.whitelist</name>\n
    \   <value/>\n    <description>Table Properties to copy over when executing a
    Create Table Like.</description>\n  </property>\n  <property>\n    <name>hive.metastore.rawstore.impl</name>\n
    \   <value>org.apache.hadoop.hive.metastore.ObjectStore</value>\n    <description>\n
    \     Name of the class that implements org.apache.hadoop.hive.metastore.rawstore
    interface. \n      This class is used to store and retrieval of raw metadata objects
    such as table, database\n    </description>\n  </property>\n  <property>\n    <name>hive.metastore.txn.store.impl</name>\n
    \   <value>org.apache.hadoop.hive.metastore.txn.CompactionTxnHandler</value>\n
    \   <description>Name of class that implements org.apache.hadoop.hive.metastore.txn.TxnStore.
    \ This class is used to store and retrieve transactions and locks</description>\n
    \ </property>\n  <property>\n    <name>javax.jdo.option.ConnectionDriverName</name>\n
    \   <value>org.apache.derby.jdbc.ClientDriver</value>\n    <description>Driver
    class name for a JDBC metastore</description>\n  </property>\n  <property>\n    <name>javax.jdo.PersistenceManagerFactoryClass</name>\n
    \   <value>org.datanucleus.api.jdo.JDOPersistenceManagerFactory</value>\n    <description>class
    implementing the jdo persistence</description>\n  </property>\n  <property>\n
    \   <name>hive.metastore.expression.proxy</name>\n    <value>org.apache.hadoop.hive.ql.optimizer.ppr.PartitionExpressionForMetastore</value>\n
    \   <description/>\n  </property>\n  <property>\n    <name>javax.jdo.option.DetachAllOnCommit</name>\n
    \   <value>true</value>\n    <description>Detaches all objects from session so
    that they can be used after transaction is committed</description>\n  </property>\n
    \ <property>\n    <name>javax.jdo.option.NonTransactionalRead</name>\n    <value>true</value>\n
    \   <description>Reads outside of transactions</description>\n  </property>\n
    \ <property>\n    <name>javax.jdo.option.ConnectionUserName</name>\n    <value>APP</value>\n
    \   <description>Username to use against metastore database</description>\n  </property>\n
    \ <property>\n    <name>hive.metastore.end.function.listeners</name>\n    <value/>\n
    \   <description>List of comma separated listeners for the end of metastore functions.</description>\n
    \ </property>\n  <property>\n    <name>hive.metastore.partition.inherit.table.properties</name>\n
    \   <value/>\n    <description>\n      List of comma separated keys occurring
    in table properties which will get inherited to newly created partitions. \n      *
    implies all the keys will get inherited.\n    </description>\n  </property>\n
    \ <property>\n    <name>hive.metastore.filter.hook</name>\n    <value>org.apache.hadoop.hive.metastore.DefaultMetaStoreFilterHookImpl</value>\n
    \   <description>Metastore hook class for filtering the metadata read results.
    If hive.security.authorization.manageris set to instance of HiveAuthorizerFactory,
    then this value is ignored.</description>\n  </property>\n  <property>\n    <name>hive.metastore.dml.events</name>\n
    \   <value>false</value>\n    <description>If true, the metastore will be asked
    to fire events for DML operations</description>\n  </property>\n  <property>\n
    \   <name>hive.metastore.client.drop.partitions.using.expressions</name>\n    <value>true</value>\n
    \   <description>Choose whether dropping partitions with HCatClient pushes the
    partition-predicate to the metastore, or drops partitions iteratively</description>\n
    \ </property>\n  <property>\n    <name>hive.metastore.aggregate.stats.cache.enabled</name>\n
    \   <value>true</value>\n    <description>Whether aggregate stats caching is enabled
    or not.</description>\n  </property>\n  <property>\n    <name>hive.metastore.aggregate.stats.cache.size</name>\n
    \   <value>10000</value>\n    <description>Maximum number of aggregate stats nodes
    that we will place in the metastore aggregate stats cache.</description>\n  </property>\n
    \ <property>\n    <name>hive.metastore.aggregate.stats.cache.max.partitions</name>\n
    \   <value>10000</value>\n    <description>Maximum number of partitions that are
    aggregated per cache node.</description>\n  </property>\n  <property>\n    <name>hive.metastore.aggregate.stats.cache.fpp</name>\n
    \   <value>0.01</value>\n    <description>Maximum false positive probability for
    the Bloom Filter used in each aggregate stats cache node (default 1%).</description>\n
    \ </property>\n  <property>\n    <name>hive.metastore.aggregate.stats.cache.max.variance</name>\n
    \   <value>0.01</value>\n    <description>Maximum tolerable variance in number
    of partitions between a cached node and our request (default 1%).</description>\n
    \ </property>\n  <property>\n    <name>hive.metastore.aggregate.stats.cache.ttl</name>\n
    \   <value>600s</value>\n    <description>\n      Expects a time value with unit
    (d/day, h/hour, m/min, s/sec, ms/msec, us/usec, ns/nsec), which is sec if not
    specified.\n      Number of seconds for a cached node to be active in the cache
    before they become stale.\n    </description>\n  </property>\n  <property>\n    <name>hive.metastore.aggregate.stats.cache.max.writer.wait</name>\n
    \   <value>5000ms</value>\n    <description>\n      Expects a time value with
    unit (d/day, h/hour, m/min, s/sec, ms/msec, us/usec, ns/nsec), which is msec if
    not specified.\n      Number of milliseconds a writer will wait to acquire the
    writelock before giving up.\n    </description>\n  </property>\n  <property>\n
    \   <name>hive.metastore.aggregate.stats.cache.max.reader.wait</name>\n    <value>1000ms</value>\n
    \   <description>\n      Expects a time value with unit (d/day, h/hour, m/min,
    s/sec, ms/msec, us/usec, ns/nsec), which is msec if not specified.\n      Number
    of milliseconds a reader will wait to acquire the readlock before giving up.\n
    \   </description>\n  </property>\n  <property>\n    <name>hive.metastore.aggregate.stats.cache.max.full</name>\n
    \   <value>0.9</value>\n    <description>Maximum cache full % after which the
    cache cleaner thread kicks in.</description>\n  </property>\n  <property>\n    <name>hive.metastore.aggregate.stats.cache.clean.until</name>\n
    \   <value>0.8</value>\n    <description>The cleaner thread cleans until cache
    reaches this % full size.</description>\n  </property>\n  <property>\n    <name>hive.metastore.metrics.enabled</name>\n
    \   <value>false</value>\n    <description>Enable metrics on the metastore.</description>\n
    \ </property>\n  <property>\n    <name>hive.metastore.initial.metadata.count.enabled</name>\n
    \   <value>true</value>\n    <description>Enable a metadata count at metastore
    startup for metrics.</description>\n  </property>\n  <property>\n    <name>hive.metastore.use.SSL</name>\n
    \   <value>false</value>\n    <description>Set this to true for using SSL encryption
    in HMS server.</description>\n  </property>\n  <property>\n    <name>hive.metastore.keystore.path</name>\n
    \   <value/>\n    <description>Metastore SSL certificate keystore location.</description>\n
    \ </property>\n  <property>\n    <name>hive.metastore.keystore.password</name>\n
    \   <value/>\n    <description>Metastore SSL certificate keystore password.</description>\n
    \ </property>\n  <property>\n    <name>hive.metastore.truststore.path</name>\n
    \   <value/>\n    <description>Metastore SSL certificate truststore location.</description>\n
    \ </property>\n  <property>\n    <name>hive.metastore.truststore.password</name>\n
    \   <value/>\n    <description>Metastore SSL certificate truststore password.</description>\n
    \ </property>\n  <property>\n    <name>hive.metadata.export.location</name>\n
    \   <value/>\n    <description>\n      When used in conjunction with the org.apache.hadoop.hive.ql.parse.MetaDataExportListener
    pre event listener, \n      it is the location to which the metadata will be exported.
    The default is an empty string, which results in the \n      metadata being exported
    to the current user's home directory on HDFS.\n    </description>\n  </property>\n
    \ <property>\n    <name>hive.metadata.move.exported.metadata.to.trash</name>\n
    \   <value>true</value>\n    <description>\n      When used in conjunction with
    the org.apache.hadoop.hive.ql.parse.MetaDataExportListener pre event listener,
    \n      this setting determines if the metadata that is exported will subsequently
    be moved to the user's trash directory \n      alongside the dropped table data.
    This ensures that the metadata will be cleaned up along with the dropped table
    data.\n    </description>\n  </property>\n  <property>\n    <name>hive.cli.errors.ignore</name>\n
    \   <value>false</value>\n    <description/>\n  </property>\n  <property>\n    <name>hive.cli.print.current.db</name>\n
    \   <value>false</value>\n    <description>Whether to include the current database
    in the Hive prompt.</description>\n  </property>\n  <property>\n    <name>hive.cli.prompt</name>\n
    \   <value>hive</value>\n    <description>\n      Command line prompt configuration
    value. Other hiveconf can be used in this configuration value. \n      Variable
    substitution will only be invoked at the Hive CLI startup.\n    </description>\n
    \ </property>\n  <property>\n    <name>hive.cli.pretty.output.num.cols</name>\n
    \   <value>-1</value>\n    <description>\n      The number of columns to use when
    formatting output generated by the DESCRIBE PRETTY table_name command.\n      If
    the value of this property is -1, then Hive will use the auto-detected terminal
    width.\n    </description>\n  </property>\n  <property>\n    <name>hive.metastore.fs.handler.class</name>\n
    \   <value>org.apache.hadoop.hive.metastore.HiveMetaStoreFsImpl</value>\n    <description/>\n
    \ </property>\n  <property>\n    <name>hive.session.id</name>\n    <value/>\n
    \   <description/>\n  </property>\n  <property>\n    <name>hive.session.silent</name>\n
    \   <value>false</value>\n    <description/>\n  </property>\n  <property>\n    <name>hive.local.time.zone</name>\n
    \   <value>LOCAL</value>\n    <description>\n      Sets the time-zone for displaying
    and interpreting time stamps. If this property value is set to\n      LOCAL, it
    is not specified, or it is not a correct time-zone, the system default time-zone
    will be\n       used instead. Time-zone IDs can be specified as region-based zone
    IDs (based on IANA time-zone data),\n      abbreviated zone IDs, or offset IDs.\n
    \   </description>\n  </property>\n  <property>\n    <name>hive.session.history.enabled</name>\n
    \   <value>false</value>\n    <description>Whether to log Hive query, query plan,
    runtime statistics etc.</description>\n  </property>\n  <property>\n    <name>hive.query.string</name>\n
    \   <value/>\n    <description>Query being executed (might be multiple per a session)</description>\n
    \ </property>\n  <property>\n    <name>hive.query.id</name>\n    <value/>\n    <description>ID
    for query being executed (might be multiple per a session)</description>\n  </property>\n
    \ <property>\n    <name>hive.jobname.length</name>\n    <value>50</value>\n    <description>max
    jobname length</description>\n  </property>\n  <property>\n    <name>hive.jar.path</name>\n
    \   <value/>\n    <description>The location of hive_cli.jar that is used when
    submitting jobs in a separate jvm.</description>\n  </property>\n  <property>\n
    \   <name>hive.aux.jars.path</name>\n    <value/>\n    <description>The location
    of the plugin jars that contain implementations of user defined functions and
    serdes.</description>\n  </property>\n  <property>\n    <name>hive.reloadable.aux.jars.path</name>\n
    \   <value/>\n    <description>\n      The locations of the plugin jars, which
    can be a comma-separated folders or jars. Jars can be renewed\n      by executing
    reload command. And these jars can be used as the auxiliary classes like creating
    a UDF or SerDe.\n    </description>\n  </property>\n  <property>\n    <name>hive.added.files.path</name>\n
    \   <value/>\n    <description>This an internal parameter.</description>\n  </property>\n
    \ <property>\n    <name>hive.added.jars.path</name>\n    <value/>\n    <description>This
    an internal parameter.</description>\n  </property>\n  <property>\n    <name>hive.added.archives.path</name>\n
    \   <value/>\n    <description>This an internal parameter.</description>\n  </property>\n
    \ <property>\n    <name>hive.resource.use.hdfs.location</name>\n    <value>true</value>\n
    \   <description>Reference HDFS based files/jars directly instead of copy to session
    based HDFS scratch directory, to make distributed cache more useful.</description>\n
    \ </property>\n  <property>\n    <name>hive.auto.progress.timeout</name>\n    <value>0s</value>\n
    \   <description>\n      Expects a time value with unit (d/day, h/hour, m/min,
    s/sec, ms/msec, us/usec, ns/nsec), which is sec if not specified.\n      How long
    to run autoprogressor for the script/UDTF operators.\n      Set to 0 for forever.\n
    \   </description>\n  </property>\n  <property>\n    <name>hive.script.auto.progress</name>\n
    \   <value>false</value>\n    <description>\n      Whether Hive Transform/Map/Reduce
    Clause should automatically send progress information to TaskTracker \n      to
    avoid the task getting killed because of inactivity.  Hive sends progress information
    when the script is \n      outputting to stderr.  This option removes the need
    of periodically producing stderr messages, \n      but users should be cautious
    because this may prevent infinite loops in the scripts to be killed by TaskTracker.\n
    \   </description>\n  </property>\n  <property>\n    <name>hive.script.operator.id.env.var</name>\n
    \   <value>HIVE_SCRIPT_OPERATOR_ID</value>\n    <description>\n      Name of the
    environment variable that holds the unique script operator ID in the user's \n
    \     transform function (the custom mapper/reducer that the user has specified
    in the query)\n    </description>\n  </property>\n  <property>\n    <name>hive.script.operator.truncate.env</name>\n
    \   <value>false</value>\n    <description>Truncate each environment variable
    for external script in scripts operator to 20KB (to fit system limits)</description>\n
    \ </property>\n  <property>\n    <name>hive.script.operator.env.blacklist</name>\n
    \   <value>hive.txn.valid.txns,hive.txn.tables.valid.writeids,hive.txn.valid.writeids,hive.script.operator.env.blacklist</value>\n
    \   <description>Comma separated list of keys from the configuration file not
    to convert to environment variables when invoking the script operator</description>\n
    \ </property>\n  <property>\n    <name>hive.strict.checks.orderby.no.limit</name>\n
    \   <value>false</value>\n    <description>\n      Enabling strict large query
    checks disallows the following:\n        Orderby without limit.\n      Note that
    this check currently does not consider data size, only the query pattern.\n    </description>\n
    \ </property>\n  <property>\n    <name>hive.strict.checks.no.partition.filter</name>\n
    \   <value>false</value>\n    <description>\n      Enabling strict large query
    checks disallows the following:\n        No partition being picked up for a query
    against partitioned table.\n      Note that this check currently does not consider
    data size, only the query pattern.\n    </description>\n  </property>\n  <property>\n
    \   <name>hive.strict.checks.type.safety</name>\n    <value>true</value>\n    <description>\n
    \     Enabling strict type safety checks disallows the following:\n        Comparing
    bigints and strings.\n        Comparing bigints and doubles.\n    </description>\n
    \ </property>\n  <property>\n    <name>hive.strict.checks.cartesian.product</name>\n
    \   <value>false</value>\n    <description>\n      Enabling strict Cartesian join
    checks disallows the following:\n        Cartesian product (cross join).\n    </description>\n
    \ </property>\n  <property>\n    <name>hive.strict.checks.bucketing</name>\n    <value>true</value>\n
    \   <description>\n      Enabling strict bucketing checks disallows the following:\n
    \       Load into bucketed tables.\n    </description>\n  </property>\n  <property>\n
    \   <name>hive.load.data.owner</name>\n    <value/>\n    <description>Set the
    owner of files loaded using load data in managed tables.</description>\n  </property>\n
    \ <property>\n    <name>hive.mapred.mode</name>\n    <value/>\n    <description>Deprecated;
    use hive.strict.checks.* settings instead.</description>\n  </property>\n  <property>\n
    \   <name>hive.alias</name>\n    <value/>\n    <description/>\n  </property>\n
    \ <property>\n    <name>hive.map.aggr</name>\n    <value>true</value>\n    <description>Whether
    to use map-side aggregation in Hive Group By queries</description>\n  </property>\n
    \ <property>\n    <name>hive.groupby.skewindata</name>\n    <value>false</value>\n
    \   <description>Whether there is skew in data to optimize group by queries</description>\n
    \ </property>\n  <property>\n    <name>hive.join.emit.interval</name>\n    <value>1000</value>\n
    \   <description>How many rows in the right-most join operand Hive should buffer
    before emitting the join result.</description>\n  </property>\n  <property>\n
    \   <name>hive.join.cache.size</name>\n    <value>25000</value>\n    <description>How
    many rows in the joining tables (except the streaming table) should be cached
    in memory.</description>\n  </property>\n  <property>\n    <name>hive.join.inner.residual</name>\n
    \   <value>false</value>\n    <description>Whether to push non-equi filter predicates
    within inner joins. This can improve efficiency in the evaluation of certain joins,
    since we will not be emitting rows which are thrown away by a Filter operator
    straight away. However, currently vectorization does not support them, thus enabling
    it is only recommended when vectorization is disabled.</description>\n  </property>\n
    \ <property>\n    <name>hive.cbo.enable</name>\n    <value>true</value>\n    <description>Flag
    to control enabling Cost Based Optimizations using Calcite framework.</description>\n
    \ </property>\n  <property>\n    <name>hive.cbo.cnf.maxnodes</name>\n    <value>-1</value>\n
    \   <description>When converting to conjunctive normal form (CNF), fail ifthe
    expression exceeds this threshold; the threshold is expressed in terms of number
    of nodes (leaves andinterior nodes). -1 to not set up a threshold.</description>\n
    \ </property>\n  <property>\n    <name>hive.cbo.returnpath.hiveop</name>\n    <value>false</value>\n
    \   <description>Flag to control calcite plan to hive operator conversion</description>\n
    \ </property>\n  <property>\n    <name>hive.cbo.costmodel.extended</name>\n    <value>false</value>\n
    \   <description>Flag to control enabling the extended cost model based onCPU,
    IO and cardinality. Otherwise, the cost model is based on cardinality.</description>\n
    \ </property>\n  <property>\n    <name>hive.cbo.costmodel.cpu</name>\n    <value>0.000001</value>\n
    \   <description>Default cost of a comparison</description>\n  </property>\n  <property>\n
    \   <name>hive.cbo.costmodel.network</name>\n    <value>150.0</value>\n    <description>Default
    cost of a transferring a byte over network; expressed as multiple of CPU cost</description>\n
    \ </property>\n  <property>\n    <name>hive.cbo.costmodel.local.fs.write</name>\n
    \   <value>4.0</value>\n    <description>Default cost of writing a byte to local
    FS; expressed as multiple of NETWORK cost</description>\n  </property>\n  <property>\n
    \   <name>hive.cbo.costmodel.local.fs.read</name>\n    <value>4.0</value>\n    <description>Default
    cost of reading a byte from local FS; expressed as multiple of NETWORK cost</description>\n
    \ </property>\n  <property>\n    <name>hive.cbo.costmodel.hdfs.write</name>\n
    \   <value>10.0</value>\n    <description>Default cost of writing a byte to HDFS;
    expressed as multiple of Local FS write cost</description>\n  </property>\n  <property>\n
    \   <name>hive.cbo.costmodel.hdfs.read</name>\n    <value>1.5</value>\n    <description>Default
    cost of reading a byte from HDFS; expressed as multiple of Local FS read cost</description>\n
    \ </property>\n  <property>\n    <name>hive.cbo.show.warnings</name>\n    <value>true</value>\n
    \   <description>Toggle display of CBO warnings like missing column stats</description>\n
    \ </property>\n  <property>\n    <name>hive.transpose.aggr.join</name>\n    <value>false</value>\n
    \   <description>push aggregates through join</description>\n  </property>\n  <property>\n
    \   <name>hive.optimize.semijoin.conversion</name>\n    <value>true</value>\n
    \   <description>convert group by followed by inner equi join into semijoin</description>\n
    \ </property>\n  <property>\n    <name>hive.order.columnalignment</name>\n    <value>true</value>\n
    \   <description>Flag to control whether we want to try to aligncolumns in operators
    such as Aggregate or Join so that we try to reduce the number of shuffling stages</description>\n
    \ </property>\n  <property>\n    <name>hive.materializedview.rewriting</name>\n
    \   <value>true</value>\n    <description>Whether to try to rewrite queries using
    the materialized views enabled for rewriting</description>\n  </property>\n  <property>\n
    \   <name>hive.materializedview.rewriting.strategy</name>\n    <value>heuristic</value>\n
    \   <description>\n      Expects one of [heuristic, costbased].\n      The strategy
    that should be used to cost and select the materialized view rewriting. \n        heuristic:
    Always try to select the plan using the materialized view if rewriting produced
    one,choosing the plan with lower cost among possible plans containing a materialized
    view\n        costbased: Fully cost-based strategy, always use plan with lower
    cost, independently on whether it uses a materialized view or not\n    </description>\n
    \ </property>\n  <property>\n    <name>hive.materializedview.rewriting.time.window</name>\n
    \   <value>0min</value>\n    <description>\n      Expects a time value with unit
    (d/day, h/hour, m/min, s/sec, ms/msec, us/usec, ns/nsec), which is min if not
    specified.\n      Time window, specified in seconds, after which outdated materialized
    views become invalid for automatic query rewriting.\n      For instance, if more
    time than the value assigned to the property has passed since the materialized
    view was created or rebuilt, and one of its source tables has changed since, the
    materialized view will not be considered for rewriting. Default value 0 means
    that the materialized view cannot be outdated to be used automatically in query
    rewriting. Value -1 means to skip this check.\n    </description>\n  </property>\n
    \ <property>\n    <name>hive.materializedview.rewriting.incremental</name>\n    <value>false</value>\n
    \   <description>\n      Whether to try to execute incremental rewritings based
    on outdated materializations and\n      current content of tables. Default value
    of true effectively amounts to enabling incremental\n      rebuild for the materializations
    too.\n    </description>\n  </property>\n  <property>\n    <name>hive.materializedview.rebuild.incremental</name>\n
    \   <value>true</value>\n    <description>\n      Whether to try to execute incremental
    rebuild for the materialized views. Incremental rebuild\n      tries to modify
    the original materialization contents to reflect the latest changes to the\n      materialized
    view source tables, instead of rebuilding the contents fully. Incremental rebuild\n
    \     is based on the materialized view algebraic incremental rewriting.\n    </description>\n
    \ </property>\n  <property>\n    <name>hive.materializedview.fileformat</name>\n
    \   <value>ORC</value>\n    <description>\n      Expects one of [none, textfile,
    sequencefile, rcfile, orc].\n      Default file format for CREATE MATERIALIZED
    VIEW statement\n    </description>\n  </property>\n  <property>\n    <name>hive.materializedview.serde</name>\n
    \   <value>org.apache.hadoop.hive.ql.io.orc.OrcSerde</value>\n    <description>Default
    SerDe used for materialized views</description>\n  </property>\n  <property>\n
    \   <name>hive.mapjoin.bucket.cache.size</name>\n    <value>100</value>\n    <description/>\n
    \ </property>\n  <property>\n    <name>hive.mapjoin.optimized.hashtable</name>\n
    \   <value>true</value>\n    <description>\n      Whether Hive should use memory-optimized
    hash table for MapJoin.\n      Only works on Tez and Spark, because memory-optimized
    hashtable cannot be serialized.\n    </description>\n  </property>\n  <property>\n
    \   <name>hive.mapjoin.optimized.hashtable.probe.percent</name>\n    <value>0.5</value>\n
    \   <description>Probing space percentage of the optimized hashtable</description>\n
    \ </property>\n  <property>\n    <name>hive.mapjoin.hybridgrace.hashtable</name>\n
    \   <value>true</value>\n    <description>Whether to use hybridgrace hash join
    as the join method for mapjoin. Tez only.</description>\n  </property>\n  <property>\n
    \   <name>hive.mapjoin.hybridgrace.memcheckfrequency</name>\n    <value>1024</value>\n
    \   <description>For hybrid grace hash join, how often (how many rows apart) we
    check if memory is full. This number should be power of 2.</description>\n  </property>\n
    \ <property>\n    <name>hive.mapjoin.hybridgrace.minwbsize</name>\n    <value>524288</value>\n
    \   <description>For hybrid graceHash join, the minimum write buffer size used
    by optimized hashtable. Default is 512 KB.</description>\n  </property>\n  <property>\n
    \   <name>hive.mapjoin.hybridgrace.minnumpartitions</name>\n    <value>16</value>\n
    \   <description>ForHybrid grace hash join, the minimum number of partitions to
    create.</description>\n  </property>\n  <property>\n    <name>hive.mapjoin.optimized.hashtable.wbsize</name>\n
    \   <value>8388608</value>\n    <description>\n      Optimized hashtable (see
    hive.mapjoin.optimized.hashtable) uses a chain of buffers to\n      store data.
    This is one buffer size. HT may be slightly faster if this is larger, but for
    small\n      joins unnecessary memory will be allocated and then trimmed.\n    </description>\n
    \ </property>\n  <property>\n    <name>hive.mapjoin.hybridgrace.bloomfilter</name>\n
    \   <value>true</value>\n    <description>Whether to use BloomFilter in Hybrid
    grace hash join to minimize unnecessary spilling.</description>\n  </property>\n
    \ <property>\n    <name>hive.smbjoin.cache.rows</name>\n    <value>10000</value>\n
    \   <description>How many rows with the same key value should be cached in memory
    per smb joined table.</description>\n  </property>\n  <property>\n    <name>hive.groupby.mapaggr.checkinterval</name>\n
    \   <value>100000</value>\n    <description>Number of rows after which size of
    the grouping keys/aggregation classes is performed</description>\n  </property>\n
    \ <property>\n    <name>hive.map.aggr.hash.percentmemory</name>\n    <value>0.5</value>\n
    \   <description>Portion of total memory to be used by map-side group aggregation
    hash table</description>\n  </property>\n  <property>\n    <name>hive.mapjoin.followby.map.aggr.hash.percentmemory</name>\n
    \   <value>0.3</value>\n    <description>Portion of total memory to be used by
    map-side group aggregation hash table, when this group by is followed by map join</description>\n
    \ </property>\n  <property>\n    <name>hive.map.aggr.hash.force.flush.memory.threshold</name>\n
    \   <value>0.9</value>\n    <description>\n      The max memory to be used by
    map-side group aggregation hash table.\n      If the memory usage is higher than
    this number, force to flush data\n    </description>\n  </property>\n  <property>\n
    \   <name>hive.map.aggr.hash.min.reduction</name>\n    <value>0.5</value>\n    <description>\n
    \     Hash aggregation will be turned off if the ratio between hash  table size
    and input rows is bigger than this number. \n      Set to 1 to make sure hash
    aggregation is never turned off.\n    </description>\n  </property>\n  <property>\n
    \   <name>hive.multigroupby.singlereducer</name>\n    <value>true</value>\n    <description>\n
    \     Whether to optimize multi group by query to generate single M/R  job plan.
    If the multi group by query has \n      common group by keys, it will be optimized
    to generate single M/R job.\n    </description>\n  </property>\n  <property>\n
    \   <name>hive.map.groupby.sorted</name>\n    <value>true</value>\n    <description>\n
    \     If the bucketing/sorting properties of the table exactly match the grouping
    key, whether to perform \n      the group by in the mapper by using BucketizedHiveInputFormat.
    The only downside to this\n      is that it limits the number of mappers to the
    number of files.\n    </description>\n  </property>\n  <property>\n    <name>hive.groupby.position.alias</name>\n
    \   <value>false</value>\n    <description>Whether to enable using Column Position
    Alias in Group By</description>\n  </property>\n  <property>\n    <name>hive.orderby.position.alias</name>\n
    \   <value>true</value>\n    <description>Whether to enable using Column Position
    Alias in Order By</description>\n  </property>\n  <property>\n    <name>hive.groupby.orderby.position.alias</name>\n
    \   <value>false</value>\n    <description>\n      Whether to enable using Column
    Position Alias in Group By or Order By (deprecated).\n      Use hive.orderby.position.alias
    or hive.groupby.position.alias instead\n    </description>\n  </property>\n  <property>\n
    \   <name>hive.new.job.grouping.set.cardinality</name>\n    <value>30</value>\n
    \   <description>\n      Whether a new map-reduce job should be launched for grouping
    sets/rollups/cubes.\n      For a query like: select a, b, c, count(1) from T group
    by a, b, c with rollup;\n      4 rows are created per row: (a, b, c), (a, b, null),
    (a, null, null), (null, null, null).\n      This can lead to explosion across
    map-reduce boundary if the cardinality of T is very high,\n      and map-side
    aggregation does not do a very good job. \n      \n      This parameter decides
    if Hive should add an additional map-reduce job. If the grouping set\n      cardinality
    (4 in the example above), is more than this value, a new MR job is added under
    the\n      assumption that the original group by will reduce the data size.\n
    \   </description>\n  </property>\n  <property>\n    <name>hive.groupby.limit.extrastep</name>\n
    \   <value>true</value>\n    <description>\n      This parameter decides if Hive
    should \n      create new MR job for sorting final output\n    </description>\n
    \ </property>\n  <property>\n    <name>hive.exec.copyfile.maxnumfiles</name>\n
    \   <value>1</value>\n    <description>Maximum number of files Hive uses to do
    sequential HDFS copies between directories.Distributed copies (distcp) will be
    used instead for larger numbers of files so that copies can be done faster.</description>\n
    \ </property>\n  <property>\n    <name>hive.exec.copyfile.maxsize</name>\n    <value>33554432</value>\n
    \   <description>Maximum file size (in bytes) that Hive uses to do single HDFS
    copies between directories.Distributed copies (distcp) will be used instead for
    bigger files so that copies can be done faster.</description>\n  </property>\n
    \ <property>\n    <name>hive.udtf.auto.progress</name>\n    <value>false</value>\n
    \   <description>\n      Whether Hive should automatically send progress information
    to TaskTracker \n      when using UDTF's to prevent the task getting killed because
    of inactivity.  Users should be cautious \n      because this may prevent TaskTracker
    from killing tasks with infinite loops.\n    </description>\n  </property>\n  <property>\n
    \   <name>hive.default.fileformat</name>\n    <value>TextFile</value>\n    <description>\n
    \     Expects one of [textfile, sequencefile, rcfile, orc, parquet].\n      Default
    file format for CREATE TABLE statement. Users can explicitly override it by CREATE
    TABLE ... STORED AS [FORMAT]\n    </description>\n  </property>\n  <property>\n
    \   <name>hive.default.fileformat.managed</name>\n    <value>none</value>\n    <description>\n
    \     Expects one of [none, textfile, sequencefile, rcfile, orc, parquet].\n      Default
    file format for CREATE TABLE statement applied to managed tables only. External
    tables will be \n      created with format specified by hive.default.fileformat.
    Leaving this null will result in using hive.default.fileformat \n      for all
    tables.\n    </description>\n  </property>\n  <property>\n    <name>hive.query.result.fileformat</name>\n
    \   <value>SequenceFile</value>\n    <description>\n      Expects one of [textfile,
    sequencefile, rcfile, llap].\n      Default file format for storing result of
    the query.\n    </description>\n  </property>\n  <property>\n    <name>hive.fileformat.check</name>\n
    \   <value>true</value>\n    <description>Whether to check file format or not
    when loading data files</description>\n  </property>\n  <property>\n    <name>hive.default.rcfile.serde</name>\n
    \   <value>org.apache.hadoop.hive.serde2.columnar.LazyBinaryColumnarSerDe</value>\n
    \   <description>The default SerDe Hive will use for the RCFile format</description>\n
    \ </property>\n  <property>\n    <name>hive.default.serde</name>\n    <value>org.apache.hadoop.hive.serde2.lazy.LazySimpleSerDe</value>\n
    \   <description>The default SerDe Hive will use for storage formats that do not
    specify a SerDe.</description>\n  </property>\n  <property>\n    <name>hive.serdes.using.metastore.for.schema</name>\n
    \   <value>org.apache.hadoop.hive.ql.io.orc.OrcSerde,org.apache.hadoop.hive.serde2.lazy.LazySimpleSerDe,org.apache.hadoop.hive.serde2.columnar.ColumnarSerDe,org.apache.hadoop.hive.serde2.dynamic_type.DynamicSerDe,org.apache.hadoop.hive.serde2.MetadataTypedColumnsetSerDe,org.apache.hadoop.hive.serde2.columnar.LazyBinaryColumnarSerDe,org.apache.hadoop.hive.ql.io.parquet.serde.ParquetHiveSerDe,org.apache.hadoop.hive.serde2.lazybinary.LazyBinarySerDe</value>\n
    \   <description>SerDes retrieving schema from metastore. This is an internal
    parameter.</description>\n  </property>\n  <property>\n    <name>hive.legacy.schema.for.all.serdes</name>\n
    \   <value>false</value>\n    <description>\n      A backward compatibility setting
    for external metastore users that do not handle \n      hive.serdes.using.metastore.for.schema
    correctly. This may be removed at any time.\n    </description>\n  </property>\n
    \ <property>\n    <name>hive.querylog.enable.plan.progress</name>\n    <value>true</value>\n
    \   <description>\n      Whether to log the plan's progress every time a job's
    progress is checked.\n      These logs are written to the location specified by
    hive.querylog.location\n    </description>\n  </property>\n  <property>\n    <name>hive.querylog.plan.progress.interval</name>\n
    \   <value>60000ms</value>\n    <description>\n      Expects a time value with
    unit (d/day, h/hour, m/min, s/sec, ms/msec, us/usec, ns/nsec), which is msec if
    not specified.\n      The interval to wait between logging the plan's progress.\n
    \     If there is a whole number percentage change in the progress of the mappers
    or the reducers,\n      the progress is logged regardless of this value.\n      The
    actual interval will be the ceiling of (this value divided by the value of\n      hive.exec.counters.pull.interval)
    multiplied by the value of hive.exec.counters.pull.interval\n      I.e. if it
    is not divide evenly by the value of hive.exec.counters.pull.interval it will
    be\n      logged less frequently than specified.\n      This only has an effect
    if hive.querylog.enable.plan.progress is set to true.\n    </description>\n  </property>\n
    \ <property>\n    <name>hive.script.serde</name>\n    <value>org.apache.hadoop.hive.serde2.lazy.LazySimpleSerDe</value>\n
    \   <description>The default SerDe for transmitting input data to and reading
    output data from the user scripts. </description>\n  </property>\n  <property>\n
    \   <name>hive.script.recordreader</name>\n    <value>org.apache.hadoop.hive.ql.exec.TextRecordReader</value>\n
    \   <description>The default record reader for reading data from the user scripts.
    </description>\n  </property>\n  <property>\n    <name>hive.script.recordwriter</name>\n
    \   <value>org.apache.hadoop.hive.ql.exec.TextRecordWriter</value>\n    <description>The
    default record writer for writing data to the user scripts. </description>\n  </property>\n
    \ <property>\n    <name>hive.transform.escape.input</name>\n    <value>false</value>\n
    \   <description>\n      This adds an option to escape special chars (newlines,
    carriage returns and\n      tabs) when they are passed to the user script. This
    is useful if the Hive tables\n      can contain data that contains special characters.\n
    \   </description>\n  </property>\n  <property>\n    <name>hive.binary.record.max.length</name>\n
    \   <value>1000</value>\n    <description>\n      Read from a binary stream and
    treat each hive.binary.record.max.length bytes as a record. \n      The last record
    before the end of stream can have less than hive.binary.record.max.length bytes\n
    \   </description>\n  </property>\n  <property>\n    <name>hive.mapred.local.mem</name>\n
    \   <value>0</value>\n    <description>mapper/reducer memory in local mode</description>\n
    \ </property>\n  <property>\n    <name>hive.mapjoin.smalltable.filesize</name>\n
    \   <value>25000000</value>\n    <description>\n      The threshold for the input
    file size of the small tables; if the file size is smaller \n      than this threshold,
    it will try to convert the common join into map join\n    </description>\n  </property>\n
    \ <property>\n    <name>hive.exec.schema.evolution</name>\n    <value>true</value>\n
    \   <description>Use schema evolution to convert self-describing file format's
    data to the schema desired by the reader.</description>\n  </property>\n  <property>\n
    \   <name>hive.transactional.events.mem</name>\n    <value>10000000</value>\n
    \   <description>\n      Vectorized ACID readers can often load all the delete
    events from all the delete deltas\n      into memory to optimize for performance.
    To prevent out-of-memory errors, this is a rough heuristic\n      that limits
    the total number of delete events that can be loaded into memory at once.\n      Roughly
    it has been set to 10 million delete events per bucket (~160 MB).\n    </description>\n
    \ </property>\n  <property>\n    <name>hive.sample.seednumber</name>\n    <value>0</value>\n
    \   <description>A number used to percentage sampling. By changing this number,
    user will change the subsets of data sampled.</description>\n  </property>\n  <property>\n
    \   <name>hive.test.mode</name>\n    <value>false</value>\n    <description>Whether
    Hive is running in test mode. If yes, it turns on sampling and prefixes the output
    tablename.</description>\n  </property>\n  <property>\n    <name>hive.exim.test.mode</name>\n
    \   <value>false</value>\n    <description>The subset of test mode that only enables
    custom path handling for ExIm.</description>\n  </property>\n  <property>\n    <name>hive.test.mode.prefix</name>\n
    \   <value>test_</value>\n    <description>In test mode, specifies prefixes for
    the output table</description>\n  </property>\n  <property>\n    <name>hive.test.mode.samplefreq</name>\n
    \   <value>32</value>\n    <description>\n      In test mode, specifies sampling
    frequency for table, which is not bucketed,\n      For example, the following
    query:\n        INSERT OVERWRITE TABLE dest SELECT col1 from src\n      would
    be converted to\n        INSERT OVERWRITE TABLE test_dest\n        SELECT col1
    from src TABLESAMPLE (BUCKET 1 out of 32 on rand(1))\n    </description>\n  </property>\n
    \ <property>\n    <name>hive.test.mode.nosamplelist</name>\n    <value/>\n    <description>In
    test mode, specifies comma separated table names which would not apply sampling</description>\n
    \ </property>\n  <property>\n    <name>hive.test.dummystats.aggregator</name>\n
    \   <value/>\n    <description>internal variable for test</description>\n  </property>\n
    \ <property>\n    <name>hive.test.dummystats.publisher</name>\n    <value/>\n
    \   <description>internal variable for test</description>\n  </property>\n  <property>\n
    \   <name>hive.test.currenttimestamp</name>\n    <value/>\n    <description>current
    timestamp for test</description>\n  </property>\n  <property>\n    <name>hive.test.rollbacktxn</name>\n
    \   <value>false</value>\n    <description>For testing only.  Will mark every
    ACID transaction aborted</description>\n  </property>\n  <property>\n    <name>hive.test.fail.compaction</name>\n
    \   <value>false</value>\n    <description>For testing only.  Will cause CompactorMR
    to fail.</description>\n  </property>\n  <property>\n    <name>hive.test.fail.heartbeater</name>\n
    \   <value>false</value>\n    <description>For testing only.  Will cause Heartbeater
    to fail.</description>\n  </property>\n  <property>\n    <name>hive.test.bucketcodec.version</name>\n
    \   <value>1</value>\n    <description>\n      For testing only.  Will make ACID
    subsystem write RecordIdentifier.bucketId in specified\n      format\n    </description>\n
    \ </property>\n  <property>\n    <name>hive.merge.mapfiles</name>\n    <value>true</value>\n
    \   <description>Merge small files at the end of a map-only job</description>\n
    \ </property>\n  <property>\n    <name>hive.merge.mapredfiles</name>\n    <value>false</value>\n
    \   <description>Merge small files at the end of a map-reduce job</description>\n
    \ </property>\n  <property>\n    <name>hive.merge.tezfiles</name>\n    <value>false</value>\n
    \   <description>Merge small files at the end of a Tez DAG</description>\n  </property>\n
    \ <property>\n    <name>hive.merge.sparkfiles</name>\n    <value>false</value>\n
    \   <description>Merge small files at the end of a Spark DAG Transformation</description>\n
    \ </property>\n  <property>\n    <name>hive.merge.size.per.task</name>\n    <value>256000000</value>\n
    \   <description>Size of merged files at the end of the job</description>\n  </property>\n
    \ <property>\n    <name>hive.merge.smallfiles.avgsize</name>\n    <value>16000000</value>\n
    \   <description>\n      When the average output file size of a job is less than
    this number, Hive will start an additional \n      map-reduce job to merge the
    output files into bigger files. This is only done for map-only jobs \n      if
    hive.merge.mapfiles is true, and for map-reduce jobs if hive.merge.mapredfiles
    is true.\n    </description>\n  </property>\n  <property>\n    <name>hive.merge.rcfile.block.level</name>\n
    \   <value>true</value>\n    <description/>\n  </property>\n  <property>\n    <name>hive.merge.orcfile.stripe.level</name>\n
    \   <value>true</value>\n    <description>\n      When hive.merge.mapfiles, hive.merge.mapredfiles
    or hive.merge.tezfiles is enabled\n      while writing a table with ORC file format,
    enabling this config will do stripe-level\n      fast merge for small ORC files.
    Note that enabling this config will not honor the\n      padding tolerance config
    (hive.exec.orc.block.padding.tolerance).\n    </description>\n  </property>\n
    \ <property>\n    <name>hive.use.orc.codec.pool</name>\n    <value>false</value>\n
    \   <description>Whether to use codec pool in ORC. Disable if there are bugs with
    codec reuse.</description>\n  </property>\n  <property>\n    <name>hive.exec.rcfile.use.explicit.header</name>\n
    \   <value>true</value>\n    <description>\n      If this is set the header for
    RCFiles will simply be RCF.  If this is not\n      set the header will be that
    borrowed from sequence files, e.g. SEQ- followed\n      by the input and output
    RCFile formats.\n    </description>\n  </property>\n  <property>\n    <name>hive.exec.rcfile.use.sync.cache</name>\n
    \   <value>true</value>\n    <description/>\n  </property>\n  <property>\n    <name>hive.io.rcfile.record.interval</name>\n
    \   <value>2147483647</value>\n    <description/>\n  </property>\n  <property>\n
    \   <name>hive.io.rcfile.column.number.conf</name>\n    <value>0</value>\n    <description/>\n
    \ </property>\n  <property>\n    <name>hive.io.rcfile.tolerate.corruptions</name>\n
    \   <value>false</value>\n    <description/>\n  </property>\n  <property>\n    <name>hive.io.rcfile.record.buffer.size</name>\n
    \   <value>4194304</value>\n    <description/>\n  </property>\n  <property>\n
    \   <name>parquet.memory.pool.ratio</name>\n    <value>0.5</value>\n    <description>\n
    \     Maximum fraction of heap that can be used by Parquet file writers in one
    task.\n      It is for avoiding OutOfMemory error in tasks. Work with Parquet
    1.6.0 and above.\n      This config parameter is defined in Parquet, so that it
    does not start with 'hive.'.\n    </description>\n  </property>\n  <property>\n
    \   <name>hive.parquet.timestamp.skip.conversion</name>\n    <value>false</value>\n
    \   <description>Current Hive implementation of parquet stores timestamps to UTC,
    this flag allows skipping of the conversionon reading parquet files from other
    tools</description>\n  </property>\n  <property>\n    <name>hive.int.timestamp.conversion.in.seconds</name>\n
    \   <value>false</value>\n    <description>\n      Boolean/tinyint/smallint/int/bigint
    value is interpreted as milliseconds during the timestamp conversion.\n      Set
    this flag to true to interpret the value as seconds to be consistent with float/double.\n
    \   </description>\n  </property>\n  <property>\n    <name>hive.exec.orc.base.delta.ratio</name>\n
    \   <value>8</value>\n    <description>\n      The ratio of base writer and\n
    \     delta writer in terms of STRIPE_SIZE and BUFFER_SIZE.\n    </description>\n
    \ </property>\n  <property>\n    <name>hive.exec.orc.delta.streaming.optimizations.enabled</name>\n
    \   <value>false</value>\n    <description>\n      Whether to enable streaming
    optimizations for ORC delta files. This will disable ORC's internal indexes,\n
    \     disable compression, enable fast encoding and disable dictionary encoding.\n
    \   </description>\n  </property>\n  <property>\n    <name>hive.exec.orc.split.strategy</name>\n
    \   <value>HYBRID</value>\n    <description>\n      Expects one of [hybrid, bi,
    etl].\n      This is not a user level config. BI strategy is used when the requirement
    is to spend less time in split generation as opposed to query execution (split
    generation does not read or cache file footers). ETL strategy is used when spending
    little more time in split generation is acceptable (split generation reads and
    caches file footers). HYBRID chooses between the above strategies based on heuristics.\n
    \   </description>\n  </property>\n  <property>\n    <name>hive.streaming.auto.flush.enabled</name>\n
    \   <value>true</value>\n    <description>\n      Whether to enable memory \n
    \     monitoring and automatic flushing of open record updaters during streaming
    ingest. This is an expert level \n      setting and disabling this may have severe
    performance impact under memory pressure.\n    </description>\n  </property>\n
    \ <property>\n    <name>hive.heap.memory.monitor.usage.threshold</name>\n    <value>0.7</value>\n
    \   <description>\n      Hive streaming does automatic memory management across
    all open record writers. This threshold will let the \n      memory monitor take
    an action (flush open files) when heap memory usage exceeded this threshold.\n
    \   </description>\n  </property>\n  <property>\n    <name>hive.streaming.auto.flush.check.interval.size</name>\n
    \   <value>100Mb</value>\n    <description>\n      Expects a byte size value with
    unit (blank for bytes, kb, mb, gb, tb, pb).\n      Hive streaming ingest has auto
    flush mechanism to flush all open record updaters under memory pressure.\n      When
    memory usage exceed hive.heap.memory.monitor.default.usage.threshold, the auto-flush
    mechanism will \n      wait until this size (default 100Mb) of records are ingested
    before triggering flush.\n    </description>\n  </property>\n  <property>\n    <name>hive.classloader.shade.prefix</name>\n
    \   <value/>\n    <description>\n      During reflective instantiation of a class\n
    \     (input, output formats, serde etc.), when classloader throws ClassNotFoundException,
    as a fallback this\n      shade prefix will be used before class reference and
    retried.\n    </description>\n  </property>\n  <property>\n    <name>hive.orc.splits.ms.footer.cache.enabled</name>\n
    \   <value>false</value>\n    <description>Whether to enable using file metadata
    cache in metastore for ORC file footers.</description>\n  </property>\n  <property>\n
    \   <name>hive.orc.splits.ms.footer.cache.ppd.enabled</name>\n    <value>true</value>\n
    \   <description>\n      Whether to enable file footer cache PPD (hive.orc.splits.ms.footer.cache.enabled\n
    \     must also be set to true for this to work).\n    </description>\n  </property>\n
    \ <property>\n    <name>hive.orc.splits.include.file.footer</name>\n    <value>false</value>\n
    \   <description>\n      If turned on splits generated by orc will include metadata
    about the stripes in the file. This\n      data is read remotely (from the client
    or HS2 machine) and sent to all the tasks.\n    </description>\n  </property>\n
    \ <property>\n    <name>hive.orc.splits.directory.batch.ms</name>\n    <value>0</value>\n
    \   <description>\n      How long, in ms, to wait to batch input directories for
    processing during ORC split\n      generation. 0 means process directories individually.
    This can increase the number of\n      metastore calls if metastore metadata cache
    is used.\n    </description>\n  </property>\n  <property>\n    <name>hive.orc.splits.include.fileid</name>\n
    \   <value>true</value>\n    <description>Include file ID in splits on file systems
    that support it.</description>\n  </property>\n  <property>\n    <name>hive.orc.splits.allow.synthetic.fileid</name>\n
    \   <value>true</value>\n    <description>Allow synthetic file ID in splits on
    file systems that don't have a native one.</description>\n  </property>\n  <property>\n
    \   <name>hive.orc.cache.stripe.details.mem.size</name>\n    <value>256Mb</value>\n
    \   <description>\n      Expects a byte size value with unit (blank for bytes,
    kb, mb, gb, tb, pb).\n      Maximum size of orc splits cached in the client.\n
    \   </description>\n  </property>\n  <property>\n    <name>hive.orc.compute.splits.num.threads</name>\n
    \   <value>10</value>\n    <description>How many threads orc should use to create
    splits in parallel.</description>\n  </property>\n  <property>\n    <name>hive.orc.cache.use.soft.references</name>\n
    \   <value>false</value>\n    <description>\n      By default, the cache that
    ORC input format uses to store orc file footer use hard\n      references for
    the cached object. Setting this to true can help avoid out of memory\n      issues
    under memory pressure (in some cases) at the cost of slight unpredictability in\n
    \     overall query performance.\n    </description>\n  </property>\n  <property>\n
    \   <name>hive.io.sarg.cache.max.weight.mb</name>\n    <value>10</value>\n    <description>The
    max weight allowed for the SearchArgument Cache. By default, the cache allows
    a max-weight of 10MB, after which entries will be evicted.</description>\n  </property>\n
    \ <property>\n    <name>hive.lazysimple.extended_boolean_literal</name>\n    <value>false</value>\n
    \   <description>\n      LazySimpleSerde uses this property to determine if it
    treats 'T', 't', 'F', 'f',\n      '1', and '0' as extended, legal boolean literal,
    in addition to 'TRUE' and 'FALSE'.\n      The default is false, which means only
    'TRUE' and 'FALSE' are treated as legal\n      boolean literal.\n    </description>\n
    \ </property>\n  <property>\n    <name>hive.optimize.skewjoin</name>\n    <value>false</value>\n
    \   <description>\n      Whether to enable skew join optimization. \n      The
    algorithm is as follows: At runtime, detect the keys with a large skew. Instead
    of\n      processing those keys, store them temporarily in an HDFS directory.
    In a follow-up map-reduce\n      job, process those skewed keys. The same key
    need not be skewed for all the tables, and so,\n      the follow-up map-reduce
    job (for the skewed keys) would be much faster, since it would be a\n      map-join.\n
    \   </description>\n  </property>\n  <property>\n    <name>hive.optimize.dynamic.partition.hashjoin</name>\n
    \   <value>false</value>\n    <description>\n      Whether to enable dynamically
    partitioned hash join optimization. \n      This setting is also dependent on
    enabling hive.auto.convert.join\n    </description>\n  </property>\n  <property>\n
    \   <name>hive.auto.convert.join</name>\n    <value>true</value>\n    <description>Whether
    Hive enables the optimization about converting common join into mapjoin based
    on the input file size</description>\n  </property>\n  <property>\n    <name>hive.auto.convert.join.noconditionaltask</name>\n
    \   <value>true</value>\n    <description>\n      Whether Hive enables the optimization
    about converting common join into mapjoin based on the input file size. \n      If
    this parameter is on, and the sum of size for n-1 of the tables/partitions for
    a n-way join is smaller than the\n      specified size, the join is directly converted
    to a mapjoin (there is no conditional task).\n    </description>\n  </property>\n
    \ <property>\n    <name>hive.auto.convert.join.noconditionaltask.size</name>\n
    \   <value>10000000</value>\n    <description>\n      If hive.auto.convert.join.noconditionaltask
    is off, this parameter does not take affect. \n      However, if it is on, and
    the sum of size for n-1 of the tables/partitions for a n-way join is smaller than
    this size, \n      the join is directly converted to a mapjoin(there is no conditional
    task). The default is 10MB\n    </description>\n  </property>\n  <property>\n
    \   <name>hive.auto.convert.join.use.nonstaged</name>\n    <value>false</value>\n
    \   <description>\n      For conditional joins, if input stream from a small alias
    can be directly applied to join operator without \n      filtering or projection,
    the alias need not to be pre-staged in distributed cache via mapred local task.\n
    \     Currently, this is not working with vectorization or tez execution engine.\n
    \   </description>\n  </property>\n  <property>\n    <name>hive.skewjoin.key</name>\n
    \   <value>100000</value>\n    <description>\n      Determine if we get a skew
    key in join. If we see more than the specified number of rows with the same key
    in join operator,\n      we think the key as a skew join key. \n    </description>\n
    \ </property>\n  <property>\n    <name>hive.skewjoin.mapjoin.map.tasks</name>\n
    \   <value>10000</value>\n    <description>\n      Determine the number of map
    task used in the follow up map join job for a skew join.\n      It should be used
    together with hive.skewjoin.mapjoin.min.split to perform a fine grained control.\n
    \   </description>\n  </property>\n  <property>\n    <name>hive.skewjoin.mapjoin.min.split</name>\n
    \   <value>33554432</value>\n    <description>\n      Determine the number of
    map task at most used in the follow up map join job for a skew join by specifying
    \n      the minimum split size. It should be used together with hive.skewjoin.mapjoin.map.tasks
    to perform a fine grained control.\n    </description>\n  </property>\n  <property>\n
    \   <name>hive.heartbeat.interval</name>\n    <value>1000</value>\n    <description>Send
    a heartbeat after this interval - used by mapjoin and filter operators</description>\n
    \ </property>\n  <property>\n    <name>hive.limit.row.max.size</name>\n    <value>100000</value>\n
    \   <description>When trying a smaller subset of data for simple LIMIT, how much
    size we need to guarantee each row to have at least.</description>\n  </property>\n
    \ <property>\n    <name>hive.limit.optimize.limit.file</name>\n    <value>10</value>\n
    \   <description>When trying a smaller subset of data for simple LIMIT, maximum
    number of files we can sample.</description>\n  </property>\n  <property>\n    <name>hive.limit.optimize.enable</name>\n
    \   <value>false</value>\n    <description>Whether to enable to optimization to
    trying a smaller subset of data for simple LIMIT first.</description>\n  </property>\n
    \ <property>\n    <name>hive.limit.optimize.fetch.max</name>\n    <value>50000</value>\n
    \   <description>\n      Maximum number of rows allowed for a smaller subset of
    data for simple LIMIT, if it is a fetch query. \n      Insert queries are not
    restricted by this limit.\n    </description>\n  </property>\n  <property>\n    <name>hive.limit.pushdown.memory.usage</name>\n
    \   <value>0.1</value>\n    <description>\n      Expects value between 0.0f and
    1.0f.\n      The fraction of available memory to be used for buffering rows in
    Reducesink operator for limit pushdown optimization.\n    </description>\n  </property>\n
    \ <property>\n    <name>hive.auto.convert.join.hashtable.max.entries</name>\n
    \   <value>21000000</value>\n    <description>\n      If hive.auto.convert.join.noconditionaltask
    is off, this parameter does not take affect. \n      However, if it is on, and
    the predicted number of entries in hashtable for a given join \n      input is
    larger than this number, the join will not be converted to a mapjoin. \n      The
    value \"-1\" means no limit.\n    </description>\n  </property>\n  <property>\n
    \   <name>hive.auto.convert.join.shuffle.max.size</name>\n    <value>10000000000</value>\n
    \   <description>\n      If hive.auto.convert.join.noconditionaltask is off, this
    parameter does not take affect. \n      However, if it is on, and the predicted
    size of the larger input for a given join is greater \n      than this number,
    the join will not be converted to a dynamically partitioned hash join. \n      The
    value \"-1\" means no limit.\n    </description>\n  </property>\n  <property>\n
    \   <name>hive.hashtable.key.count.adjustment</name>\n    <value>2.0</value>\n
    \   <description>Adjustment to mapjoin hashtable size derived from table and column
    statistics; the estimate of the number of keys is divided by this value. If the
    value is 0, statistics are not usedand hive.hashtable.initialCapacity is used
    instead.</description>\n  </property>\n  <property>\n    <name>hive.hashtable.initialCapacity</name>\n
    \   <value>100000</value>\n    <description>Initial capacity of mapjoin hashtable
    if statistics are absent, or if hive.hashtable.key.count.adjustment is set to
    0</description>\n  </property>\n  <property>\n    <name>hive.hashtable.loadfactor</name>\n
    \   <value>0.75</value>\n    <description/>\n  </property>\n  <property>\n    <name>hive.mapjoin.followby.gby.localtask.max.memory.usage</name>\n
    \   <value>0.55</value>\n    <description>\n      This number means how much memory
    the local task can take to hold the key/value into an in-memory hash table \n
    \     when this map join is followed by a group by. If the local task's memory
    usage is more than this number, \n      the local task will abort by itself. It
    means the data of the small table is too large to be held in memory.\n    </description>\n
    \ </property>\n  <property>\n    <name>hive.mapjoin.localtask.max.memory.usage</name>\n
    \   <value>0.9</value>\n    <description>\n      This number means how much memory
    the local task can take to hold the key/value into an in-memory hash table. \n
    \     If the local task's memory usage is more than this number, the local task
    will abort by itself. \n      It means the data of the small table is too large
    to be held in memory.\n    </description>\n  </property>\n  <property>\n    <name>hive.mapjoin.check.memory.rows</name>\n
    \   <value>100000</value>\n    <description>The number means after how many rows
    processed it needs to check the memory usage</description>\n  </property>\n  <property>\n
    \   <name>hive.debug.localtask</name>\n    <value>false</value>\n    <description/>\n
    \ </property>\n  <property>\n    <name>hive.input.format</name>\n    <value>org.apache.hadoop.hive.ql.io.CombineHiveInputFormat</value>\n
    \   <description>The default input format. Set this to HiveInputFormat if you
    encounter problems with CombineHiveInputFormat.</description>\n  </property>\n
    \ <property>\n    <name>hive.tez.input.format</name>\n    <value>org.apache.hadoop.hive.ql.io.HiveInputFormat</value>\n
    \   <description>The default input format for tez. Tez groups splits in the AM.</description>\n
    \ </property>\n  <property>\n    <name>hive.tez.container.size</name>\n    <value>-1</value>\n
    \   <description>By default Tez will spawn containers of the size of a mapper.
    This can be used to overwrite.</description>\n  </property>\n  <property>\n    <name>hive.tez.cpu.vcores</name>\n
    \   <value>-1</value>\n    <description>\n      By default Tez will ask for however
    many cpus map-reduce is configured to use per container.\n      This can be used
    to overwrite.\n    </description>\n  </property>\n  <property>\n    <name>hive.tez.java.opts</name>\n
    \   <value/>\n    <description>By default Tez will use the Java options from map
    tasks. This can be used to overwrite.</description>\n  </property>\n  <property>\n
    \   <name>hive.tez.log.level</name>\n    <value>WARN</value>\n    <description>\n
    \     The log level to use for tasks executing as part of the DAG.\n      Used
    only if hive.tez.java.opts is used to configure Java options.\n    </description>\n
    \ </property>\n  <property>\n    <name>hive.tez.hs2.user.access</name>\n    <value>true</value>\n
    \   <description>Whether to grant access to the hs2/hive user for queries</description>\n
    \ </property>\n  <property>\n    <name>hive.query.name</name>\n    <value/>\n
    \   <description>\n      This named is used by Tez to set the dag name. This name
    in turn will appear on \n      the Tez UI representing the work that was done.
    Used by Spark to set the query name, will show up in the\n      Spark UI.\n    </description>\n
    \ </property>\n  <property>\n    <name>hive.optimize.bucketingsorting</name>\n
    \   <value>true</value>\n    <description>\n      Don't create a reducer for enforcing
    \n      bucketing/sorting for queries of the form: \n      insert overwrite table
    T2 select * from T1;\n      where T1 and T2 are bucketed/sorted by the same keys
    into the same number of buckets.\n    </description>\n  </property>\n  <property>\n
    \   <name>hive.mapred.partitioner</name>\n    <value>org.apache.hadoop.hive.ql.io.DefaultHivePartitioner</value>\n
    \   <description/>\n  </property>\n  <property>\n    <name>hive.enforce.sortmergebucketmapjoin</name>\n
    \   <value>false</value>\n    <description>If the user asked for sort-merge bucketed
    map-side join, and it cannot be performed, should the query fail or not ?</description>\n
    \ </property>\n  <property>\n    <name>hive.enforce.bucketmapjoin</name>\n    <value>false</value>\n
    \   <description>\n      If the user asked for bucketed map-side join, and it
    cannot be performed, \n      should the query fail or not ? For example, if the
    buckets in the tables being joined are\n      not a multiple of each other, bucketed
    map-side join cannot be performed, and the\n      query will fail if hive.enforce.bucketmapjoin
    is set to true.\n    </description>\n  </property>\n  <property>\n    <name>hive.constraint.notnull.enforce</name>\n
    \   <value>true</value>\n    <description>Should \"IS NOT NULL \" constraint be
    enforced?</description>\n  </property>\n  <property>\n    <name>hive.auto.convert.sortmerge.join</name>\n
    \   <value>true</value>\n    <description>Will the join be automatically converted
    to a sort-merge join, if the joined tables pass the criteria for sort-merge join.</description>\n
    \ </property>\n  <property>\n    <name>hive.auto.convert.sortmerge.join.reduce.side</name>\n
    \   <value>true</value>\n    <description>Whether hive.auto.convert.sortmerge.join
    (if enabled) should be applied to reduce side.</description>\n  </property>\n
    \ <property>\n    <name>hive.auto.convert.sortmerge.join.bigtable.selection.policy</name>\n
    \   <value>org.apache.hadoop.hive.ql.optimizer.AvgPartitionSizeBasedBigTableSelectorForAutoSMJ</value>\n
    \   <description>\n      The policy to choose the big table for automatic conversion
    to sort-merge join. \n      By default, the table with the largest partitions
    is assigned the big table. All policies are:\n      . based on position of the
    table - the leftmost table is selected\n      org.apache.hadoop.hive.ql.optimizer.LeftmostBigTableSMJ.\n
    \     . based on total size (all the partitions selected in the query) of the
    table \n      org.apache.hadoop.hive.ql.optimizer.TableSizeBasedBigTableSelectorForAutoSMJ.\n
    \     . based on average size (all the partitions selected in the query) of the
    table \n      org.apache.hadoop.hive.ql.optimizer.AvgPartitionSizeBasedBigTableSelectorForAutoSMJ.\n
    \     New policies can be added in future.\n    </description>\n  </property>\n
    \ <property>\n    <name>hive.auto.convert.sortmerge.join.to.mapjoin</name>\n    <value>false</value>\n
    \   <description>\n      If hive.auto.convert.sortmerge.join is set to true, and
    a join was converted to a sort-merge join, \n      this parameter decides whether
    each table should be tried as a big table, and effectively a map-join should be\n
    \     tried. That would create a conditional task with n+1 children for a n-way
    join (1 child for each table as the\n      big table), and the backup task will
    be the sort-merge join. In some cases, a map-join would be faster than a\n      sort-merge
    join, if there is no advantage of having the output bucketed and sorted. For example,
    if a very big sorted\n      and bucketed table with few files (say 10 files) are
    being joined with a very small sorter and bucketed table\n      with few files
    (10 files), the sort-merge join will only use 10 mappers, and a simple map-only
    join might be faster\n      if the complete small table can fit in memory, and
    a map-join can be performed.\n    </description>\n  </property>\n  <property>\n
    \   <name>hive.exec.script.trust</name>\n    <value>false</value>\n    <description/>\n
    \ </property>\n  <property>\n    <name>hive.exec.rowoffset</name>\n    <value>false</value>\n
    \   <description>Whether to provide the row offset virtual column</description>\n
    \ </property>\n  <property>\n    <name>hive.optimize.index.filter</name>\n    <value>false</value>\n
    \   <description>Whether to enable automatic use of indexes</description>\n  </property>\n
    \ <property>\n    <name>hive.optimize.ppd</name>\n    <value>true</value>\n    <description>Whether
    to enable predicate pushdown</description>\n  </property>\n  <property>\n    <name>hive.optimize.ppd.windowing</name>\n
    \   <value>true</value>\n    <description>Whether to enable predicate pushdown
    through windowing</description>\n  </property>\n  <property>\n    <name>hive.ppd.recognizetransivity</name>\n
    \   <value>true</value>\n    <description>Whether to transitively replicate predicate
    filters over equijoin conditions.</description>\n  </property>\n  <property>\n
    \   <name>hive.ppd.remove.duplicatefilters</name>\n    <value>true</value>\n    <description>\n
    \     During query optimization, filters may be pushed down in the operator tree.
    \n      If this config is true only pushed down filters remain in the operator
    tree, \n      and the original filter is removed. If this config is false, the
    original filter \n      is also left in the operator tree at the original place.\n
    \   </description>\n  </property>\n  <property>\n    <name>hive.optimize.point.lookup</name>\n
    \   <value>true</value>\n    <description>Whether to transform OR clauses in Filter
    operators into IN clauses</description>\n  </property>\n  <property>\n    <name>hive.optimize.point.lookup.min</name>\n
    \   <value>31</value>\n    <description>Minimum number of OR clauses needed to
    transform into IN clauses</description>\n  </property>\n  <property>\n    <name>hive.optimize.countdistinct</name>\n
    \   <value>true</value>\n    <description>Whether to transform count distinct
    into two stages</description>\n  </property>\n  <property>\n    <name>hive.optimize.partition.columns.separate</name>\n
    \   <value>true</value>\n    <description>Extract partition columns from IN clauses</description>\n
    \ </property>\n  <property>\n    <name>hive.optimize.constant.propagation</name>\n
    \   <value>true</value>\n    <description>Whether to enable constant propagation
    optimizer</description>\n  </property>\n  <property>\n    <name>hive.optimize.remove.identity.project</name>\n
    \   <value>true</value>\n    <description>Removes identity project from operator
    tree</description>\n  </property>\n  <property>\n    <name>hive.optimize.metadataonly</name>\n
    \   <value>false</value>\n    <description>\n      Whether to eliminate scans
    of the tables from which no columns are selected. Note\n      that, when selecting
    from empty tables with data files, this can produce incorrect\n      results,
    so it's disabled by default. It works correctly for normal tables.\n    </description>\n
    \ </property>\n  <property>\n    <name>hive.optimize.null.scan</name>\n    <value>true</value>\n
    \   <description>Dont scan relations which are guaranteed to not generate any
    rows</description>\n  </property>\n  <property>\n    <name>hive.optimize.ppd.storage</name>\n
    \   <value>true</value>\n    <description>Whether to push predicates down to storage
    handlers</description>\n  </property>\n  <property>\n    <name>hive.optimize.groupby</name>\n
    \   <value>true</value>\n    <description>Whether to enable the bucketed group
    by from bucketed partitions/tables.</description>\n  </property>\n  <property>\n
    \   <name>hive.optimize.bucketmapjoin</name>\n    <value>false</value>\n    <description>Whether
    to try bucket mapjoin</description>\n  </property>\n  <property>\n    <name>hive.optimize.bucketmapjoin.sortedmerge</name>\n
    \   <value>false</value>\n    <description>Whether to try sorted bucket merge
    map join</description>\n  </property>\n  <property>\n    <name>hive.optimize.reducededuplication</name>\n
    \   <value>true</value>\n    <description>\n      Remove extra map-reduce jobs
    if the data is already clustered by the same key which needs to be used again.
    \n      This should always be set to true. Since it is a new feature, it has been
    made configurable.\n    </description>\n  </property>\n  <property>\n    <name>hive.optimize.reducededuplication.min.reducer</name>\n
    \   <value>4</value>\n    <description>\n      Reduce deduplication merges two
    RSs by moving key/parts/reducer-num of the child RS to parent RS. \n      That
    means if reducer-num of the child RS is fixed (order by or forced bucketing) and
    small, it can make very slow, single MR.\n      The optimization will be automatically
    disabled if number of reducers would be less than specified value.\n    </description>\n
    \ </property>\n  <property>\n    <name>hive.optimize.joinreducededuplication</name>\n
    \   <value>true</value>\n    <description>\n      Remove extra shuffle/sorting
    operations after join algorithm selection has been executed. \n      Currently
    it only works with Apache Tez. This should always be set to true. \n      Since
    it is a new feature, it has been made configurable.\n    </description>\n  </property>\n
    \ <property>\n    <name>hive.optimize.sort.dynamic.partition</name>\n    <value>false</value>\n
    \   <description>\n      When enabled dynamic partitioning column will be globally
    sorted.\n      This way we can keep only one record writer open for each partition
    value\n      in the reducer thereby reducing the memory pressure on reducers.\n
    \   </description>\n  </property>\n  <property>\n    <name>hive.optimize.sampling.orderby</name>\n
    \   <value>false</value>\n    <description>Uses sampling on order-by clause for
    parallel execution.</description>\n  </property>\n  <property>\n    <name>hive.optimize.sampling.orderby.number</name>\n
    \   <value>1000</value>\n    <description>Total number of samples to be obtained.</description>\n
    \ </property>\n  <property>\n    <name>hive.optimize.sampling.orderby.percent</name>\n
    \   <value>0.1</value>\n    <description>\n      Expects value between 0.0f and
    1.0f.\n      Probability with which a row will be chosen.\n    </description>\n
    \ </property>\n  <property>\n    <name>hive.remove.orderby.in.subquery</name>\n
    \   <value>true</value>\n    <description>If set to true, order/sort by without
    limit in sub queries will be removed.</description>\n  </property>\n  <property>\n
    \   <name>hive.optimize.distinct.rewrite</name>\n    <value>true</value>\n    <description>When
    applicable this optimization rewrites distinct aggregates from a single stage
    to multi-stage aggregation. This may not be optimal in all cases. Ideally, whether
    to trigger it or not should be cost based decision. Until Hive formalizes cost
    model for this, this is config driven.</description>\n  </property>\n  <property>\n
    \   <name>hive.optimize.union.remove</name>\n    <value>false</value>\n    <description>\n
    \     Whether to remove the union and push the operators between union and the
    filesink above union. \n      This avoids an extra scan of the output by union.
    This is independently useful for union\n      queries, and specially useful when
    hive.optimize.skewjoin.compiletime is set to true, since an\n      extra union
    is inserted.\n      \n      The merge is triggered if either of hive.merge.mapfiles
    or hive.merge.mapredfiles is set to true.\n      If the user has set hive.merge.mapfiles
    to true and hive.merge.mapredfiles to false, the idea was the\n      number of
    reducers are few, so the number of files anyway are small. However, with this
    optimization,\n      we are increasing the number of files possibly by a big margin.
    So, we merge aggressively.\n    </description>\n  </property>\n  <property>\n
    \   <name>hive.optimize.correlation</name>\n    <value>false</value>\n    <description>exploit
    intra-query correlations.</description>\n  </property>\n  <property>\n    <name>hive.optimize.limittranspose</name>\n
    \   <value>false</value>\n    <description>\n      Whether to push a limit through
    left/right outer join or union. If the value is true and the size of the outer\n
    \     input is reduced enough (as specified in hive.optimize.limittranspose.reduction),
    the limit is pushed\n      to the outer input or union; to remain semantically
    correct, the limit is kept on top of the join or the union too.\n    </description>\n
    \ </property>\n  <property>\n    <name>hive.optimize.limittranspose.reductionpercentage</name>\n
    \   <value>1.0</value>\n    <description>\n      When hive.optimize.limittranspose
    is true, this variable specifies the minimal reduction of the\n      size of the
    outer input of the join or input of the union that we should get in order to apply
    the rule.\n    </description>\n  </property>\n  <property>\n    <name>hive.optimize.limittranspose.reductiontuples</name>\n
    \   <value>0</value>\n    <description>\n      When hive.optimize.limittranspose
    is true, this variable specifies the minimal reduction in the\n      number of
    tuples of the outer input of the join or the input of the union that you should
    get in order to apply the rule.\n    </description>\n  </property>\n  <property>\n
    \   <name>hive.optimize.filter.stats.reduction</name>\n    <value>false</value>\n
    \   <description>\n      Whether to simplify comparison\n      expressions in
    filter operators using column stats\n    </description>\n  </property>\n  <property>\n
    \   <name>hive.optimize.skewjoin.compiletime</name>\n    <value>false</value>\n
    \   <description>\n      Whether to create a separate plan for skewed keys for
    the tables in the join.\n      This is based on the skewed keys stored in the
    metadata. At compile time, the plan is broken\n      into different joins: one
    for the skewed keys, and the other for the remaining keys. And then,\n      a
    union is performed for the 2 joins generated above. So unless the same skewed
    key is present\n      in both the joined tables, the join for the skewed key will
    be performed as a map-side join.\n      \n      The main difference between this
    parameter and hive.optimize.skewjoin is that this parameter\n      uses the skew
    information stored in the metastore to optimize the plan at compile time itself.\n
    \     If there is no skew information in the metadata, this parameter will not
    have any affect.\n      Both hive.optimize.skewjoin.compiletime and hive.optimize.skewjoin
    should be set to true.\n      Ideally, hive.optimize.skewjoin should be renamed
    as hive.optimize.skewjoin.runtime, but not doing\n      so for backward compatibility.\n
    \     \n      If the skew information is correctly stored in the metadata, hive.optimize.skewjoin.compiletime\n
    \     would change the query plan to take care of it, and hive.optimize.skewjoin
    will be a no-op.\n    </description>\n  </property>\n  <property>\n    <name>hive.optimize.shared.work</name>\n
    \   <value>true</value>\n    <description>\n      Whether to enable shared work
    optimizer. The optimizer finds scan operator over the same table\n      and follow-up
    operators in the query plan and merges them if they meet some preconditions. Tez
    only.\n    </description>\n  </property>\n  <property>\n    <name>hive.optimize.shared.work.extended</name>\n
    \   <value>true</value>\n    <description>\n      Whether to enable shared work
    extended optimizer. The optimizer tries to merge equal operators\n      after
    a work boundary after shared work optimizer has been executed. Requires hive.optimize.shared.work\n
    \     to be set to true. Tez only.\n    </description>\n  </property>\n  <property>\n
    \   <name>hive.combine.equivalent.work.optimization</name>\n    <value>true</value>\n
    \   <description>\n      Whether to combine equivalent work objects during physical
    optimization.\n       This optimization looks for equivalent work objects and
    combines them if they meet certain preconditions. Spark only.\n    </description>\n
    \ </property>\n  <property>\n    <name>hive.optimize.remove.sq_count_check</name>\n
    \   <value>false</value>\n    <description>Whether to remove an extra join with
    sq_count_check for scalar subqueries with constant group by keys.</description>\n
    \ </property>\n  <property>\n    <name>hive.optimize.update.table.properties.from.serde</name>\n
    \   <value>false</value>\n    <description>\n      Whether to update table-properties
    by initializing tables' SerDe instances during logical-optimization. \n      By
    doing so, certain SerDe classes (like AvroSerDe) can pre-calculate table-specific
    information, and \n      store it in table-properties, to be used later in the
    SerDe, while running the job.\n    </description>\n  </property>\n  <property>\n
    \   <name>hive.optimize.update.table.properties.from.serde.list</name>\n    <value>org.apache.hadoop.hive.serde2.avro.AvroSerDe</value>\n
    \   <description>\n      The comma-separated list of SerDe classes that are considered
    when enhancing table-properties \n      during logical optimization.\n    </description>\n
    \ </property>\n  <property>\n    <name>hive.optimize.cte.materialize.threshold</name>\n
    \   <value>-1</value>\n    <description>\n      If the number of references to
    a CTE clause exceeds this threshold, Hive will materialize it\n      before executing
    the main query block. -1 will disable this feature.\n    </description>\n  </property>\n
    \ <property>\n    <name>hive.stats.estimate</name>\n    <value>true</value>\n
    \   <description>Estimate statistics in absence of statistics.</description>\n
    \ </property>\n  <property>\n    <name>hive.stats.ndv.estimate.percent</name>\n
    \   <value>20.0</value>\n    <description>This many percentage of rows will be
    estimated as count distinct in absence of statistics.</description>\n  </property>\n
    \ <property>\n    <name>hive.stats.num.nulls.estimate.percent</name>\n    <value>5.0</value>\n
    \   <description>This many percentage of rows will be estimated as number of nulls
    in absence of statistics.</description>\n  </property>\n  <property>\n    <name>hive.stats.autogather</name>\n
    \   <value>true</value>\n    <description>A flag to gather statistics (only basic)
    automatically during the INSERT OVERWRITE command.</description>\n  </property>\n
    \ <property>\n    <name>hive.stats.column.autogather</name>\n    <value>true</value>\n
    \   <description>A flag to gather column statistics automatically.</description>\n
    \ </property>\n  <property>\n    <name>hive.stats.dbclass</name>\n    <value>fs</value>\n
    \   <description>\n      Expects one of the pattern in [custom, fs].\n      The
    storage that stores temporary Hive statistics. In filesystem based statistics
    collection ('fs'), \n      each task writes statistics it has collected in a file
    on the filesystem, which will be aggregated \n      after the job has finished.
    Supported values are fs (filesystem) and custom as defined in StatsSetupConst.java.\n
    \   </description>\n  </property>\n  <property>\n    <name>hive.stats.default.publisher</name>\n
    \   <value/>\n    <description>The Java class (implementing the StatsPublisher
    interface) that is used by default if hive.stats.dbclass is custom type.</description>\n
    \ </property>\n  <property>\n    <name>hive.stats.default.aggregator</name>\n
    \   <value/>\n    <description>The Java class (implementing the StatsAggregator
    interface) that is used by default if hive.stats.dbclass is custom type.</description>\n
    \ </property>\n  <property>\n    <name>hive.client.stats.counters</name>\n    <value/>\n
    \   <description>\n      Subset of counters that should be of interest for hive.client.stats.publishers
    (when one wants to limit their publishing). \n      Non-display names should be
    used\n    </description>\n  </property>\n  <property>\n    <name>hive.stats.reliable</name>\n
    \   <value>false</value>\n    <description>\n      Whether queries will fail because
    stats cannot be collected completely accurately. \n      If this is set to true,
    reading/writing from/into a partition may fail because the stats\n      could
    not be computed accurately.\n    </description>\n  </property>\n  <property>\n
    \   <name>hive.analyze.stmt.collect.partlevel.stats</name>\n    <value>true</value>\n
    \   <description>analyze table T compute statistics for columns. Queries like
    these should compute partitionlevel stats for partitioned table even when no part
    spec is specified.</description>\n  </property>\n  <property>\n    <name>hive.stats.gather.num.threads</name>\n
    \   <value>10</value>\n    <description>\n      Number of threads used by noscan
    analyze command for partitioned tables.\n      This is applicable only for file
    formats that implement StatsProvidingRecordReader (like ORC).\n    </description>\n
    \ </property>\n  <property>\n    <name>hive.stats.collect.tablekeys</name>\n    <value>false</value>\n
    \   <description>\n      Whether join and group by keys on tables are derived
    and maintained in the QueryPlan.\n      This is useful to identify how tables
    are accessed and to determine if they should be bucketed.\n    </description>\n
    \ </property>\n  <property>\n    <name>hive.stats.collect.scancols</name>\n    <value>false</value>\n
    \   <description>\n      Whether column accesses are tracked in the QueryPlan.\n
    \     This is useful to identify how tables are accessed and to determine if there
    are wasted columns that can be trimmed.\n    </description>\n  </property>\n  <property>\n
    \   <name>hive.stats.ndv.algo</name>\n    <value>hll</value>\n    <description>\n
    \     Expects one of the pattern in [hll, fm].\n      hll and fm stand for HyperLogLog
    and FM-sketch, respectively for computing ndv.\n    </description>\n  </property>\n
    \ <property>\n    <name>hive.stats.fetch.bitvector</name>\n    <value>false</value>\n
    \   <description>Whether we fetch bitvector when we compute ndv. Users can turn
    it off if they want to use old schema</description>\n  </property>\n  <property>\n
    \   <name>hive.stats.ndv.error</name>\n    <value>20.0</value>\n    <description>\n
    \     Standard error expressed in percentage. Provides a tradeoff between accuracy
    and compute cost. \n      A lower value for error indicates higher accuracy and
    a higher compute cost.\n    </description>\n  </property>\n  <property>\n    <name>hive.metastore.stats.ndv.tuner</name>\n
    \   <value>0.0</value>\n    <description>\n      Provides a tunable parameter
    between the lower bound and the higher bound of ndv for aggregate ndv across all
    the partitions. \n      The lower bound is equal to the maximum of ndv of all
    the partitions. The higher bound is equal to the sum of ndv of all the partitions.\n
    \     Its value should be between 0.0 (i.e., choose lower bound) and 1.0 (i.e.,
    choose higher bound)\n    </description>\n  </property>\n  <property>\n    <name>hive.metastore.stats.ndv.densityfunction</name>\n
    \   <value>false</value>\n    <description>Whether to use density function to
    estimate the NDV for the whole table based on the NDV of partitions</description>\n
    \ </property>\n  <property>\n    <name>hive.stats.max.variable.length</name>\n
    \   <value>100</value>\n    <description>\n      To estimate the size of data
    flowing through operators in Hive/Tez(for reducer estimation etc.),\n      average
    row size is multiplied with the total number of rows coming out of each operator.\n
    \     Average row size is computed from average column size of all columns in
    the row. In the absence\n      of column statistics, for variable length columns
    (like string, bytes etc.), this value will be\n      used. For fixed length columns
    their corresponding Java equivalent sizes are used\n      (float - 4 bytes, double
    - 8 bytes etc.).\n    </description>\n  </property>\n  <property>\n    <name>hive.stats.list.num.entries</name>\n
    \   <value>10</value>\n    <description>\n      To estimate the size of data flowing
    through operators in Hive/Tez(for reducer estimation etc.),\n      average row
    size is multiplied with the total number of rows coming out of each operator.\n
    \     Average row size is computed from average column size of all columns in
    the row. In the absence\n      of column statistics and for variable length complex
    columns like list, the average number of\n      entries/values can be specified
    using this config.\n    </description>\n  </property>\n  <property>\n    <name>hive.stats.map.num.entries</name>\n
    \   <value>10</value>\n    <description>\n      To estimate the size of data flowing
    through operators in Hive/Tez(for reducer estimation etc.),\n      average row
    size is multiplied with the total number of rows coming out of each operator.\n
    \     Average row size is computed from average column size of all columns in
    the row. In the absence\n      of column statistics and for variable length complex
    columns like map, the average number of\n      entries/values can be specified
    using this config.\n    </description>\n  </property>\n  <property>\n    <name>hive.stats.fetch.column.stats</name>\n
    \   <value>false</value>\n    <description>\n      Annotation of operator tree
    with statistics information requires column statistics.\n      Column statistics
    are fetched from metastore. Fetching column statistics for each needed column\n
    \     can be expensive when the number of columns is high. This flag can be used
    to disable fetching\n      of column statistics from metastore.\n    </description>\n
    \ </property>\n  <property>\n    <name>hive.stats.join.factor</name>\n    <value>1.1</value>\n
    \   <description>\n      Hive/Tez optimizer estimates the data size flowing through
    each of the operators. JOIN operator\n      uses column statistics to estimate
    the number of rows flowing out of it and hence the data size.\n      In the absence
    of column statistics, this factor determines the amount of rows that flows out\n
    \     of JOIN operator.\n    </description>\n  </property>\n  <property>\n    <name>hive.stats.correlated.multi.key.joins</name>\n
    \   <value>true</value>\n    <description>When estimating output rows for a join
    involving multiple columns, the default behavior assumesthe columns are independent.
    Setting this flag to true will cause the estimator to assumethe columns are correlated.</description>\n
    \ </property>\n  <property>\n    <name>hive.stats.deserialization.factor</name>\n
    \   <value>10.0</value>\n    <description>\n      Hive/Tez optimizer estimates
    the data size flowing through each of the operators. In the absence\n      of
    basic statistics like number of rows and data size, file size is used to estimate
    the number\n      of rows and data size. Since files in tables/partitions are
    serialized (and optionally\n      compressed) the estimates of number of rows
    and data size cannot be reliably determined.\n      This factor is multiplied
    with the file size to account for serialization and compression.\n    </description>\n
    \ </property>\n  <property>\n    <name>hive.stats.filter.in.factor</name>\n    <value>1.0</value>\n
    \   <description>\n      Currently column distribution is assumed to be uniform.
    This can lead to overestimation/underestimation\n      in the number of rows filtered
    by a certain operator, which in turn might lead to overprovision or\n      underprovision
    of resources. This factor is applied to the cardinality estimation of IN clauses
    in\n      filter operators.\n    </description>\n  </property>\n  <property>\n
    \   <name>hive.stats.filter.in.min.ratio</name>\n    <value>0.05</value>\n    <description>Output
    estimation of an IN filter can't be lower than this ratio</description>\n  </property>\n
    \ <property>\n    <name>hive.support.concurrency</name>\n    <value>false</value>\n
    \   <description>\n      Whether Hive supports concurrency control or not. \n
    \     A ZooKeeper instance must be up and running when using zookeeper Hive lock
    manager \n    </description>\n  </property>\n  <property>\n    <name>hive.lock.manager</name>\n
    \   <value>org.apache.hadoop.hive.ql.lockmgr.zookeeper.ZooKeeperHiveLockManager</value>\n
    \   <description/>\n  </property>\n  <property>\n    <name>hive.lock.numretries</name>\n
    \   <value>100</value>\n    <description>The number of times you want to try to
    get all the locks</description>\n  </property>\n  <property>\n    <name>hive.unlock.numretries</name>\n
    \   <value>10</value>\n    <description>The number of times you want to retry
    to do one unlock</description>\n  </property>\n  <property>\n    <name>hive.lock.sleep.between.retries</name>\n
    \   <value>60s</value>\n    <description>\n      Expects a time value with unit
    (d/day, h/hour, m/min, s/sec, ms/msec, us/usec, ns/nsec), which is sec if not
    specified.\n      The time should be in between 0 sec (exclusive) and 9223372036854775807
    sec (exclusive).\n      The maximum sleep time between various retries\n    </description>\n
    \ </property>\n  <property>\n    <name>hive.lock.mapred.only.operation</name>\n
    \   <value>false</value>\n    <description>\n      This param is to control whether
    or not only do lock on queries\n      that need to execute at least one mapred
    job.\n    </description>\n  </property>\n  <property>\n    <name>hive.lock.query.string.max.length</name>\n
    \   <value>1000000</value>\n    <description>\n      The maximum length of the
    query string to store in the lock.\n      The default value is 1000000, since
    the data limit of a znode is 1MB\n    </description>\n  </property>\n  <property>\n
    \   <name>hive.mm.allow.originals</name>\n    <value>false</value>\n    <description>\n
    \     Whether to allow original files in MM tables. Conversion to MM may be expensive
    if\n      this is set to false, however unless MAPREDUCE-7086 fix is present,
    queries that\n      read MM tables with original files will fail. The default
    in Hive 3.0 is false.\n    </description>\n  </property>\n  <property>\n    <name>hive.zookeeper.quorum</name>\n
    \   <value/>\n    <description>\n      List of ZooKeeper servers to talk to. This
    is needed for: \n      1. Read/write locks - when hive.lock.manager is set to
    \n      org.apache.hadoop.hive.ql.lockmgr.zookeeper.ZooKeeperHiveLockManager,
    \n      2. When HiveServer2 supports service discovery via Zookeeper.\n      3.
    For delegation token storage if zookeeper store is used, if\n      hive.cluster.delegation.token.store.zookeeper.connectString
    is not set\n      4. LLAP daemon registry service\n      5. Leader selection for
    privilege synchronizer\n    </description>\n  </property>\n  <property>\n    <name>hive.zookeeper.client.port</name>\n
    \   <value>2181</value>\n    <description>\n      The port of ZooKeeper servers
    to talk to.\n      If the list of Zookeeper servers specified in hive.zookeeper.quorum\n
    \     does not contain port numbers, this value is used.\n    </description>\n
    \ </property>\n  <property>\n    <name>hive.zookeeper.session.timeout</name>\n
    \   <value>1200000ms</value>\n    <description>\n      Expects a time value with
    unit (d/day, h/hour, m/min, s/sec, ms/msec, us/usec, ns/nsec), which is msec if
    not specified.\n      ZooKeeper client's session timeout (in milliseconds). The
    client is disconnected, and as a result, all locks released, \n      if a heartbeat
    is not sent in the timeout.\n    </description>\n  </property>\n  <property>\n
    \   <name>hive.zookeeper.connection.timeout</name>\n    <value>15s</value>\n    <description>\n
    \     Expects a time value with unit (d/day, h/hour, m/min, s/sec, ms/msec, us/usec,
    ns/nsec), which is sec if not specified.\n      ZooKeeper client's connection
    timeout in seconds. Connection timeout * hive.zookeeper.connection.max.retries\n
    \     with exponential backoff is when curator client deems connection is lost
    to zookeeper.\n    </description>\n  </property>\n  <property>\n    <name>hive.zookeeper.namespace</name>\n
    \   <value>hive_zookeeper_namespace</value>\n    <description>The parent node
    under which all ZooKeeper nodes are created.</description>\n  </property>\n  <property>\n
    \   <name>hive.zookeeper.clean.extra.nodes</name>\n    <value>false</value>\n
    \   <description>Clean extra nodes at the end of the session.</description>\n
    \ </property>\n  <property>\n    <name>hive.zookeeper.connection.max.retries</name>\n
    \   <value>3</value>\n    <description>Max number of times to retry when connecting
    to the ZooKeeper server.</description>\n  </property>\n  <property>\n    <name>hive.zookeeper.connection.basesleeptime</name>\n
    \   <value>1000ms</value>\n    <description>\n      Expects a time value with
    unit (d/day, h/hour, m/min, s/sec, ms/msec, us/usec, ns/nsec), which is msec if
    not specified.\n      Initial amount of time (in milliseconds) to wait between
    retries\n      when connecting to the ZooKeeper server when using ExponentialBackoffRetry
    policy.\n    </description>\n  </property>\n  <property>\n    <name>hive.txn.manager</name>\n
    \   <value>org.apache.hadoop.hive.ql.lockmgr.DummyTxnManager</value>\n    <description>\n
    \     Set to org.apache.hadoop.hive.ql.lockmgr.DbTxnManager as part of turning
    on Hive\n      transactions, which also requires appropriate settings for hive.compactor.initiator.on,\n
    \     hive.compactor.worker.threads, hive.support.concurrency (true),\n      and
    hive.exec.dynamic.partition.mode (nonstrict).\n      The default DummyTxnManager
    replicates pre-Hive-0.13 behavior and provides\n      no transactions.\n    </description>\n
    \ </property>\n  <property>\n    <name>hive.txn.strict.locking.mode</name>\n    <value>true</value>\n
    \   <description>\n      In strict mode non-ACID\n      resources use standard
    R/W lock semantics, e.g. INSERT will acquire exclusive lock.\n      In nonstrict
    mode, for non-ACID resources, INSERT will only acquire shared lock, which\n      allows
    two concurrent writes to the same partition but still lets lock manager prevent\n
    \     DROP TABLE etc. when the table is being written to\n    </description>\n
    \ </property>\n  <property>\n    <name>hive.txn.xlock.iow</name>\n    <value>true</value>\n
    \   <description>\n      Ensures commands with OVERWRITE (such as INSERT OVERWRITE)
    acquire Exclusive locks for transactional tables.  This ensures that inserts (w/o
    overwrite) running concurrently\n      are not hidden by the INSERT OVERWRITE.\n
    \   </description>\n  </property>\n  <property>\n    <name>hive.txn.timeout</name>\n
    \   <value>300s</value>\n    <description>\n      Expects a time value with unit
    (d/day, h/hour, m/min, s/sec, ms/msec, us/usec, ns/nsec), which is sec if not
    specified.\n      time after which transactions are declared aborted if the client
    has not sent a heartbeat.\n    </description>\n  </property>\n  <property>\n    <name>hive.txn.heartbeat.threadpool.size</name>\n
    \   <value>5</value>\n    <description>The number of threads to use for heartbeating.
    For Hive CLI, 1 is enough. For HiveServer2, we need a few</description>\n  </property>\n
    \ <property>\n    <name>hive.txn.manager.dump.lock.state.on.acquire.timeout</name>\n
    \   <value>false</value>\n    <description>Set this to true so that when attempt
    to acquire a lock on resource times out, the current state of the lock manager
    is dumped to log file.  This is for debugging.  See also hive.lock.numretries
    and hive.lock.sleep.between.retries.</description>\n  </property>\n  <property>\n
    \   <name>hive.max.open.txns</name>\n    <value>100000</value>\n    <description>\n
    \     Maximum number of open transactions. If \n      current open transactions
    reach this limit, future open transaction requests will be \n      rejected, until
    this number goes below the limit.\n    </description>\n  </property>\n  <property>\n
    \   <name>hive.count.open.txns.interval</name>\n    <value>1s</value>\n    <description>\n
    \     Expects a time value with unit (d/day, h/hour, m/min, s/sec, ms/msec, us/usec,
    ns/nsec), which is sec if not specified.\n      Time in seconds between checks
    to count open transactions.\n    </description>\n  </property>\n  <property>\n
    \   <name>hive.txn.max.open.batch</name>\n    <value>1000</value>\n    <description>\n
    \     Maximum number of transactions that can be fetched in one call to open_txns().\n
    \     This controls how many transactions streaming agents such as Flume or Storm
    open\n      simultaneously. The streaming agent then writes that number of entries
    into a single\n      file (per Flume agent or Storm bolt). Thus increasing this
    value decreases the number\n      of delta files created by streaming agents.
    But it also increases the number of open\n      transactions that Hive has to
    track at any given time, which may negatively affect\n      read performance.\n
    \   </description>\n  </property>\n  <property>\n    <name>hive.txn.retryable.sqlex.regex</name>\n
    \   <value/>\n    <description>\n      Comma separated list\n      of regular
    expression patterns for SQL state, error code, and error message of\n      retryable
    SQLExceptions, that's suitable for the metastore DB.\n      For example: Can't
    serialize.*,40001$,^Deadlock,.*ORA-08176.*\n      The string that the regex will
    be matched against is of the following form, where ex is a SQLException:\n      ex.getMessage()
    + \" (SQLState=\" + ex.getSQLState() + \", ErrorCode=\" + ex.getErrorCode() +
    \")\"\n    </description>\n  </property>\n  <property>\n    <name>hive.compactor.initiator.on</name>\n
    \   <value>false</value>\n    <description>\n      Whether to run the initiator
    and cleaner threads on this metastore instance or not.\n      Set this to true
    on one instance of the Thrift metastore service as part of turning\n      on Hive
    transactions. For a complete list of parameters required for turning on\n      transactions,
    see hive.txn.manager.\n    </description>\n  </property>\n  <property>\n    <name>hive.compactor.worker.threads</name>\n
    \   <value>0</value>\n    <description>\n      How many compactor worker threads
    to run on this metastore instance. Set this to a\n      positive number on one
    or more instances of the Thrift metastore service as part of\n      turning on
    Hive transactions. For a complete list of parameters required for turning\n      on
    transactions, see hive.txn.manager.\n      Worker threads spawn MapReduce jobs
    to do compactions. They do not do the compactions\n      themselves. Increasing
    the number of worker threads will decrease the time it takes\n      tables or
    partitions to be compacted once they are determined to need compaction.\n      It
    will also increase the background load on the Hadoop cluster as more MapReduce
    jobs\n      will be running in the background.\n    </description>\n  </property>\n
    \ <property>\n    <name>hive.compactor.worker.timeout</name>\n    <value>86400s</value>\n
    \   <description>\n      Expects a time value with unit (d/day, h/hour, m/min,
    s/sec, ms/msec, us/usec, ns/nsec), which is sec if not specified.\n      Time
    in seconds after which a compaction job will be declared failed and the\n      compaction
    re-queued.\n    </description>\n  </property>\n  <property>\n    <name>hive.compactor.check.interval</name>\n
    \   <value>300s</value>\n    <description>\n      Expects a time value with unit
    (d/day, h/hour, m/min, s/sec, ms/msec, us/usec, ns/nsec), which is sec if not
    specified.\n      Time in seconds between checks to see if any tables or partitions
    need to be\n      compacted. This should be kept high because each check for compaction
    requires\n      many calls against the NameNode.\n      Decreasing this value
    will reduce the time it takes for compaction to be started\n      for a table
    or partition that requires compaction. However, checking if compaction\n      is
    needed requires several calls to the NameNode for each table or partition that\n
    \     has had a transaction done on it since the last major compaction. So decreasing
    this\n      value will increase the load on the NameNode.\n    </description>\n
    \ </property>\n  <property>\n    <name>hive.compactor.delta.num.threshold</name>\n
    \   <value>10</value>\n    <description>\n      Number of delta directories in
    a table or partition that will trigger a minor\n      compaction.\n    </description>\n
    \ </property>\n  <property>\n    <name>hive.compactor.delta.pct.threshold</name>\n
    \   <value>0.1</value>\n    <description>\n      Percentage (fractional) size
    of the delta files relative to the base that will trigger\n      a major compaction.
    (1.0 = 100%, so the default 0.1 = 10%.)\n    </description>\n  </property>\n  <property>\n
    \   <name>hive.compactor.max.num.delta</name>\n    <value>500</value>\n    <description>Maximum
    number of delta files that the compactor will attempt to handle in a single job.</description>\n
    \ </property>\n  <property>\n    <name>hive.compactor.abortedtxn.threshold</name>\n
    \   <value>1000</value>\n    <description>\n      Number of aborted transactions
    involving a given table or partition that will trigger\n      a major compaction.\n
    \   </description>\n  </property>\n  <property>\n    <name>hive.compactor.initiator.failed.compacts.threshold</name>\n
    \   <value>2</value>\n    <description>\n      Expects value between 1 and 20.\n
    \     Number of consecutive compaction failures (per table/partition) after which
    automatic compactions will not be scheduled any more.  Note that this must be
    less than hive.compactor.history.retention.failed.\n    </description>\n  </property>\n
    \ <property>\n    <name>hive.compactor.cleaner.run.interval</name>\n    <value>5000ms</value>\n
    \   <description>\n      Expects a time value with unit (d/day, h/hour, m/min,
    s/sec, ms/msec, us/usec, ns/nsec), which is msec if not specified.\n      Time
    between runs of the cleaner thread\n    </description>\n  </property>\n  <property>\n
    \   <name>hive.compactor.job.queue</name>\n    <value/>\n    <description>\n      Used
    to specify name of Hadoop queue to which\n      Compaction jobs will be submitted.
    \ Set to empty string to let Hadoop choose the queue.\n    </description>\n  </property>\n
    \ <property>\n    <name>hive.transactional.concatenate.noblock</name>\n    <value>false</value>\n
    \   <description>Will cause 'alter table T concatenate' to be non-blocking</description>\n
    \ </property>\n  <property>\n    <name>hive.compactor.compact.insert.only</name>\n
    \   <value>true</value>\n    <description>Whether the compactor should compact
    insert-only tables. A safety switch.</description>\n  </property>\n  <property>\n
    \   <name>hive.compactor.history.retention.succeeded</name>\n    <value>3</value>\n
    \   <description>\n      Expects value between 0 and 100.\n      Determines how
    many successful compaction records will be retained in compaction history for
    a given table/partition.\n    </description>\n  </property>\n  <property>\n    <name>hive.compactor.history.retention.failed</name>\n
    \   <value>3</value>\n    <description>\n      Expects value between 0 and 100.\n
    \     Determines how many failed compaction records will be retained in compaction
    history for a given table/partition.\n    </description>\n  </property>\n  <property>\n
    \   <name>hive.compactor.history.retention.attempted</name>\n    <value>2</value>\n
    \   <description>\n      Expects value between 0 and 100.\n      Determines how
    many attempted compaction records will be retained in compaction history for a
    given table/partition.\n    </description>\n  </property>\n  <property>\n    <name>hive.compactor.history.reaper.interval</name>\n
    \   <value>2m</value>\n    <description>\n      Expects a time value with unit
    (d/day, h/hour, m/min, s/sec, ms/msec, us/usec, ns/nsec), which is msec if not
    specified.\n      Determines how often compaction history reaper runs\n    </description>\n
    \ </property>\n  <property>\n    <name>hive.timedout.txn.reaper.start</name>\n
    \   <value>100s</value>\n    <description>\n      Expects a time value with unit
    (d/day, h/hour, m/min, s/sec, ms/msec, us/usec, ns/nsec), which is msec if not
    specified.\n      Time delay of 1st reaper run after metastore start\n    </description>\n
    \ </property>\n  <property>\n    <name>hive.timedout.txn.reaper.interval</name>\n
    \   <value>180s</value>\n    <description>\n      Expects a time value with unit
    (d/day, h/hour, m/min, s/sec, ms/msec, us/usec, ns/nsec), which is msec if not
    specified.\n      Time interval describing how often the reaper runs\n    </description>\n
    \ </property>\n  <property>\n    <name>hive.writeset.reaper.interval</name>\n
    \   <value>60s</value>\n    <description>\n      Expects a time value with unit
    (d/day, h/hour, m/min, s/sec, ms/msec, us/usec, ns/nsec), which is msec if not
    specified.\n      Frequency of WriteSet reaper runs\n    </description>\n  </property>\n
    \ <property>\n    <name>hive.merge.cardinality.check</name>\n    <value>true</value>\n
    \   <description>\n      Set to true to ensure that each SQL Merge statement ensures
    that for each row in the target\n      table there is at most 1 matching row in
    the source table per SQL Specification.\n    </description>\n  </property>\n  <property>\n
    \   <name>hive.arrow.root.allocator.limit</name>\n    <value>9223372036854775807</value>\n
    \   <description>Arrow root allocator memory size limitation in bytes.</description>\n
    \ </property>\n  <property>\n    <name>hive.arrow.batch.size</name>\n    <value>1000</value>\n
    \   <description>The number of rows sent in one Arrow batch.</description>\n  </property>\n
    \ <property>\n    <name>hive.druid.indexer.segments.granularity</name>\n    <value>DAY</value>\n
    \   <description>\n      Expects one of the pattern in [YEAR, MONTH, WEEK, DAY,
    HOUR, MINUTE, SECOND].\n      Granularity for the segments created by the Druid
    storage handler\n    </description>\n  </property>\n  <property>\n    <name>hive.druid.indexer.partition.size.max</name>\n
    \   <value>5000000</value>\n    <description>Maximum number of records per segment
    partition</description>\n  </property>\n  <property>\n    <name>hive.druid.indexer.memory.rownum.max</name>\n
    \   <value>75000</value>\n    <description>Maximum number of records in memory
    while storing data in Druid</description>\n  </property>\n  <property>\n    <name>hive.druid.broker.address.default</name>\n
    \   <value>localhost:8082</value>\n    <description>\n      Address of the Druid
    broker. If we are querying Druid from Hive, this address needs to be\n      declared\n
    \   </description>\n  </property>\n  <property>\n    <name>hive.druid.coordinator.address.default</name>\n
    \   <value>localhost:8081</value>\n    <description>Address of the Druid coordinator.
    It is used to check the load status of newly created segments</description>\n
    \ </property>\n  <property>\n    <name>hive.druid.overlord.address.default</name>\n
    \   <value>localhost:8090</value>\n    <description>Address of the Druid overlord.
    It is used to submit indexing tasks to druid.</description>\n  </property>\n  <property>\n
    \   <name>hive.druid.select.threshold</name>\n    <value>10000</value>\n    <description>\n
    \     Takes only effect when hive.druid.select.distribute is set to false. \n
    \     When we can split a Select query, this is the maximum number of rows that
    we try to retrieve\n      per query. In order to do that, we obtain the estimated
    size for the complete result. If the\n      number of records of the query results
    is larger than this threshold, we split the query in\n      total number of rows/threshold
    parts across the time dimension. Note that we assume the\n      records to be
    split uniformly across the time dimension.\n    </description>\n  </property>\n
    \ <property>\n    <name>hive.druid.http.numConnection</name>\n    <value>20</value>\n
    \   <description>\n      Number of connections used by\n      the HTTP client.\n
    \   </description>\n  </property>\n  <property>\n    <name>hive.druid.http.read.timeout</name>\n
    \   <value>PT1M</value>\n    <description>\n      Read timeout period for the
    HTTP\n      client in ISO8601 format (for example P2W, P3M, PT1H30M, PT0.750S),
    default is period of 1 minute.\n    </description>\n  </property>\n  <property>\n
    \   <name>hive.druid.sleep.time</name>\n    <value>PT10S</value>\n    <description>Sleep
    time between retries in ISO8601 format (for example P2W, P3M, PT1H30M, PT0.750S),
    default is period of 10 seconds.</description>\n  </property>\n  <property>\n
    \   <name>hive.druid.basePersistDirectory</name>\n    <value/>\n    <description>Local
    temporary directory used to persist intermediate indexing state, will default
    to JVM system property java.io.tmpdir.</description>\n  </property>\n  <property>\n
    \   <name>hive.druid.storage.storageDirectory</name>\n    <value>/druid/segments</value>\n
    \   <description>druid deep storage location.</description>\n  </property>\n  <property>\n
    \   <name>hive.druid.metadata.base</name>\n    <value>druid</value>\n    <description>Default
    prefix for metadata tables</description>\n  </property>\n  <property>\n    <name>hive.druid.metadata.db.type</name>\n
    \   <value>mysql</value>\n    <description>\n      Expects one of the pattern
    in [mysql, postgresql, derby].\n      Type of the metadata database.\n    </description>\n
    \ </property>\n  <property>\n    <name>hive.druid.metadata.username</name>\n    <value/>\n
    \   <description>Username to connect to Type of the metadata DB.</description>\n
    \ </property>\n  <property>\n    <name>hive.druid.metadata.password</name>\n    <value/>\n
    \   <description>Password to connect to Type of the metadata DB.</description>\n
    \ </property>\n  <property>\n    <name>hive.druid.metadata.uri</name>\n    <value/>\n
    \   <description>URI to connect to the database (for example jdbc:mysql://hostname:port/DBName).</description>\n
    \ </property>\n  <property>\n    <name>hive.druid.working.directory</name>\n    <value>/tmp/workingDirectory</value>\n
    \   <description>Default hdfs working directory used to store some intermediate
    metadata</description>\n  </property>\n  <property>\n    <name>hive.druid.maxTries</name>\n
    \   <value>5</value>\n    <description>Maximum number of retries before giving
    up</description>\n  </property>\n  <property>\n    <name>hive.druid.passiveWaitTimeMs</name>\n
    \   <value>30000</value>\n    <description>Wait time in ms default to 30 seconds.</description>\n
    \ </property>\n  <property>\n    <name>hive.druid.bitmap.type</name>\n    <value>roaring</value>\n
    \   <description>\n      Expects one of the pattern in [roaring, concise].\n      Coding
    algorithm use to encode the bitmaps\n    </description>\n  </property>\n  <property>\n
    \   <name>hive.hbase.wal.enabled</name>\n    <value>true</value>\n    <description>\n
    \     Whether writes to HBase should be forced to the write-ahead log. \n      Disabling
    this improves HBase write performance at the risk of lost writes in case of a
    crash.\n    </description>\n  </property>\n  <property>\n    <name>hive.hbase.generatehfiles</name>\n
    \   <value>false</value>\n    <description>True when HBaseStorageHandler should
    generate hfiles instead of operate against the online table.</description>\n  </property>\n
    \ <property>\n    <name>hive.hbase.snapshot.name</name>\n    <value/>\n    <description>The
    HBase table snapshot name to use.</description>\n  </property>\n  <property>\n
    \   <name>hive.hbase.snapshot.restoredir</name>\n    <value>/tmp</value>\n    <description>The
    directory in which to restore the HBase table snapshot.</description>\n  </property>\n
    \ <property>\n    <name>hive.archive.enabled</name>\n    <value>false</value>\n
    \   <description>Whether archiving operations are permitted</description>\n  </property>\n
    \ <property>\n    <name>hive.fetch.task.conversion</name>\n    <value>more</value>\n
    \   <description>\n      Expects one of [none, minimal, more].\n      Some select
    queries can be converted to single FETCH task minimizing latency.\n      Currently
    the query should be single sourced not having any subquery and should not have\n
    \     any aggregations or distincts (which incurs RS), lateral views and joins.\n
    \     0. none : disable hive.fetch.task.conversion\n      1. minimal : SELECT
    STAR, FILTER on partition columns, LIMIT only\n      2. more    : SELECT, FILTER,
    LIMIT only (support TABLESAMPLE and virtual columns)\n    </description>\n  </property>\n
    \ <property>\n    <name>hive.fetch.task.conversion.threshold</name>\n    <value>1073741824</value>\n
    \   <description>\n      Input threshold for applying hive.fetch.task.conversion.
    If target table is native, input length\n      is calculated by summation of file
    lengths. If it's not native, storage handler for the table\n      can optionally
    implement org.apache.hadoop.hive.ql.metadata.InputEstimator interface.\n    </description>\n
    \ </property>\n  <property>\n    <name>hive.fetch.task.aggr</name>\n    <value>false</value>\n
    \   <description>\n      Aggregation queries with no group-by clause (for example,
    select count(*) from src) execute\n      final aggregations in single reduce task.
    If this is set true, Hive delegates final aggregation\n      stage to fetch task,
    possibly decreasing the query time.\n    </description>\n  </property>\n  <property>\n
    \   <name>hive.compute.query.using.stats</name>\n    <value>true</value>\n    <description>\n
    \     When set to true Hive will answer a few queries like count(1) purely using
    stats\n      stored in metastore. For basic stats collection turn on the config
    hive.stats.autogather to true.\n      For more advanced stats collection need
    to run analyze table queries.\n    </description>\n  </property>\n  <property>\n
    \   <name>hive.fetch.output.serde</name>\n    <value>org.apache.hadoop.hive.serde2.DelimitedJSONSerDe</value>\n
    \   <description>The SerDe used by FetchTask to serialize the fetch output.</description>\n
    \ </property>\n  <property>\n    <name>hive.cache.expr.evaluation</name>\n    <value>true</value>\n
    \   <description>\n      If true, the evaluation result of a deterministic expression
    referenced twice or more\n      will be cached.\n      For example, in a filter
    condition like '.. where key + 10 = 100 or key + 10 = 0'\n      the expression
    'key + 10' will be evaluated/cached once and reused for the following\n      expression
    ('key + 10 = 0'). Currently, this is applied only to expressions in select\n      or
    filter operators.\n    </description>\n  </property>\n  <property>\n    <name>hive.variable.substitute</name>\n
    \   <value>true</value>\n    <description>This enables substitution using syntax
    like ${var} ${system:var} and ${env:var}.</description>\n  </property>\n  <property>\n
    \   <name>hive.variable.substitute.depth</name>\n    <value>40</value>\n    <description>The
    maximum replacements the substitution engine will do.</description>\n  </property>\n
    \ <property>\n    <name>hive.conf.validation</name>\n    <value>true</value>\n
    \   <description>Enables type checking for registered Hive configurations</description>\n
    \ </property>\n  <property>\n    <name>hive.semantic.analyzer.hook</name>\n    <value/>\n
    \   <description/>\n  </property>\n  <property>\n    <name>hive.security.authorization.enabled</name>\n
    \   <value>false</value>\n    <description>enable or disable the Hive client authorization</description>\n
    \ </property>\n  <property>\n    <name>hive.security.authorization.manager</name>\n
    \   <value>org.apache.hadoop.hive.ql.security.authorization.plugin.sqlstd.SQLStdHiveAuthorizerFactory</value>\n
    \   <description>\n      The Hive client authorization manager class name. The
    user defined authorization class should implement \n      interface org.apache.hadoop.hive.ql.security.authorization.HiveAuthorizationProvider.\n
    \   </description>\n  </property>\n  <property>\n    <name>hive.security.authenticator.manager</name>\n
    \   <value>org.apache.hadoop.hive.ql.security.HadoopDefaultAuthenticator</value>\n
    \   <description>\n      hive client authenticator manager class name. The user
    defined authenticator should implement \n      interface org.apache.hadoop.hive.ql.security.HiveAuthenticationProvider.\n
    \   </description>\n  </property>\n  <property>\n    <name>hive.security.metastore.authorization.manager</name>\n
    \   <value>org.apache.hadoop.hive.ql.security.authorization.DefaultHiveMetastoreAuthorizationProvider</value>\n
    \   <description>\n      Names of authorization manager classes (comma separated)
    to be used in the metastore\n      for authorization. The user defined authorization
    class should implement interface\n      org.apache.hadoop.hive.ql.security.authorization.HiveMetastoreAuthorizationProvider.\n
    \     All authorization manager classes have to successfully authorize the metastore
    API\n      call for the command execution to be allowed.\n    </description>\n
    \ </property>\n  <property>\n    <name>hive.security.metastore.authorization.auth.reads</name>\n
    \   <value>true</value>\n    <description>If this is true, metastore authorizer
    authorizes read actions on database, table</description>\n  </property>\n  <property>\n
    \   <name>hive.security.metastore.authenticator.manager</name>\n    <value>org.apache.hadoop.hive.ql.security.HadoopDefaultMetastoreAuthenticator</value>\n
    \   <description>\n      authenticator manager class name to be used in the metastore
    for authentication. \n      The user defined authenticator should implement interface
    org.apache.hadoop.hive.ql.security.HiveAuthenticationProvider.\n    </description>\n
    \ </property>\n  <property>\n    <name>hive.security.authorization.createtable.user.grants</name>\n
    \   <value/>\n    <description>\n      the privileges automatically granted to
    some users whenever a table gets created.\n      An example like \"userX,userY:select;userZ:create\"
    will grant select privilege to userX and userY,\n      and grant create privilege
    to userZ whenever a new table created.\n    </description>\n  </property>\n  <property>\n
    \   <name>hive.security.authorization.createtable.group.grants</name>\n    <value/>\n
    \   <description>\n      the privileges automatically granted to some groups whenever
    a table gets created.\n      An example like \"groupX,groupY:select;groupZ:create\"
    will grant select privilege to groupX and groupY,\n      and grant create privilege
    to groupZ whenever a new table created.\n    </description>\n  </property>\n  <property>\n
    \   <name>hive.security.authorization.createtable.role.grants</name>\n    <value/>\n
    \   <description>\n      the privileges automatically granted to some roles whenever
    a table gets created.\n      An example like \"roleX,roleY:select;roleZ:create\"
    will grant select privilege to roleX and roleY,\n      and grant create privilege
    to roleZ whenever a new table created.\n    </description>\n  </property>\n  <property>\n
    \   <name>hive.security.authorization.createtable.owner.grants</name>\n    <value/>\n
    \   <description>\n      The privileges automatically granted to the owner whenever
    a table gets created.\n      An example like \"select,drop\" will grant select
    and drop privilege to the owner\n      of the table. Note that the default gives
    the creator of a table no access to the\n      table (but see HIVE-8067).\n    </description>\n
    \ </property>\n  <property>\n    <name>hive.security.authorization.task.factory</name>\n
    \   <value>org.apache.hadoop.hive.ql.parse.authorization.HiveAuthorizationTaskFactoryImpl</value>\n
    \   <description>Authorization DDL task factory implementation</description>\n
    \ </property>\n  <property>\n    <name>hive.security.authorization.sqlstd.confwhitelist</name>\n
    \   <value/>\n    <description>\n      A Java regex. Configurations parameters
    that match this\n      regex can be modified by user when SQL standard authorization
    is enabled.\n      To get the default value, use the 'set &lt;param&gt;' command.\n
    \     Note that the hive.conf.restricted.list checks are still enforced after
    the white list\n      check\n    </description>\n  </property>\n  <property>\n
    \   <name>hive.security.authorization.sqlstd.confwhitelist.append</name>\n    <value/>\n
    \   <description>\n      2nd Java regex that it would match in addition to\n      hive.security.authorization.sqlstd.confwhitelist.\n
    \     Do not include a starting \"|\" in the value. Using this regex instead\n
    \     of updating the original regex means that you can append to the default\n
    \     set by SQL standard authorization instead of replacing it entirely.\n    </description>\n
    \ </property>\n  <property>\n    <name>hive.cli.print.header</name>\n    <value>false</value>\n
    \   <description>Whether to print the names of the columns in query output.</description>\n
    \ </property>\n  <property>\n    <name>hive.cli.print.escape.crlf</name>\n    <value>false</value>\n
    \   <description>Whether to print carriage returns and line feeds in row output
    as escaped \\r and \\n</description>\n  </property>\n  <property>\n    <name>hive.cli.tez.session.async</name>\n
    \   <value>true</value>\n    <description>\n      Whether to start Tez\n      session
    in background when running CLI with Tez, allowing CLI to be available earlier.\n
    \   </description>\n  </property>\n  <property>\n    <name>hive.disable.unsafe.external.table.operations</name>\n
    \   <value>true</value>\n    <description>Whether to disable certain optimizations
    and operations on external tables, on the assumption that data changes by external
    applications may have negative effects on these operations.</description>\n  </property>\n
    \ <property>\n    <name>hive.error.on.empty.partition</name>\n    <value>false</value>\n
    \   <description>Whether to throw an exception if dynamic partition insert generates
    empty results.</description>\n  </property>\n  <property>\n    <name>hive.exim.uri.scheme.whitelist</name>\n
    \   <value>hdfs,pfile,file,s3,s3a</value>\n    <description>A comma separated
    list of acceptable URI schemes for import and export.</description>\n  </property>\n
    \ <property>\n    <name>hive.exim.strict.repl.tables</name>\n    <value>true</value>\n
    \   <description>\n      Parameter that determines if 'regular' (non-replication)
    export dumps can be\n      imported on to tables that are the target of replication.
    If this parameter is\n      set, regular imports will check if the destination
    table(if it exists) has a 'repl.last.id' set on it. If so, it will fail.\n    </description>\n
    \ </property>\n  <property>\n    <name>hive.repl.task.factory</name>\n    <value>org.apache.hive.hcatalog.api.repl.exim.EximReplicationTaskFactory</value>\n
    \   <description>\n      Parameter that can be used to override which ReplicationTaskFactory
    will be\n      used to instantiate ReplicationTask events. Override for third
    party repl plugins\n    </description>\n  </property>\n  <property>\n    <name>hive.mapper.cannot.span.multiple.partitions</name>\n
    \   <value>false</value>\n    <description/>\n  </property>\n  <property>\n    <name>hive.rework.mapredwork</name>\n
    \   <value>false</value>\n    <description>\n      should rework the mapred work
    or not.\n      This is first introduced by SymlinkTextInputFormat to replace symlink
    files with real paths at compile time.\n    </description>\n  </property>\n  <property>\n
    \   <name>hive.io.exception.handlers</name>\n    <value/>\n    <description>\n
    \     A list of io exception handler class names. This is used\n      to construct
    a list exception handlers to handle exceptions thrown\n      by record readers\n
    \   </description>\n  </property>\n  <property>\n    <name>hive.log4j.file</name>\n
    \   <value/>\n    <description>\n      Hive log4j configuration file.\n      If
    the property is not set, then logging will be initialized using hive-log4j2.properties
    found on the classpath.\n      If the property is set, the value must be a valid
    URI (java.net.URI, e.g. \"file:///tmp/my-logging.xml\"), \n      which you can
    then extract a URL from and pass to PropertyConfigurator.configure(URL).\n    </description>\n
    \ </property>\n  <property>\n    <name>hive.exec.log4j.file</name>\n    <value/>\n
    \   <description>\n      Hive log4j configuration file for execution mode(sub
    command).\n      If the property is not set, then logging will be initialized
    using hive-exec-log4j2.properties found on the classpath.\n      If the property
    is set, the value must be a valid URI (java.net.URI, e.g. \"file:///tmp/my-logging.xml\"),
    \n      which you can then extract a URL from and pass to PropertyConfigurator.configure(URL).\n
    \   </description>\n  </property>\n  <property>\n    <name>hive.async.log.enabled</name>\n
    \   <value>true</value>\n    <description>\n      Whether to enable Log4j2's asynchronous
    logging. Asynchronous logging can give\n       significant performance improvement
    as logging will be handled in separate thread\n       that uses LMAX disruptor
    queue for buffering log messages.\n       Refer https://logging.apache.org/log4j/2.x/manual/async.html
    for benefits and\n       drawbacks.\n    </description>\n  </property>\n  <property>\n
    \   <name>hive.log.explain.output</name>\n    <value>false</value>\n    <description>\n
    \     Whether to log explain output for every query.\n      When enabled, will
    log EXPLAIN EXTENDED output for the query at INFO log4j log level\n      and in
    WebUI / Drilldown / Show Query.\n    </description>\n  </property>\n  <property>\n
    \   <name>hive.explain.user</name>\n    <value>true</value>\n    <description>\n
    \     Whether to show explain result at user level.\n      When enabled, will
    log EXPLAIN output for the query at user level. Tez only.\n    </description>\n
    \ </property>\n  <property>\n    <name>hive.spark.explain.user</name>\n    <value>false</value>\n
    \   <description>\n      Whether to show explain result at user level.\n      When
    enabled, will log EXPLAIN output for the query at user level. Spark only.\n    </description>\n
    \ </property>\n  <property>\n    <name>hive.autogen.columnalias.prefix.label</name>\n
    \   <value>_c</value>\n    <description>\n      String used as a prefix when auto
    generating column alias.\n      By default the prefix label will be appended with
    a column position number to form the column alias. \n      Auto generation would
    happen if an aggregate function is used in a select clause without an explicit
    alias.\n    </description>\n  </property>\n  <property>\n    <name>hive.autogen.columnalias.prefix.includefuncname</name>\n
    \   <value>false</value>\n    <description>Whether to include function name in
    the column alias auto generated by Hive.</description>\n  </property>\n  <property>\n
    \   <name>hive.service.metrics.class</name>\n    <value>org.apache.hadoop.hive.common.metrics.metrics2.CodahaleMetrics</value>\n
    \   <description>\n      Expects one of [org.apache.hadoop.hive.common.metrics.metrics2.codahalemetrics,
    org.apache.hadoop.hive.common.metrics.legacymetrics].\n      Hive metrics subsystem
    implementation class.\n    </description>\n  </property>\n  <property>\n    <name>hive.service.metrics.codahale.reporter.classes</name>\n
    \   <value>org.apache.hadoop.hive.common.metrics.metrics2.JsonFileMetricsReporter,
    org.apache.hadoop.hive.common.metrics.metrics2.JmxMetricsReporter</value>\n    <description>Comma
    separated list of reporter implementation classes for metric class org.apache.hadoop.hive.common.metrics.metrics2.CodahaleMetrics.
    Overrides HIVE_METRICS_REPORTER conf if present</description>\n  </property>\n
    \ <property>\n    <name>hive.service.metrics.reporter</name>\n    <value/>\n    <description>Reporter
    implementations for metric class org.apache.hadoop.hive.common.metrics.metrics2.CodahaleMetrics;Deprecated,
    use HIVE_CODAHALE_METRICS_REPORTER_CLASSES instead. This configuraiton will be
    overridden by HIVE_CODAHALE_METRICS_REPORTER_CLASSES if present. Comma separated
    list of JMX, CONSOLE, JSON_FILE, HADOOP2</description>\n  </property>\n  <property>\n
    \   <name>hive.service.metrics.file.location</name>\n    <value>/tmp/report.json</value>\n
    \   <description>For metric class org.apache.hadoop.hive.common.metrics.metrics2.CodahaleMetrics
    JSON_FILE reporter, the location of local JSON metrics file.  This file will get
    overwritten at every interval.</description>\n  </property>\n  <property>\n    <name>hive.service.metrics.file.frequency</name>\n
    \   <value>5000ms</value>\n    <description>\n      Expects a time value with
    unit (d/day, h/hour, m/min, s/sec, ms/msec, us/usec, ns/nsec), which is msec if
    not specified.\n      For metric class org.apache.hadoop.hive.common.metrics.metrics2.JsonFileMetricsReporter,
    the frequency of updating JSON metrics file.\n    </description>\n  </property>\n
    \ <property>\n    <name>hive.service.metrics.hadoop2.frequency</name>\n    <value>30s</value>\n
    \   <description>\n      Expects a time value with unit (d/day, h/hour, m/min,
    s/sec, ms/msec, us/usec, ns/nsec), which is sec if not specified.\n      For metric
    class org.apache.hadoop.hive.common.metrics.metrics2.Metrics2Reporter, the frequency
    of updating the HADOOP2 metrics system.\n    </description>\n  </property>\n  <property>\n
    \   <name>hive.service.metrics.hadoop2.component</name>\n    <value>hive</value>\n
    \   <description>Component name to provide to Hadoop2 Metrics system. Ideally
    'hivemetastore' for the MetaStore  and and 'hiveserver2' for HiveServer2.</description>\n
    \ </property>\n  <property>\n    <name>hive.exec.perf.logger</name>\n    <value>org.apache.hadoop.hive.ql.log.PerfLogger</value>\n
    \   <description>\n      The class responsible for logging client side performance
    metrics. \n      Must be a subclass of org.apache.hadoop.hive.ql.log.PerfLogger\n
    \   </description>\n  </property>\n  <property>\n    <name>hive.start.cleanup.scratchdir</name>\n
    \   <value>false</value>\n    <description>To cleanup the Hive scratchdir when
    starting the Hive Server</description>\n  </property>\n  <property>\n    <name>hive.scratchdir.lock</name>\n
    \   <value>false</value>\n    <description>To hold a lock file in scratchdir to
    prevent to be removed by cleardanglingscratchdir</description>\n  </property>\n
    \ <property>\n    <name>hive.insert.into.multilevel.dirs</name>\n    <value>false</value>\n
    \   <description>\n      Where to insert into multilevel directories like\n      \"insert
    directory '/HIVEFT25686/chinna/' from table\"\n    </description>\n  </property>\n
    \ <property>\n    <name>hive.insert.into.external.tables</name>\n    <value>true</value>\n
    \   <description>whether insert into external tables is allowed</description>\n
    \ </property>\n  <property>\n    <name>hive.exec.temporary.table.storage</name>\n
    \   <value>default</value>\n    <description>\n      Expects one of [memory, ssd,
    default].\n      Define the storage policy for temporary tables.Choices between
    memory, ssd and default\n    </description>\n  </property>\n  <property>\n    <name>hive.query.lifetime.hooks</name>\n
    \   <value/>\n    <description>A comma separated list of hooks which implement
    QueryLifeTimeHook. These will be triggered before/after query compilation and
    before/after query execution, in the order specified.Implementations of QueryLifeTimeHookWithParseHooks
    can also be specified in this list. If they arespecified then they will be invoked
    in the same places as QueryLifeTimeHooks and will be invoked during pre and post
    query parsing</description>\n  </property>\n  <property>\n    <name>hive.exec.driver.run.hooks</name>\n
    \   <value/>\n    <description>A comma separated list of hooks which implement
    HiveDriverRunHook. Will be run at the beginning and end of Driver.run, these will
    be run in the order specified.</description>\n  </property>\n  <property>\n    <name>hive.ddl.output.format</name>\n
    \   <value/>\n    <description>\n      The data format to use for DDL output.
    \ One of \"text\" (for human\n      readable text) or \"json\" (for a json object).\n
    \   </description>\n  </property>\n  <property>\n    <name>hive.entity.separator</name>\n
    \   <value>@</value>\n    <description>Separator used to construct names of tables
    and partitions. For example, dbname@tablename@partitionname</description>\n  </property>\n
    \ <property>\n    <name>hive.entity.capture.transform</name>\n    <value>false</value>\n
    \   <description>Compiler to capture transform URI referred in the query</description>\n
    \ </property>\n  <property>\n    <name>hive.display.partition.cols.separately</name>\n
    \   <value>true</value>\n    <description>\n      In older Hive version (0.10
    and earlier) no distinction was made between\n      partition columns or non-partition
    columns while displaying columns in describe\n      table. From 0.12 onwards,
    they are displayed separately. This flag will let you\n      get old behavior,
    if desired. See, test-case in patch for HIVE-6689.\n    </description>\n  </property>\n
    \ <property>\n    <name>hive.ssl.protocol.blacklist</name>\n    <value>SSLv2,SSLv3</value>\n
    \   <description>SSL Versions to disable for all Hive Servers</description>\n
    \ </property>\n  <property>\n    <name>hive.privilege.synchronizer.interval</name>\n
    \   <value>1800s</value>\n    <description>\n      Expects a time value with unit
    (d/day, h/hour, m/min, s/sec, ms/msec, us/usec, ns/nsec), which is sec if not
    specified.\n      Interval to synchronize privileges from external authorizer
    periodically in HS2\n    </description>\n  </property>\n  <property>\n    <name>hive.server2.clear.dangling.scratchdir</name>\n
    \   <value>false</value>\n    <description>Clear dangling scratch dir periodically
    in HS2</description>\n  </property>\n  <property>\n    <name>hive.server2.clear.dangling.scratchdir.interval</name>\n
    \   <value>1800s</value>\n    <description>\n      Expects a time value with unit
    (d/day, h/hour, m/min, s/sec, ms/msec, us/usec, ns/nsec), which is sec if not
    specified.\n      Interval to clear dangling scratch dir periodically in HS2\n
    \   </description>\n  </property>\n  <property>\n    <name>hive.server2.sleep.interval.between.start.attempts</name>\n
    \   <value>60s</value>\n    <description>\n      Expects a time value with unit
    (d/day, h/hour, m/min, s/sec, ms/msec, us/usec, ns/nsec), which is msec if not
    specified.\n      The time should be in between 0 msec (inclusive) and 9223372036854775807
    msec (inclusive).\n      Amount of time to sleep between HiveServer2 start attempts.
    Primarily meant for tests\n    </description>\n  </property>\n  <property>\n    <name>hive.server2.max.start.attempts</name>\n
    \   <value>30</value>\n    <description>\n      Expects value bigger than 0.\n
    \     Number of times HiveServer2 will attempt to start before exiting. The sleep
    interval between retries is determined by hive.server2.sleep.interval.between.start.attempts\n
    \      The default of 30 will keep trying for 30 minutes.\n    </description>\n
    \ </property>\n  <property>\n    <name>hive.server2.support.dynamic.service.discovery</name>\n
    \   <value>false</value>\n    <description>Whether HiveServer2 supports dynamic
    service discovery for its clients. To support this, each instance of HiveServer2
    currently uses ZooKeeper to register itself, when it is brought up. JDBC/ODBC
    clients should use the ZooKeeper ensemble: hive.zookeeper.quorum in their connection
    string.</description>\n  </property>\n  <property>\n    <name>hive.server2.zookeeper.namespace</name>\n
    \   <value>hiveserver2</value>\n    <description>The parent node in ZooKeeper
    used by HiveServer2 when supporting dynamic service discovery.</description>\n
    \ </property>\n  <property>\n    <name>hive.server2.zookeeper.publish.configs</name>\n
    \   <value>true</value>\n    <description>Whether we should publish HiveServer2's
    configs to ZooKeeper.</description>\n  </property>\n  <property>\n    <name>hive.server2.global.init.file.location</name>\n
    \   <value>${env:HIVE_CONF_DIR}</value>\n    <description>\n      Either the location
    of a HS2 global init file or a directory containing a .hiverc file. If the \n
    \     property is set, the value must be a valid path to an init file or directory
    where the init file is located.\n    </description>\n  </property>\n  <property>\n
    \   <name>hive.server2.transport.mode</name>\n    <value>binary</value>\n    <description>\n
    \     Expects one of [binary, http].\n      Transport mode of HiveServer2.\n    </description>\n
    \ </property>\n  <property>\n    <name>hive.server2.thrift.bind.host</name>\n
    \   <value>fom-hadoop-03.fritz.box</value>\n    <description>Bind host on which
    to run the HiveServer2 Thrift service.</description>\n  </property>\n  <property>\n
    \   <name>hive.driver.parallel.compilation</name>\n    <value>false</value>\n
    \   <description>\n      Whether to\n      enable parallel compilation of the
    queries between sessions and within the same session on HiveServer2. The default
    is false.\n    </description>\n  </property>\n  <property>\n    <name>hive.server2.compile.lock.timeout</name>\n
    \   <value>0s</value>\n    <description>\n      Expects a time value with unit
    (d/day, h/hour, m/min, s/sec, ms/msec, us/usec, ns/nsec), which is sec if not
    specified.\n      Number of seconds a request will wait to acquire the compile
    lock before giving up. Setting it to 0s disables the timeout.\n    </description>\n
    \ </property>\n  <property>\n    <name>hive.server2.parallel.ops.in.session</name>\n
    \   <value>true</value>\n    <description>Whether to allow several parallel operations
    (such as SQL statements) in one session.</description>\n  </property>\n  <property>\n
    \   <name>hive.server2.materializedviews.registry.impl</name>\n    <value>DEFAULT</value>\n
    \   <description>\n      Expects one of [default, dummy].\n      The implementation
    that we should use for the materialized views registry. \n        DEFAULT: Default
    cache for materialized views\n        DUMMY: Do not cache materialized views and
    hence forward requests to metastore\n    </description>\n  </property>\n  <property>\n
    \   <name>hive.server2.webui.host</name>\n    <value>0.0.0.0</value>\n    <description>The
    host address the HiveServer2 WebUI will listen on</description>\n  </property>\n
    \ <property>\n    <name>hive.server2.webui.port</name>\n    <value>10002</value>\n
    \   <description>The port the HiveServer2 WebUI will listen on. This can beset
    to 0 or a negative integer to disable the web UI</description>\n  </property>\n
    \ <property>\n    <name>hive.server2.webui.max.threads</name>\n    <value>50</value>\n
    \   <description>The max HiveServer2 WebUI threads</description>\n  </property>\n
    \ <property>\n    <name>hive.server2.webui.use.ssl</name>\n    <value>false</value>\n
    \   <description>Set this to true for using SSL encryption for HiveServer2 WebUI.</description>\n
    \ </property>\n  <property>\n    <name>hive.server2.webui.keystore.path</name>\n
    \   <value/>\n    <description>SSL certificate keystore location for HiveServer2
    WebUI.</description>\n  </property>\n  <property>\n    <name>hive.server2.webui.keystore.password</name>\n
    \   <value/>\n    <description>SSL certificate keystore password for HiveServer2
    WebUI.</description>\n  </property>\n  <property>\n    <name>hive.server2.webui.use.spnego</name>\n
    \   <value>false</value>\n    <description>If true, the HiveServer2 WebUI will
    be secured with SPNEGO. Clients must authenticate with Kerberos.</description>\n
    \ </property>\n  <property>\n    <name>hive.server2.webui.spnego.keytab</name>\n
    \   <value/>\n    <description>The path to the Kerberos Keytab file containing
    the HiveServer2 WebUI SPNEGO service principal.</description>\n  </property>\n
    \ <property>\n    <name>hive.server2.webui.spnego.principal</name>\n    <value>HTTP/_HOST@EXAMPLE.COM</value>\n
    \   <description>\n      The HiveServer2 WebUI SPNEGO service principal.\n      The
    special string _HOST will be replaced automatically with \n      the value of
    hive.server2.webui.host or the correct host name.\n    </description>\n  </property>\n
    \ <property>\n    <name>hive.server2.webui.max.historic.queries</name>\n    <value>25</value>\n
    \   <description>The maximum number of past queries to show in HiverSever2 WebUI.</description>\n
    \ </property>\n  <property>\n    <name>hive.server2.webui.use.pam</name>\n    <value>false</value>\n
    \   <description>If true, the HiveServer2 WebUI will be secured with PAM.</description>\n
    \ </property>\n  <property>\n    <name>hive.server2.webui.enable.cors</name>\n
    \   <value>false</value>\n    <description>\n      Whether to enable cross origin
    requests (CORS)\n    </description>\n  </property>\n  <property>\n    <name>hive.server2.webui.cors.allowed.origins</name>\n
    \   <value>*</value>\n    <description>\n      Comma separated list of origins
    that are allowed when CORS is enabled.\n    </description>\n  </property>\n  <property>\n
    \   <name>hive.server2.webui.cors.allowed.methods</name>\n    <value>GET,POST,DELETE,HEAD</value>\n
    \   <description>\n      Comma separated list of http methods that are allowed
    when CORS is enabled.\n    </description>\n  </property>\n  <property>\n    <name>hive.server2.webui.cors.allowed.headers</name>\n
    \   <value>X-Requested-With,Content-Type,Accept,Origin</value>\n    <description>\n
    \     Comma separated list of http headers that are allowed when CORS is enabled.\n
    \   </description>\n  </property>\n  <property>\n    <name>hive.server2.active.passive.ha.enable</name>\n
    \   <value>false</value>\n    <description>Whether HiveServer2 Active/Passive
    High Availability be enabled when Hive Interactive sessions are enabled.This will
    also require hive.server2.support.dynamic.service.discovery to be enabled.</description>\n
    \ </property>\n  <property>\n    <name>hive.server2.active.passive.ha.registry.namespace</name>\n
    \   <value>hs2ActivePassiveHA</value>\n    <description>\n      When HiveServer2
    Active/Passive High Availability is enabled, uses this namespace for registering
    HS2\n      instances with zookeeper\n    </description>\n  </property>\n  <property>\n
    \   <name>hive.server2.tez.interactive.queue</name>\n    <value/>\n    <description>\n
    \     A single YARN queues to use for Hive Interactive sessions. When this is
    specified,\n      workload management is enabled and used for these sessions.\n
    \   </description>\n  </property>\n  <property>\n    <name>hive.server2.wm.worker.threads</name>\n
    \   <value>4</value>\n    <description>\n      Number of worker threads to use
    to perform the synchronous operations with Tez\n      sessions for workload management
    (e.g. opening, closing, etc.)\n    </description>\n  </property>\n  <property>\n
    \   <name>hive.server2.wm.allow.any.pool.via.jdbc</name>\n    <value>false</value>\n
    \   <description>\n      Applies when a user specifies a target WM pool in the
    JDBC connection string. If\n      false, the user can only specify a pool he is
    mapped to (e.g. make a choice among\n      multiple group mappings); if true,
    the user can specify any existing pool.\n    </description>\n  </property>\n  <property>\n
    \   <name>hive.server2.wm.pool.metrics</name>\n    <value>true</value>\n    <description>Whether
    per-pool WM metrics should be enabled.</description>\n  </property>\n  <property>\n
    \   <name>hive.server2.tez.wm.am.registry.timeout</name>\n    <value>30s</value>\n
    \   <description>\n      Expects a time value with unit (d/day, h/hour, m/min,
    s/sec, ms/msec, us/usec, ns/nsec), which is sec if not specified.\n      The timeout
    for AM registry registration, after which (on attempting to use the\n      session),
    we kill it and try to get another one.\n    </description>\n  </property>\n  <property>\n
    \   <name>hive.server2.tez.default.queues</name>\n    <value/>\n    <description>\n
    \     A list of comma separated values corresponding to YARN queues of the same
    name.\n      When HiveServer2 is launched in Tez mode, this configuration needs
    to be set\n      for multiple Tez sessions to run in parallel on the cluster.\n
    \   </description>\n  </property>\n  <property>\n    <name>hive.server2.tez.sessions.per.default.queue</name>\n
    \   <value>1</value>\n    <description>\n      A positive integer that determines
    the number of Tez sessions that should be\n      launched on each of the queues
    specified by \"hive.server2.tez.default.queues\".\n      Determines the parallelism
    on each queue.\n    </description>\n  </property>\n  <property>\n    <name>hive.server2.tez.initialize.default.sessions</name>\n
    \   <value>false</value>\n    <description>\n      This flag is used in HiveServer2
    to enable a user to use HiveServer2 without\n      turning on Tez for HiveServer2.
    The user could potentially want to run queries\n      over Tez without the pool
    of sessions.\n    </description>\n  </property>\n  <property>\n    <name>hive.server2.tez.queue.access.check</name>\n
    \   <value>false</value>\n    <description>Whether to check user access to explicitly
    specified YARN queues. yarn.resourcemanager.webapp.address must be configured
    to use this.</description>\n  </property>\n  <property>\n    <name>hive.server2.tez.session.lifetime</name>\n
    \   <value>162h</value>\n    <description>\n      Expects a time value with unit
    (d/day, h/hour, m/min, s/sec, ms/msec, us/usec, ns/nsec), which is hour if not
    specified.\n      The lifetime of the Tez sessions launched by HS2 when default
    sessions are enabled.\n      Set to 0 to disable session expiration.\n    </description>\n
    \ </property>\n  <property>\n    <name>hive.server2.tez.session.lifetime.jitter</name>\n
    \   <value>3h</value>\n    <description>\n      Expects a time value with unit
    (d/day, h/hour, m/min, s/sec, ms/msec, us/usec, ns/nsec), which is hour if not
    specified.\n      The jitter for Tez session lifetime; prevents all the sessions
    from restarting at once.\n    </description>\n  </property>\n  <property>\n    <name>hive.server2.tez.sessions.init.threads</name>\n
    \   <value>16</value>\n    <description>\n      If hive.server2.tez.initialize.default.sessions
    is enabled, the maximum number of\n      threads to use to initialize the default
    sessions.\n    </description>\n  </property>\n  <property>\n    <name>hive.server2.tez.sessions.restricted.configs</name>\n
    \   <value/>\n    <description>\n      The configuration settings that cannot
    be set when submitting jobs to HiveServer2. If\n      any of these are set to
    values different from those in the server configuration, an\n      exception will
    be thrown.\n    </description>\n  </property>\n  <property>\n    <name>hive.server2.tez.sessions.custom.queue.allowed</name>\n
    \   <value>true</value>\n    <description>\n      Expects one of [true, false,
    ignore].\n      Whether Tez session pool should allow submitting queries to custom
    queues. The options\n      are true, false (error out), ignore (accept the query
    but ignore the queue setting).\n    </description>\n  </property>\n  <property>\n
    \   <name>hive.server2.logging.operation.enabled</name>\n    <value>false</value>\n
    \   <description>When true, HS2 will save operation logs and make them available
    for clients</description>\n  </property>\n  <property>\n    <name>hive.server2.logging.operation.level</name>\n\t\t
    \   <!-- <value>EXECUTION</value> -->\n    <value>NONE</value>\n    <description>\n
    \     Expects one of [none, execution, performance, verbose].\n      HS2 operation
    logging mode available to clients to be set at session level.\n      For this
    to work, hive.server2.logging.operation.enabled should be set to true.\n        NONE:
    Ignore any logging\n        EXECUTION: Log completion of tasks\n        PERFORMANCE:
    Execution + Performance logs \n        VERBOSE: All logs\n    </description>\n
    \ </property>\n  <property>\n    <name>hive.server2.operation.log.cleanup.delay</name>\n
    \   <value>300s</value>\n    <description>\n      Expects a time value with unit
    (d/day, h/hour, m/min, s/sec, ms/msec, us/usec, ns/nsec), which is sec if not
    specified.\n      When a query is cancelled (via kill query, query timeout or
    triggers),\n       operation logs gets cleaned up after this delay\n    </description>\n
    \ </property>\n  <property>\n    <name>hive.server2.limit.connections.per.user</name>\n
    \   <value>0</value>\n    <description>Maximum hive server2 connections per user.
    Any user exceeding this limit will not be allowed to connect. Default=0 does not
    enforce limits.</description>\n  </property>\n  <property>\n    <name>hive.server2.limit.connections.per.ipaddress</name>\n
    \   <value>0</value>\n    <description>Maximum hive server2 connections per ipaddress.
    Any ipaddress exceeding this limit will not be allowed to connect. Default=0 does
    not enforce limits.</description>\n  </property>\n  <property>\n    <name>hive.server2.limit.connections.per.user.ipaddress</name>\n
    \   <value>0</value>\n    <description>Maximum hive server2 connections per user:ipaddress
    combination. Any user-ipaddress exceeding this limit will not be allowed to connect.
    Default=0 does not enforce limits.</description>\n  </property>\n  <property>\n
    \   <name>hive.server2.metrics.enabled</name>\n    <value>false</value>\n    <description>Enable
    metrics on the HiveServer2.</description>\n  </property>\n  <property>\n    <name>hive.server2.thrift.http.port</name>\n
    \   <value>10001</value>\n    <description>Port number of HiveServer2 Thrift interface
    when hive.server2.transport.mode is 'http'.</description>\n  </property>\n  <property>\n
    \   <name>hive.server2.thrift.http.path</name>\n    <value>cliservice</value>\n
    \   <description>Path component of URL endpoint when in HTTP mode.</description>\n
    \ </property>\n  <property>\n    <name>hive.server2.thrift.max.message.size</name>\n
    \   <value>104857600</value>\n    <description>Maximum message size in bytes a
    HS2 server will accept.</description>\n  </property>\n  <property>\n    <name>hive.server2.thrift.http.max.idle.time</name>\n
    \   <value>1800s</value>\n    <description>\n      Expects a time value with unit
    (d/day, h/hour, m/min, s/sec, ms/msec, us/usec, ns/nsec), which is msec if not
    specified.\n      Maximum idle time for a connection on the server when in HTTP
    mode.\n    </description>\n  </property>\n  <property>\n    <name>hive.server2.thrift.http.worker.keepalive.time</name>\n
    \   <value>60s</value>\n    <description>\n      Expects a time value with unit
    (d/day, h/hour, m/min, s/sec, ms/msec, us/usec, ns/nsec), which is sec if not
    specified.\n      Keepalive time for an idle http worker thread. When the number
    of workers exceeds min workers, excessive threads are killed after this time interval.\n
    \   </description>\n  </property>\n  <property>\n    <name>hive.server2.thrift.http.request.header.size</name>\n
    \   <value>6144</value>\n    <description>Request header size in bytes, when using
    HTTP transport mode. Jetty defaults used.</description>\n  </property>\n  <property>\n
    \   <name>hive.server2.thrift.http.response.header.size</name>\n    <value>6144</value>\n
    \   <description>Response header size in bytes, when using HTTP transport mode.
    Jetty defaults used.</description>\n  </property>\n  <property>\n    <name>hive.server2.thrift.http.compression.enabled</name>\n
    \   <value>true</value>\n    <description>Enable thrift http compression via Jetty
    compression support</description>\n  </property>\n  <property>\n    <name>hive.server2.thrift.http.cookie.auth.enabled</name>\n
    \   <value>true</value>\n    <description>When true, HiveServer2 in HTTP transport
    mode, will use cookie based authentication mechanism.</description>\n  </property>\n
    \ <property>\n    <name>hive.server2.thrift.http.cookie.max.age</name>\n    <value>86400s</value>\n
    \   <description>\n      Expects a time value with unit (d/day, h/hour, m/min,
    s/sec, ms/msec, us/usec, ns/nsec), which is sec if not specified.\n      Maximum
    age in seconds for server side cookie used by HS2 in HTTP mode.\n    </description>\n
    \ </property>\n  <property>\n    <name>hive.server2.thrift.http.cookie.domain</name>\n
    \   <value/>\n    <description>Domain for the HS2 generated cookies</description>\n
    \ </property>\n  <property>\n    <name>hive.server2.thrift.http.cookie.path</name>\n
    \   <value/>\n    <description>Path for the HS2 generated cookies</description>\n
    \ </property>\n  <property>\n    <name>hive.server2.thrift.http.cookie.is.secure</name>\n
    \   <value>true</value>\n    <description>Deprecated: Secure attribute of the
    HS2 generated cookie (this is automatically enabled for SSL enabled HiveServer2).</description>\n
    \ </property>\n  <property>\n    <name>hive.server2.thrift.http.cookie.is.httponly</name>\n
    \   <value>true</value>\n    <description>HttpOnly attribute of the HS2 generated
    cookie.</description>\n  </property>\n  <property>\n    <name>hive.server2.thrift.port</name>\n
    \   <value>10000</value>\n    <description>Port number of HiveServer2 Thrift interface
    when hive.server2.transport.mode is 'binary'.</description>\n  </property>\n  <property>\n
    \   <name>hive.server2.thrift.sasl.qop</name>\n    <value>auth</value>\n    <description>\n
    \     Expects one of [auth, auth-int, auth-conf].\n      Sasl QOP value; set it
    to one of following values to enable higher levels of\n      protection for HiveServer2
    communication with clients.\n      Setting hadoop.rpc.protection to a higher level
    than HiveServer2 does not\n      make sense in most situations. HiveServer2 ignores
    hadoop.rpc.protection in favor\n      of hive.server2.thrift.sasl.qop.\n        \"auth\"
    - authentication only (default)\n        \"auth-int\" - authentication plus integrity
    protection\n        \"auth-conf\" - authentication plus integrity and confidentiality
    protection\n      This is applicable only if HiveServer2 is configured to use
    Kerberos authentication.\n    </description>\n  </property>\n  <property>\n    <name>hive.server2.thrift.min.worker.threads</name>\n
    \   <value>5</value>\n    <description>Minimum number of Thrift worker threads</description>\n
    \ </property>\n  <property>\n    <name>hive.server2.thrift.max.worker.threads</name>\n
    \   <value>500</value>\n    <description>Maximum number of Thrift worker threads</description>\n
    \ </property>\n  <property>\n    <name>hive.server2.thrift.exponential.backoff.slot.length</name>\n
    \   <value>100ms</value>\n    <description>\n      Expects a time value with unit
    (d/day, h/hour, m/min, s/sec, ms/msec, us/usec, ns/nsec), which is msec if not
    specified.\n      Binary exponential backoff slot time for Thrift clients during
    login to HiveServer2,\n      for retries until hitting Thrift client timeout\n
    \   </description>\n  </property>\n  <property>\n    <name>hive.server2.thrift.login.timeout</name>\n
    \   <value>20s</value>\n    <description>\n      Expects a time value with unit
    (d/day, h/hour, m/min, s/sec, ms/msec, us/usec, ns/nsec), which is sec if not
    specified.\n      Timeout for Thrift clients during login to HiveServer2\n    </description>\n
    \ </property>\n  <property>\n    <name>hive.server2.thrift.worker.keepalive.time</name>\n
    \   <value>60s</value>\n    <description>\n      Expects a time value with unit
    (d/day, h/hour, m/min, s/sec, ms/msec, us/usec, ns/nsec), which is sec if not
    specified.\n      Keepalive time (in seconds) for an idle worker thread. When
    the number of workers exceeds min workers, excessive threads are killed after
    this time interval.\n    </description>\n  </property>\n  <property>\n    <name>hive.server2.async.exec.threads</name>\n
    \   <value>100</value>\n    <description>Number of threads in the async thread
    pool for HiveServer2</description>\n  </property>\n  <property>\n    <name>hive.server2.async.exec.shutdown.timeout</name>\n
    \   <value>10s</value>\n    <description>\n      Expects a time value with unit
    (d/day, h/hour, m/min, s/sec, ms/msec, us/usec, ns/nsec), which is sec if not
    specified.\n      How long HiveServer2 shutdown will wait for async threads to
    terminate.\n    </description>\n  </property>\n  <property>\n    <name>hive.server2.async.exec.wait.queue.size</name>\n
    \   <value>100</value>\n    <description>\n      Size of the wait queue for async
    thread pool in HiveServer2.\n      After hitting this limit, the async thread
    pool will reject new requests.\n    </description>\n  </property>\n  <property>\n
    \   <name>hive.server2.async.exec.keepalive.time</name>\n    <value>10s</value>\n
    \   <description>\n      Expects a time value with unit (d/day, h/hour, m/min,
    s/sec, ms/msec, us/usec, ns/nsec), which is sec if not specified.\n      Time
    that an idle HiveServer2 async thread (from the thread pool) will wait for a new
    task\n      to arrive before terminating\n    </description>\n  </property>\n
    \ <property>\n    <name>hive.server2.async.exec.async.compile</name>\n    <value>false</value>\n
    \   <description>Whether to enable compiling async query asynchronously. If enabled,
    it is unknown if the query will have any resultset before compilation completed.</description>\n
    \ </property>\n  <property>\n    <name>hive.server2.long.polling.timeout</name>\n
    \   <value>5000ms</value>\n    <description>\n      Expects a time value with
    unit (d/day, h/hour, m/min, s/sec, ms/msec, us/usec, ns/nsec), which is msec if
    not specified.\n      Time that HiveServer2 will wait before responding to asynchronous
    calls that use long polling\n    </description>\n  </property>\n  <property>\n
    \   <name>hive.session.impl.classname</name>\n    <value/>\n    <description>Classname
    for custom implementation of hive session</description>\n  </property>\n  <property>\n
    \   <name>hive.session.impl.withugi.classname</name>\n    <value/>\n    <description>Classname
    for custom implementation of hive session with UGI</description>\n  </property>\n
    \ <property>\n    <name>hive.server2.authentication</name>\n    <value>NONE</value>\n
    \   <description>\n      Expects one of [nosasl, none, ldap, kerberos, pam, custom].\n
    \     Client authentication types.\n        NONE: no authentication check\n        LDAP:
    LDAP/AD based authentication\n        KERBEROS: Kerberos/GSSAPI authentication\n
    \       CUSTOM: Custom authentication provider\n                (Use with property
    hive.server2.custom.authentication.class)\n        PAM: Pluggable authentication
    module\n        NOSASL:  Raw transport\n    </description>\n  </property>\n  <property>\n
    \   <name>hive.server2.allow.user.substitution</name>\n    <value>true</value>\n
    \   <description>Allow alternate user to be specified as part of HiveServer2 open
    connection request.</description>\n  </property>\n  <property>\n    <name>hive.server2.authentication.kerberos.keytab</name>\n
    \   <value/>\n    <description>Kerberos keytab file for server principal</description>\n
    \ </property>\n  <property>\n    <name>hive.server2.authentication.kerberos.principal</name>\n
    \   <value/>\n    <description>Kerberos server principal</description>\n  </property>\n
    \ <property>\n    <name>hive.server2.authentication.client.kerberos.principal</name>\n
    \   <value/>\n    <description>Kerberos principal used by the HA hive_server2s.</description>\n
    \ </property>\n  <property>\n    <name>hive.server2.authentication.spnego.keytab</name>\n
    \   <value/>\n    <description>\n      keytab file for SPNego principal, optional,\n
    \     typical value would look like /etc/security/keytabs/spnego.service.keytab,\n
    \     This keytab would be used by HiveServer2 when Kerberos security is enabled
    and \n      HTTP transport mode is used.\n      This needs to be set only if SPNEGO
    is to be used in authentication.\n      SPNego authentication would be honored
    only if valid\n        hive.server2.authentication.spnego.principal\n      and\n
    \       hive.server2.authentication.spnego.keytab\n      are specified.\n    </description>\n
    \ </property>\n  <property>\n    <name>hive.server2.authentication.spnego.principal</name>\n
    \   <value/>\n    <description>\n      SPNego service principal, optional,\n      typical
    value would look like HTTP/_HOST@EXAMPLE.COM\n      SPNego service principal would
    be used by HiveServer2 when Kerberos security is enabled\n      and HTTP transport
    mode is used.\n      This needs to be set only if SPNEGO is to be used in authentication.\n
    \   </description>\n  </property>\n  <property>\n    <name>hive.server2.authentication.ldap.url</name>\n
    \   <value/>\n    <description>\n      LDAP connection URL(s),\n      this value
    could contain URLs to multiple LDAP servers instances for HA,\n      each LDAP
    URL is separated by a SPACE character. URLs are used in the \n       order specified
    until a connection is successful.\n    </description>\n  </property>\n  <property>\n
    \   <name>hive.server2.authentication.ldap.baseDN</name>\n    <value/>\n    <description>LDAP
    base DN</description>\n  </property>\n  <property>\n    <name>hive.server2.authentication.ldap.Domain</name>\n
    \   <value/>\n    <description/>\n  </property>\n  <property>\n    <name>hive.server2.authentication.ldap.groupDNPattern</name>\n
    \   <value/>\n    <description>\n      COLON-separated list of patterns to use
    to find DNs for group entities in this directory.\n      Use %s where the actual
    group name is to be substituted for.\n      For example: CN=%s,CN=Groups,DC=subdomain,DC=domain,DC=com.\n
    \   </description>\n  </property>\n  <property>\n    <name>hive.server2.authentication.ldap.groupFilter</name>\n
    \   <value/>\n    <description>\n      COMMA-separated list of LDAP Group names
    (short name not full DNs).\n      For example: HiveAdmins,HadoopAdmins,Administrators\n
    \   </description>\n  </property>\n  <property>\n    <name>hive.server2.authentication.ldap.userDNPattern</name>\n
    \   <value/>\n    <description>\n      COLON-separated list of patterns to use
    to find DNs for users in this directory.\n      Use %s where the actual group
    name is to be substituted for.\n      For example: CN=%s,CN=Users,DC=subdomain,DC=domain,DC=com.\n
    \   </description>\n  </property>\n  <property>\n    <name>hive.server2.authentication.ldap.userFilter</name>\n
    \   <value/>\n    <description>\n      COMMA-separated list of LDAP usernames
    (just short names, not full DNs).\n      For example: hiveuser,impalauser,hiveadmin,hadoopadmin\n
    \   </description>\n  </property>\n  <property>\n    <name>hive.server2.authentication.ldap.guidKey</name>\n
    \   <value>uid</value>\n    <description>\n      LDAP attribute name whose values
    are unique in this LDAP server.\n      For example: uid or CN.\n    </description>\n
    \ </property>\n  <property>\n    <name>hive.server2.authentication.ldap.groupMembershipKey</name>\n
    \   <value>member</value>\n    <description>\n      LDAP attribute name on the
    group object that contains the list of distinguished names\n      for the user,
    group, and contact objects that are members of the group.\n      For example:
    member, uniqueMember or memberUid\n    </description>\n  </property>\n  <property>\n
    \   <name>hive.server2.authentication.ldap.userMembershipKey</name>\n    <value/>\n
    \   <description>\n      LDAP attribute name on the user object that contains
    groups of which the user is\n      a direct member, except for the primary group,
    which is represented by the\n      primaryGroupId.\n      For example: memberOf\n
    \   </description>\n  </property>\n  <property>\n    <name>hive.server2.authentication.ldap.groupClassKey</name>\n
    \   <value>groupOfNames</value>\n    <description>\n      LDAP attribute name
    on the group entry that is to be used in LDAP group searches.\n      For example:
    group, groupOfNames or groupOfUniqueNames.\n    </description>\n  </property>\n
    \ <property>\n    <name>hive.server2.authentication.ldap.customLDAPQuery</name>\n
    \   <value/>\n    <description>\n      A full LDAP query that LDAP Atn provider
    uses to execute against LDAP Server.\n      If this query returns a null resultset,
    the LDAP Provider fails the Authentication\n      request, succeeds if the user
    is part of the resultset.For example: (&amp;(objectClass=group)(objectClass=top)(instanceType=4)(cn=Domain*))
    \n      (&amp;(objectClass=person)(|(sAMAccountName=admin)(|(memberOf=CN=Domain
    Admins,CN=Users,DC=domain,DC=com)(memberOf=CN=Administrators,CN=Builtin,DC=domain,DC=com))))\n
    \   </description>\n  </property>\n  <property>\n    <name>hive.server2.custom.authentication.class</name>\n
    \   <value/>\n    <description>\n      Custom authentication class. Used when
    property\n      'hive.server2.authentication' is set to 'CUSTOM'. Provided class\n
    \     must be a proper implementation of the interface\n      org.apache.hive.service.auth.PasswdAuthenticationProvider.
    HiveServer2\n      will call its Authenticate(user, passed) method to authenticate
    requests.\n      The implementation may optionally implement Hadoop's\n      org.apache.hadoop.conf.Configurable
    class to grab Hive's Configuration object.\n    </description>\n  </property>\n
    \ <property>\n    <name>hive.server2.authentication.pam.services</name>\n    <value/>\n
    \   <description>\n      List of the underlying pam services that should be used
    when auth type is PAM\n      A file with the same name must exist in /etc/pam.d\n
    \   </description>\n  </property>\n  <property>\n    <name>hive.server2.enable.doAs</name>\n
    \   <value>false</value>\n    <description>\n      Setting this property to true
    will have HiveServer2 execute\n      Hive operations as the user making the calls
    to it.\n    </description>\n  </property>\n  <property>\n    <name>hive.distcp.privileged.doAs</name>\n
    \   <value>hive</value>\n    <description>\n      This property allows privileged
    distcp executions done by hive\n      to run as this user.\n    </description>\n
    \ </property>\n  <property>\n    <name>hive.server2.table.type.mapping</name>\n
    \   <value>CLASSIC</value>\n    <description>\n      Expects one of [classic,
    hive].\n      This setting reflects how HiveServer2 will report the table types
    for JDBC and other\n      client implementations that retrieve the available tables
    and supported table types\n        HIVE : Exposes Hive's native table types like
    MANAGED_TABLE, EXTERNAL_TABLE, VIRTUAL_VIEW\n        CLASSIC : More generic types
    like TABLE and VIEW\n    </description>\n  </property>\n  <property>\n    <name>hive.server2.session.hook</name>\n
    \   <value/>\n    <description/>\n  </property>\n  <property>\n    <name>hive.server2.use.SSL</name>\n
    \   <value>false</value>\n    <description>Set this to true for using SSL encryption
    in HiveServer2.</description>\n  </property>\n  <property>\n    <name>hive.server2.keystore.path</name>\n
    \   <value/>\n    <description>SSL certificate keystore location.</description>\n
    \ </property>\n  <property>\n    <name>hive.server2.keystore.password</name>\n
    \   <value/>\n    <description>SSL certificate keystore password.</description>\n
    \ </property>\n  <property>\n    <name>hive.server2.map.fair.scheduler.queue</name>\n
    \   <value>true</value>\n    <description>\n      If the YARN fair scheduler is
    configured and HiveServer2 is running in non-impersonation mode,\n      this setting
    determines the user for fair scheduler queue mapping.\n      If set to true (default),
    the logged-in user determines the fair scheduler queue\n      for submitted jobs,
    so that map reduce resource usage can be tracked by user.\n      If set to false,
    all Hive jobs go to the 'hive' user's queue.\n    </description>\n  </property>\n
    \ <property>\n    <name>hive.server2.builtin.udf.whitelist</name>\n    <value/>\n
    \   <description>\n      Comma separated list of builtin udf names allowed in
    queries.\n      An empty whitelist allows all builtin udfs to be executed.  The
    udf black list takes precedence over udf white list\n    </description>\n  </property>\n
    \ <property>\n    <name>hive.server2.builtin.udf.blacklist</name>\n    <value/>\n
    \   <description>Comma separated list of udfs names. These udfs will not be allowed
    in queries. The udf black list takes precedence over udf white list</description>\n
    \ </property>\n  <property>\n    <name>hive.allow.udf.load.on.demand</name>\n
    \   <value>false</value>\n    <description>\n      Whether enable loading UDFs
    from metastore on demand; this is mostly relevant for\n      HS2 and was the default
    behavior before Hive 1.2. Off by default.\n    </description>\n  </property>\n
    \ <property>\n    <name>hive.server2.session.check.interval</name>\n    <value>6h</value>\n
    \   <description>\n      Expects a time value with unit (d/day, h/hour, m/min,
    s/sec, ms/msec, us/usec, ns/nsec), which is msec if not specified.\n      The
    time should be bigger than or equal to 3000 msec.\n      The check interval for
    session/operation timeout, which can be disabled by setting to zero or negative
    value.\n    </description>\n  </property>\n  <property>\n    <name>hive.server2.close.session.on.disconnect</name>\n
    \   <value>true</value>\n    <description>Session will be closed when connection
    is closed. Set this to false to have session outlive its parent connection.</description>\n
    \ </property>\n  <property>\n    <name>hive.server2.idle.session.timeout</name>\n
    \   <value>7d</value>\n    <description>\n      Expects a time value with unit
    (d/day, h/hour, m/min, s/sec, ms/msec, us/usec, ns/nsec), which is msec if not
    specified.\n      Session will be closed when it's not accessed for this duration,
    which can be disabled by setting to zero or negative value.\n    </description>\n
    \ </property>\n  <property>\n    <name>hive.server2.idle.operation.timeout</name>\n
    \   <value>5d</value>\n    <description>\n      Expects a time value with unit
    (d/day, h/hour, m/min, s/sec, ms/msec, us/usec, ns/nsec), which is msec if not
    specified.\n      Operation will be closed when it's not accessed for this duration
    of time, which can be disabled by setting to zero value.\n        With positive
    value, it's checked for operations in terminal state only (FINISHED, CANCELED,
    CLOSED, ERROR).\n        With negative value, it's checked for all of the operations
    regardless of state.\n    </description>\n  </property>\n  <property>\n    <name>hive.server2.idle.session.check.operation</name>\n
    \   <value>true</value>\n    <description>\n      Session will be considered to
    be idle only if there is no activity, and there is no pending operation.\n       This
    setting takes effect only if session idle timeout (hive.server2.idle.session.timeout)
    and checking\n      (hive.server2.session.check.interval) are enabled.\n    </description>\n
    \ </property>\n  <property>\n    <name>hive.server2.thrift.client.retry.limit</name>\n
    \   <value>1</value>\n    <description>Number of retries upon failure of Thrift
    HiveServer2 calls</description>\n  </property>\n  <property>\n    <name>hive.server2.thrift.client.connect.retry.limit</name>\n
    \   <value>1</value>\n    <description>Number of retries while opening a connection
    to HiveServe2</description>\n  </property>\n  <property>\n    <name>hive.server2.thrift.client.retry.delay.seconds</name>\n
    \   <value>1s</value>\n    <description>\n      Expects a time value with unit
    (d/day, h/hour, m/min, s/sec, ms/msec, us/usec, ns/nsec), which is sec if not
    specified.\n      Number of seconds for the HiveServer2 thrift client to wait
    between consecutive connection attempts. Also specifies the time to wait between
    retrying thrift calls upon failures\n    </description>\n  </property>\n  <property>\n
    \   <name>hive.server2.thrift.client.user</name>\n    <value>anonymous</value>\n
    \   <description>Username to use against thrift client</description>\n  </property>\n
    \ <property>\n    <name>hive.server2.thrift.client.password</name>\n    <value>anonymous</value>\n
    \   <description>Password to use against thrift client</description>\n  </property>\n
    \ <property>\n    <name>hive.server2.thrift.resultset.serialize.in.tasks</name>\n
    \   <value>false</value>\n    <description>\n      Whether we should serialize
    the Thrift structures used in JDBC ResultSet RPC in task nodes.\n       We use
    SequenceFile and ThriftJDBCBinarySerDe to read and write the final results if
    this is true.\n    </description>\n  </property>\n  <property>\n    <name>hive.server2.thrift.resultset.max.fetch.size</name>\n
    \   <value>10000</value>\n    <description>Max number of rows sent in one Fetch
    RPC call by the server to the client.</description>\n  </property>\n  <property>\n
    \   <name>hive.server2.thrift.resultset.default.fetch.size</name>\n    <value>1000</value>\n
    \   <description>\n      The number of rows sent in one Fetch RPC call by the
    server to the client, if not\n      specified by the client.\n    </description>\n
    \ </property>\n  <property>\n    <name>hive.server2.xsrf.filter.enabled</name>\n
    \   <value>false</value>\n    <description>If enabled, HiveServer2 will block
    any requests made to it over http if an X-XSRF-HEADER header is not present</description>\n
    \ </property>\n  <property>\n    <name>hive.security.command.whitelist</name>\n
    \   <value>set,reset,dfs,add,list,delete,reload,compile,llap</value>\n    <description>Comma
    separated list of non-SQL Hive commands users are authorized to execute</description>\n
    \ </property>\n  <property>\n    <name>hive.server2.job.credential.provider.path</name>\n
    \   <value/>\n    <description>If set, this configuration property should provide
    a comma-separated list of URLs that indicates the type and location of providers
    to be used by hadoop credential provider API. It provides HiveServer2 the ability
    to provide job-specific credential providers for jobs run using MR and Spark execution
    engines. This functionality has not been tested against Tez.</description>\n  </property>\n
    \ <property>\n    <name>hive.mv.files.thread</name>\n    <value>15</value>\n    <description>\n
    \     Expects a byte size value with unit (blank for bytes, kb, mb, gb, tb, pb).\n
    \     The size should be in between 0Pb (inclusive) and 1Kb (inclusive).\n      Number
    of threads used to move files in move task. Set it to 0 to disable multi-threaded
    file moves. This parameter is also used by MSCK to check tables.\n    </description>\n
    \ </property>\n  <property>\n    <name>hive.load.dynamic.partitions.thread</name>\n
    \   <value>15</value>\n    <description>\n      Expects a byte size value with
    unit (blank for bytes, kb, mb, gb, tb, pb).\n      The size should be in between
    1 bytes (inclusive) and 1Kb (inclusive).\n      Number of threads used to load
    dynamic partitions.\n    </description>\n  </property>\n  <property>\n    <name>hive.multi.insert.move.tasks.share.dependencies</name>\n
    \   <value>false</value>\n    <description>\n      If this is set all move tasks
    for tables/partitions (not directories) at the end of a\n      multi-insert query
    will only begin once the dependencies for all these move tasks have been\n      met.\n
    \     Advantages: If concurrency is enabled, the locks will only be released once
    the query has\n                  finished, so with this config enabled, the time
    when the table/partition is\n                  generated will be much closer to
    when the lock on it is released.\n      Disadvantages: If concurrency is not enabled,
    with this disabled, the tables/partitions which\n                     are produced
    by this query and finish earlier will be available for querying\n                     much
    earlier.  Since the locks are only released once the query finishes, this\n                     does
    not apply if concurrency is enabled.\n    </description>\n  </property>\n  <property>\n
    \   <name>hive.exec.infer.bucket.sort</name>\n    <value>false</value>\n    <description>\n
    \     If this is set, when writing partitions, the metadata will include the bucketing/sorting\n
    \     properties with which the data was written if any (this will not overwrite
    the metadata\n      inherited from the table if the table is bucketed/sorted)\n
    \   </description>\n  </property>\n  <property>\n    <name>hive.exec.infer.bucket.sort.num.buckets.power.two</name>\n
    \   <value>false</value>\n    <description>\n      If this is set, when setting
    the number of reducers for the map reduce task which writes the\n      final output
    files, it will choose a number which is a power of two, unless the user specifies\n
    \     the number of reducers to use using mapred.reduce.tasks.  The number of
    reducers\n      may be set to a power of two, only to be followed by a merge task
    meaning preventing\n      anything from being inferred.\n      With hive.exec.infer.bucket.sort
    set to true:\n      Advantages:  If this is not set, the number of buckets for
    partitions will seem arbitrary,\n                   which means that the number
    of mappers used for optimized joins, for example, will\n                   be
    very low.  With this set, since the number of buckets used for any partition is\n
    \                  a power of two, the number of mappers used for optimized joins
    will be the least\n                   number of buckets used by any partition
    being joined.\n      Disadvantages: This may mean a much larger or much smaller
    number of reducers being used in the\n                     final map reduce job,
    e.g. if a job was originally going to take 257 reducers,\n                     it
    will now take 512 reducers, similarly if the max number of reducers is 511,\n
    \                    and a job was going to use this many, it will now use 256
    reducers.\n    </description>\n  </property>\n  <property>\n    <name>hive.optimize.listbucketing</name>\n
    \   <value>false</value>\n    <description>Enable list bucketing optimizer. Default
    value is false so that we disable it by default.</description>\n  </property>\n
    \ <property>\n    <name>hive.server.read.socket.timeout</name>\n    <value>10s</value>\n
    \   <description>\n      Expects a time value with unit (d/day, h/hour, m/min,
    s/sec, ms/msec, us/usec, ns/nsec), which is sec if not specified.\n      Timeout
    for the HiveServer to close the connection if no response from the client. By
    default, 10 seconds.\n    </description>\n  </property>\n  <property>\n    <name>hive.server.tcp.keepalive</name>\n
    \   <value>true</value>\n    <description>Whether to enable TCP keepalive for
    the Hive Server. Keepalive will prevent accumulation of half-open connections.</description>\n
    \ </property>\n  <property>\n    <name>hive.decode.partition.name</name>\n    <value>false</value>\n
    \   <description>Whether to show the unquoted partition names in query results.</description>\n
    \ </property>\n  <property>\n    <name>hive.execution.engine</name>\n    <value>tez</value>\n
    \   <description>\n      Expects one of [mr, tez, spark].\n      Chooses execution
    engine. Options are: mr (Map reduce, default), tez, spark. While MR\n      remains
    the default engine for historical reasons, it is itself a historical engine\n
    \     and is deprecated in Hive 2 line. It may be removed without further warning.\n
    \   </description>\n  </property>\n  <property>\n    <name>hive.execution.mode</name>\n
    \   <value>container</value>\n    <description>\n      Expects one of [container,
    llap].\n      Chooses whether query fragments will run in container or in llap\n
    \   </description>\n  </property>\n  <property>\n    <name>hive.jar.directory</name>\n
    \   <value>/opt/apache-hive-3.1.0-bin/lib/</value>\n    <description>\n      This
    is the location hive in tez mode will look for to find a site wide \n      installed
    hive instance.\n    </description>\n  </property>\n  <property>\n    <name>hive.user.install.directory</name>\n
    \   <value>/user/</value>\n    <description>\n      If hive (in tez mode only)
    cannot find a usable hive jar in \"hive.jar.directory\", \n      it will upload
    the hive jar to \"hive.user.install.directory/user.name\"\n      and use it to
    run queries.\n    </description>\n  </property>\n  <property>\n    <name>hive.vectorized.execution.enabled</name>\n
    \   <value>true</value>\n    <description>\n      This flag should be set to true
    to enable vectorized mode of query execution.\n      The default value is true
    to reflect that our most expected Hive deployment will be using vectorization.\n
    \   </description>\n  </property>\n  <property>\n    <name>hive.vectorized.execution.reduce.enabled</name>\n
    \   <value>true</value>\n    <description>\n      This flag should be set to true
    to enable vectorized mode of the reduce-side of query execution.\n      The default
    value is true.\n    </description>\n  </property>\n  <property>\n    <name>hive.vectorized.execution.reduce.groupby.enabled</name>\n
    \   <value>true</value>\n    <description>\n      This flag should be set to true
    to enable vectorized mode of the reduce-side GROUP BY query execution.\n      The
    default value is true.\n    </description>\n  </property>\n  <property>\n    <name>hive.vectorized.execution.mapjoin.native.enabled</name>\n
    \   <value>true</value>\n    <description>\n      This flag should be set to true
    to enable native (i.e. non-pass through) vectorization\n      of queries using
    MapJoin.\n      The default value is true.\n    </description>\n  </property>\n
    \ <property>\n    <name>hive.vectorized.execution.mapjoin.native.multikey.only.enabled</name>\n
    \   <value>false</value>\n    <description>\n      This flag should be set to
    true to restrict use of native vector map join hash tables to\n      the MultiKey
    in queries using MapJoin.\n      The default value is false.\n    </description>\n
    \ </property>\n  <property>\n    <name>hive.vectorized.execution.mapjoin.minmax.enabled</name>\n
    \   <value>false</value>\n    <description>\n      This flag should be set to
    true to enable vector map join hash tables to\n      use max / max filtering for
    integer join queries using MapJoin.\n      The default value is false.\n    </description>\n
    \ </property>\n  <property>\n    <name>hive.vectorized.execution.mapjoin.overflow.repeated.threshold</name>\n
    \   <value>-1</value>\n    <description>\n      The number of small table rows
    for a match in vector map join hash tables\n      where we use the repeated field
    optimization in overflow vectorized row batch for join queries using MapJoin.\n
    \     A value of -1 means do use the join result optimization.  Otherwise, threshold
    value can be 0 to maximum integer.\n    </description>\n  </property>\n  <property>\n
    \   <name>hive.vectorized.execution.mapjoin.native.fast.hashtable.enabled</name>\n
    \   <value>false</value>\n    <description>\n      This flag should be set to
    true to enable use of native fast vector map join hash tables in\n      queries
    using MapJoin.\n      The default value is false.\n    </description>\n  </property>\n
    \ <property>\n    <name>hive.vectorized.groupby.checkinterval</name>\n    <value>100000</value>\n
    \   <description>Number of entries added to the group by aggregation hash before
    a recomputation of average entry size is performed.</description>\n  </property>\n
    \ <property>\n    <name>hive.vectorized.groupby.maxentries</name>\n    <value>1000000</value>\n
    \   <description>\n      Max number of entries in the vector group by aggregation
    hashtables. \n      Exceeding this will trigger a flush irrelevant of memory pressure
    condition.\n    </description>\n  </property>\n  <property>\n    <name>hive.vectorized.groupby.flush.percent</name>\n
    \   <value>0.1</value>\n    <description>Percent of entries in the group by aggregation
    hash flushed when the memory threshold is exceeded.</description>\n  </property>\n
    \ <property>\n    <name>hive.vectorized.execution.reducesink.new.enabled</name>\n
    \   <value>true</value>\n    <description>\n      This flag should be set to true
    to enable the new vectorization\n      of queries using ReduceSink.\n      iThe
    default value is true.\n    </description>\n  </property>\n  <property>\n    <name>hive.vectorized.use.vectorized.input.format</name>\n
    \   <value>true</value>\n    <description>\n      This flag should be set to true
    to enable vectorizing with vectorized input file format capable SerDe.\n      The
    default value is true.\n    </description>\n  </property>\n  <property>\n    <name>hive.vectorized.input.format.excludes</name>\n
    \   <value/>\n    <description>\n      This configuration should be set to fully
    described input format class names for which \n       vectorized input format
    should not be used for vectorized execution.\n    </description>\n  </property>\n
    \ <property>\n    <name>hive.vectorized.use.vector.serde.deserialize</name>\n
    \   <value>true</value>\n    <description>\n      This flag should be set to true
    to enable vectorizing rows using vector deserialize.\n      The default value
    is true.\n    </description>\n  </property>\n  <property>\n    <name>hive.vectorized.use.row.serde.deserialize</name>\n
    \   <value>true</value>\n    <description>\n      This flag should be set to true
    to enable vectorizing using row deserialize.\n      The default value is false.\n
    \   </description>\n  </property>\n  <property>\n    <name>hive.vectorized.row.serde.inputformat.excludes</name>\n
    \   <value>org.apache.parquet.hadoop.ParquetInputFormat,org.apache.hadoop.hive.ql.io.parquet.MapredParquetInputFormat</value>\n
    \   <description>The input formats not supported by row deserialize vectorization.</description>\n
    \ </property>\n  <property>\n    <name>hive.vectorized.adaptor.usage.mode</name>\n
    \   <value>all</value>\n    <description>\n      Expects one of [none, chosen,
    all].\n      Specifies the extent to which the VectorUDFAdaptor will be used for
    UDFs that do not have a corresponding vectorized class.\n      0. none   : disable
    any usage of VectorUDFAdaptor\n      1. chosen : use VectorUDFAdaptor for a small
    set of UDFs that were chosen for good performance\n      2. all    : use VectorUDFAdaptor
    for all UDFs\n    </description>\n  </property>\n  <property>\n    <name>hive.vectorized.execution.ptf.enabled</name>\n
    \   <value>true</value>\n    <description>\n      This flag should be set to true
    to enable vectorized mode of the PTF of query execution.\n      The default value
    is true.\n    </description>\n  </property>\n  <property>\n    <name>hive.vectorized.ptf.max.memory.buffering.batch.count</name>\n
    \   <value>25</value>\n    <description>\n      Maximum number of vectorized row
    batches to buffer in memory for PTF\n      The default value is 25\n    </description>\n
    \ </property>\n  <property>\n    <name>hive.vectorized.complex.types.enabled</name>\n
    \   <value>true</value>\n    <description>\n      This flag should be set to true
    to enable vectorization\n      of expressions with complex types.\n      The default
    value is true.\n    </description>\n  </property>\n  <property>\n    <name>hive.vectorized.groupby.complex.types.enabled</name>\n
    \   <value>true</value>\n    <description>\n      This flag should be set to true
    to enable group by vectorization\n      of aggregations that use complex types.\n
    \   </description>\n  </property>\n  <property>\n    <name>hive.vectorized.row.identifier.enabled</name>\n
    \   <value>true</value>\n    <description>This flag should be set to true to enable
    vectorization of ROW__ID.</description>\n  </property>\n  <property>\n    <name>hive.vectorized.use.checked.expressions</name>\n
    \   <value>false</value>\n    <description>\n      This flag should be set to
    true to use overflow checked vector expressions when available.\n      For example,
    arithmetic expressions which can overflow the output data type can be evaluated
    using\n       checked vector expressions so that they produce same result as non-vectorized
    evaluation.\n    </description>\n  </property>\n  <property>\n    <name>hive.vectorized.adaptor.suppress.evaluate.exceptions</name>\n
    \   <value>false</value>\n    <description>\n      This flag should be set to
    true to suppress HiveException from the generic UDF function\n      evaluate call
    and turn them into NULLs. Assume, by default, this is not needed\n    </description>\n
    \ </property>\n  <property>\n    <name>hive.vectorized.input.format.supports.enabled</name>\n
    \   <value>decimal_64</value>\n    <description>\n      Which vectorized input
    format support features are enabled for vectorization.\n      That is, if a VectorizedInputFormat
    input format does support \"decimal_64\" for example\n      this variable must
    enable that to be used in vectorization\n    </description>\n  </property>\n  <property>\n
    \   <name>hive.vectorized.if.expr.mode</name>\n    <value>better</value>\n    <description>\n
    \     Expects one of [adaptor, good, better].\n      Specifies the extent to which
    SQL IF statements will be vectorized.\n      0. adaptor: only use the VectorUDFAdaptor
    to vectorize IF statements\n      1. good   : use regular vectorized IF expression
    classes that get good performance\n      2. better : use vectorized IF expression
    classes that conditionally execute THEN/ELSE\n                  expressions for
    better performance.\n    </description>\n  </property>\n  <property>\n    <name>hive.typecheck.on.insert</name>\n
    \   <value>true</value>\n    <description>This property has been extended to control
    whether to check, convert, and normalize partition value to conform to its column
    type in partition operations including but not limited to insert, such as alter,
    describe etc.</description>\n  </property>\n  <property>\n    <name>hive.hadoop.classpath</name>\n
    \   <value/>\n    <description>\n      For Windows OS, we need to pass HIVE_HADOOP_CLASSPATH
    Java parameter while starting HiveServer2 \n      using \"-hiveconf hive.hadoop.classpath=%HIVE_LIB%\".\n
    \   </description>\n  </property>\n  <property>\n    <name>hive.rpc.query.plan</name>\n
    \   <value>false</value>\n    <description>Whether to send the query plan via
    local resource or RPC</description>\n  </property>\n  <property>\n    <name>hive.compute.splits.in.am</name>\n
    \   <value>true</value>\n    <description>Whether to generate the splits locally
    or in the AM (tez only)</description>\n  </property>\n  <property>\n    <name>hive.tez.input.generate.consistent.splits</name>\n
    \   <value>true</value>\n    <description>Whether to generate consistent split
    locations when generating splits in the AM</description>\n  </property>\n  <property>\n
    \   <name>hive.prewarm.enabled</name>\n    <value>false</value>\n    <description>Enables
    container prewarm for Tez/Spark (Hadoop 2 only)</description>\n  </property>\n
    \ <property>\n    <name>hive.prewarm.numcontainers</name>\n    <value>10</value>\n
    \   <description>Controls the number of containers to prewarm for Tez/Spark (Hadoop
    2 only)</description>\n  </property>\n  <property>\n    <name>hive.prewarm.spark.timeout</name>\n
    \   <value>5000ms</value>\n    <description>\n      Expects a time value with
    unit (d/day, h/hour, m/min, s/sec, ms/msec, us/usec, ns/nsec), which is msec if
    not specified.\n      Time to wait to finish prewarming spark executors\n    </description>\n
    \ </property>\n  <property>\n    <name>hive.stageid.rearrange</name>\n    <value>none</value>\n
    \   <description>\n      Expects one of [none, idonly, traverse, execution].\n
    \   </description>\n  </property>\n  <property>\n    <name>hive.explain.dependency.append.tasktype</name>\n
    \   <value>false</value>\n    <description/>\n  </property>\n  <property>\n    <name>hive.counters.group.name</name>\n
    \   <value>HIVE</value>\n    <description>The name of counter group for internal
    Hive variables (CREATED_FILE, FATAL_ERROR, etc.)</description>\n  </property>\n
    \ <property>\n    <name>hive.support.quoted.identifiers</name>\n    <value>column</value>\n
    \   <description>\n      Expects one of [none, column].\n      Whether to use
    quoted identifier. 'none' or 'column' can be used. \n        none: default(past)
    behavior. Implies only alphaNumeric and underscore are valid characters in identifiers.\n
    \       column: implies column names can contain any character.\n    </description>\n
    \ </property>\n  <property>\n    <name>hive.support.special.characters.tablename</name>\n
    \   <value>true</value>\n    <description>\n      This flag should be set to true
    to enable support for special characters in table names.\n      When it is set
    to false, only [a-zA-Z_0-9]+ are supported.\n      The only supported special
    character right now is '/'. This flag applies only to quoted table names.\n      The
    default value is true.\n    </description>\n  </property>\n  <property>\n    <name>hive.create.as.insert.only</name>\n
    \   <value>false</value>\n    <description>\n      Whether the eligible tables
    should be created as ACID insert-only by default. Does \n      not apply to external
    tables, the ones using storage handlers, etc.\n    </description>\n  </property>\n
    \ <property>\n    <name>hive.users.in.admin.role</name>\n    <value/>\n    <description>\n
    \     Comma separated list of users who are in admin role for bootstrapping.\n
    \     More users can be added in ADMIN role later.\n    </description>\n  </property>\n
    \ <property>\n    <name>hive.compat</name>\n    <value>0.12</value>\n    <description>\n
    \     Enable (configurable) deprecated behaviors by setting desired level of backward
    compatibility.\n      Setting to 0.12:\n        Maintains division behavior: int
    / int = double\n    </description>\n  </property>\n  <property>\n    <name>hive.convert.join.bucket.mapjoin.tez</name>\n
    \   <value>true</value>\n    <description>\n      Whether joins can be automatically
    converted to bucket map joins in hive \n      when tez is used as the execution
    engine.\n    </description>\n  </property>\n  <property>\n    <name>hive.tez.bmj.use.subcache</name>\n
    \   <value>true</value>\n    <description>Use subcache to reuse hashtable across
    multiple tasks</description>\n  </property>\n  <property>\n    <name>hive.exec.check.crossproducts</name>\n
    \   <value>true</value>\n    <description>Check if a plan contains a Cross Product.
    If there is one, output a warning to the Session's console.</description>\n  </property>\n
    \ <property>\n    <name>hive.localize.resource.wait.interval</name>\n    <value>5000ms</value>\n
    \   <description>\n      Expects a time value with unit (d/day, h/hour, m/min,
    s/sec, ms/msec, us/usec, ns/nsec), which is msec if not specified.\n      Time
    to wait for another thread to localize the same resource for hive-tez.\n    </description>\n
    \ </property>\n  <property>\n    <name>hive.localize.resource.num.wait.attempts</name>\n
    \   <value>5</value>\n    <description>The number of attempts waiting for localizing
    a resource in hive-tez.</description>\n  </property>\n  <property>\n    <name>hive.tez.auto.reducer.parallelism</name>\n
    \   <value>false</value>\n    <description>\n      Turn on Tez' auto reducer parallelism
    feature. When enabled, Hive will still estimate data sizes\n      and set parallelism
    estimates. Tez will sample source vertices' output sizes and adjust the estimates
    at runtime as\n      necessary.\n    </description>\n  </property>\n  <property>\n
    \   <name>hive.tez.llap.min.reducer.per.executor</name>\n    <value>0.95</value>\n
    \   <description>\n      If above 0, the min number of reducers for auto-parallelism
    for LLAP scheduling will\n      be set to this fraction of the number of executors.\n
    \   </description>\n  </property>\n  <property>\n    <name>hive.tez.max.partition.factor</name>\n
    \   <value>2.0</value>\n    <description>When auto reducer parallelism is enabled
    this factor will be used to over-partition data in shuffle edges.</description>\n
    \ </property>\n  <property>\n    <name>hive.tez.min.partition.factor</name>\n
    \   <value>0.25</value>\n    <description>\n      When auto reducer parallelism
    is enabled this factor will be used to put a lower limit to the number\n      of
    reducers that tez specifies.\n    </description>\n  </property>\n  <property>\n
    \   <name>hive.tez.bucket.pruning</name>\n    <value>false</value>\n    <description>\n
    \     When pruning is enabled, filters on bucket columns will be processed by
    \n      filtering the splits against a bitset of included buckets. This needs
    predicates \n      produced by hive.optimize.ppd and hive.optimize.index.filters.\n
    \   </description>\n  </property>\n  <property>\n    <name>hive.tez.bucket.pruning.compat</name>\n
    \   <value>true</value>\n    <description>\n      When pruning is enabled, handle
    possibly broken inserts due to negative hashcodes.\n      This occasionally doubles
    the data scan cost, but is default enabled for safety\n    </description>\n  </property>\n
    \ <property>\n    <name>hive.tez.dynamic.partition.pruning</name>\n    <value>true</value>\n
    \   <description>\n      When dynamic pruning is enabled, joins on partition keys
    will be processed by sending\n      events from the processing vertices to the
    Tez application master. These events will be\n      used to prune unnecessary
    partitions.\n    </description>\n  </property>\n  <property>\n    <name>hive.tez.dynamic.partition.pruning.max.event.size</name>\n
    \   <value>1048576</value>\n    <description>Maximum size of events sent by processors
    in dynamic pruning. If this size is crossed no pruning will take place.</description>\n
    \ </property>\n  <property>\n    <name>hive.tez.dynamic.partition.pruning.max.data.size</name>\n
    \   <value>104857600</value>\n    <description>Maximum total data size of events
    in dynamic pruning.</description>\n  </property>\n  <property>\n    <name>hive.tez.dynamic.semijoin.reduction</name>\n
    \   <value>true</value>\n    <description>When dynamic semijoin is enabled, shuffle
    joins will perform a leaky semijoin before shuffle. This requires hive.tez.dynamic.partition.pruning
    to be enabled.</description>\n  </property>\n  <property>\n    <name>hive.tez.min.bloom.filter.entries</name>\n
    \   <value>1000000</value>\n    <description>Bloom filter should be of at min
    certain size to be effective</description>\n  </property>\n  <property>\n    <name>hive.tez.max.bloom.filter.entries</name>\n
    \   <value>100000000</value>\n    <description>Bloom filter should be of at max
    certain size to be effective</description>\n  </property>\n  <property>\n    <name>hive.tez.bloom.filter.factor</name>\n
    \   <value>1.0</value>\n    <description>Bloom filter should be a multiple of
    this factor with nDV</description>\n  </property>\n  <property>\n    <name>hive.tez.bigtable.minsize.semijoin.reduction</name>\n
    \   <value>100000000</value>\n    <description>Big table for runtime filteting
    should be of atleast this size</description>\n  </property>\n  <property>\n    <name>hive.tez.dynamic.semijoin.reduction.threshold</name>\n
    \   <value>0.5</value>\n    <description>Only perform semijoin optimization if
    the estimated benefit at or above this fraction of the target table</description>\n
    \ </property>\n  <property>\n    <name>hive.tez.dynamic.semijoin.reduction.for.mapjoin</name>\n
    \   <value>false</value>\n    <description>Use a semi-join branch for map-joins.
    This may not make it faster, but is helpful in certain join patterns.</description>\n
    \ </property>\n  <property>\n    <name>hive.tez.dynamic.semijoin.reduction.for.dpp.factor</name>\n
    \   <value>1.0</value>\n    <description>\n      The factor to decide if semijoin
    branch feeds into a TableScan\n      which has an outgoing Dynamic Partition Pruning
    (DPP) branch based on number of distinct values.\n    </description>\n  </property>\n
    \ <property>\n    <name>hive.tez.smb.number.waves</name>\n    <value>0.5</value>\n
    \   <description>The number of waves in which to run the SMB join. Account for
    cluster being occupied. Ideally should be 1 wave.</description>\n  </property>\n
    \ <property>\n    <name>hive.tez.exec.print.summary</name>\n    <value>false</value>\n
    \   <description>Display breakdown of execution steps, for every query executed
    by the shell.</description>\n  </property>\n  <property>\n    <name>hive.tez.session.events.print.summary</name>\n
    \   <value>none</value>\n    <description>\n      Expects one of [none, text,
    json].\n      Display summary of all tez sessions related events in text or json
    format\n    </description>\n  </property>\n  <property>\n    <name>hive.tez.exec.inplace.progress</name>\n
    \   <value>true</value>\n    <description>Updates tez job execution progress in-place
    in the terminal when hive-cli is used.</description>\n  </property>\n  <property>\n
    \   <name>hive.server2.in.place.progress</name>\n    <value>true</value>\n    <description>Allows
    hive server 2 to send progress bar update information. This is currently available
    only if the execution engine is tez.</description>\n  </property>\n  <property>\n
    \   <name>hive.tez.dag.status.check.interval</name>\n    <value>500ms</value>\n
    \   <description>\n      Expects a time value with unit (d/day, h/hour, m/min,
    s/sec, ms/msec, us/usec, ns/nsec), which is msec if not specified.\n      Interval
    between subsequent DAG status invocation.\n    </description>\n  </property>\n
    \ <property>\n    <name>hive.spark.exec.inplace.progress</name>\n    <value>true</value>\n
    \   <description>Updates spark job execution progress in-place in the terminal.</description>\n
    \ </property>\n  <property>\n    <name>hive.tez.container.max.java.heap.fraction</name>\n
    \   <value>0.8</value>\n    <description>This is to override the tez setting with
    the same name</description>\n  </property>\n  <property>\n    <name>hive.tez.task.scale.memory.reserve-fraction.min</name>\n
    \   <value>0.3</value>\n    <description>This is to override the tez setting tez.task.scale.memory.reserve-fraction</description>\n
    \ </property>\n  <property>\n    <name>hive.tez.task.scale.memory.reserve.fraction.max</name>\n
    \   <value>0.5</value>\n    <description>The maximum fraction of JVM memory which
    Tez will reserve for the processor</description>\n  </property>\n  <property>\n
    \   <name>hive.tez.task.scale.memory.reserve.fraction</name>\n    <value>-1.0</value>\n
    \   <description>The customized fraction of JVM memory which Tez will reserve
    for the processor</description>\n  </property>\n  <property>\n    <name>hive.tez.cartesian-product.enabled</name>\n
    \   <value>false</value>\n    <description>Use Tez cartesian product edge to speed
    up cross product</description>\n  </property>\n  <property>\n    <name>hive.llap.io.enabled</name>\n
    \   <value/>\n    <description>Whether the LLAP IO layer is enabled.</description>\n
    \ </property>\n  <property>\n    <name>hive.llap.io.row.wrapper.enabled</name>\n
    \   <value>true</value>\n    <description>Whether the LLAP IO row wrapper is enabled
    for non-vectorized queries.</description>\n  </property>\n  <property>\n    <name>hive.llap.io.acid</name>\n
    \   <value>true</value>\n    <description>Whether the LLAP IO layer is enabled
    for ACID.</description>\n  </property>\n  <property>\n    <name>hive.llap.io.trace.size</name>\n
    \   <value>2Mb</value>\n    <description>\n      Expects a byte size value with
    unit (blank for bytes, kb, mb, gb, tb, pb).\n      The size should be in between
    0Pb (inclusive) and 2147483647 bytes (exclusive).\n      The buffer size for a
    per-fragment LLAP debug trace. 0 to disable.\n    </description>\n  </property>\n
    \ <property>\n    <name>hive.llap.io.trace.always.dump</name>\n    <value>false</value>\n
    \   <description>Whether to always dump the LLAP IO trace (if enabled); the default
    is on error.</description>\n  </property>\n  <property>\n    <name>hive.llap.io.nonvector.wrapper.enabled</name>\n
    \   <value>true</value>\n    <description>\n      Whether the LLAP IO layer is
    enabled for non-vectorized queries that read inputs\n      that can be vectorized\n
    \   </description>\n  </property>\n  <property>\n    <name>hive.llap.io.memory.mode</name>\n
    \   <value>cache</value>\n    <description>\n      Expects one of [cache, none].\n
    \     LLAP IO memory usage; 'cache' (the default) uses data and metadata cache
    with a\n      custom off-heap allocator, 'none' doesn't use either (this mode
    may result in\n      significant performance degradation)\n    </description>\n
    \ </property>\n  <property>\n    <name>hive.llap.io.allocator.alloc.min</name>\n
    \   <value>4Kb</value>\n    <description>\n      Expects a byte size value with
    unit (blank for bytes, kb, mb, gb, tb, pb).\n      Minimum allocation possible
    from LLAP buddy allocator. Allocations below that are\n      padded to minimum
    allocation. For ORC, should generally be the same as the expected\n      compression
    buffer size, or next lowest power of 2. Must be a power of 2.\n    </description>\n
    \ </property>\n  <property>\n    <name>hive.llap.io.allocator.alloc.max</name>\n
    \   <value>16Mb</value>\n    <description>\n      Expects a byte size value with
    unit (blank for bytes, kb, mb, gb, tb, pb).\n      Maximum allocation possible
    from LLAP buddy allocator. For ORC, should be as large as\n      the largest expected
    ORC compression buffer size. Must be a power of 2.\n    </description>\n  </property>\n
    \ <property>\n    <name>hive.llap.io.allocator.arena.count</name>\n    <value>8</value>\n
    \   <description>\n      Arena count for LLAP low-level cache; cache will be allocated
    in the steps of\n      (size/arena_count) bytes. This size must be &lt;= 1Gb and
    &gt;= max allocation; if it is\n      not the case, an adjusted size will be used.
    Using powers of 2 is recommended.\n    </description>\n  </property>\n  <property>\n
    \   <name>hive.llap.io.memory.size</name>\n    <value>1Gb</value>\n    <description>\n
    \     Expects a byte size value with unit (blank for bytes, kb, mb, gb, tb, pb).\n
    \     Maximum size for IO allocator or ORC low-level cache.\n    </description>\n
    \ </property>\n  <property>\n    <name>hive.llap.io.allocator.direct</name>\n
    \   <value>true</value>\n    <description>Whether ORC low-level cache should use
    direct allocation.</description>\n  </property>\n  <property>\n    <name>hive.llap.io.allocator.mmap</name>\n
    \   <value>false</value>\n    <description>\n      Whether ORC low-level cache
    should use memory mapped allocation (direct I/O). \n      This is recommended
    to be used along-side NVDIMM (DAX) or NVMe flash storage.\n    </description>\n
    \ </property>\n  <property>\n    <name>hive.llap.io.allocator.mmap.path</name>\n
    \   <value>/tmp</value>\n    <description>\n      Expects a writable directory
    on the local filesystem.\n      The directory location for mapping NVDIMM/NVMe
    flash storage into the ORC low-level cache.\n    </description>\n  </property>\n
    \ <property>\n    <name>hive.llap.io.allocator.discard.method</name>\n    <value>both</value>\n
    \   <description>\n      Expects one of [freelist, brute, both].\n      Which
    method to use to force-evict blocks to deal with fragmentation:\n      freelist
    - use half-size free list (discards less, but also less reliable); brute -\n      brute
    force, discard whatever we can; both - first try free list, then brute force.\n
    \   </description>\n  </property>\n  <property>\n    <name>hive.llap.io.allocator.defrag.headroom</name>\n
    \   <value>1Mb</value>\n    <description>\n      How much of a headroom to leave
    to allow allocator more flexibility to defragment.\n      The allocator would
    further cap it to a fraction of total memory.\n    </description>\n  </property>\n
    \ <property>\n    <name>hive.llap.io.track.cache.usage</name>\n    <value>true</value>\n
    \   <description>\n      Whether to tag LLAP cache contents, mapping them to Hive
    entities (paths for\n      partitions and tables) for reporting.\n    </description>\n
    \ </property>\n  <property>\n    <name>hive.llap.io.use.lrfu</name>\n    <value>true</value>\n
    \   <description>Whether ORC low-level cache should use LRFU cache policy instead
    of default (FIFO).</description>\n  </property>\n  <property>\n    <name>hive.llap.io.lrfu.lambda</name>\n
    \   <value>1.0E-6</value>\n    <description>\n      Lambda for ORC low-level cache
    LRFU cache policy. Must be in [0, 1]. 0 makes LRFU\n      behave like LFU, 1 makes
    it behave like LRU, values in between balance accordingly.\n      The meaning
    of this parameter is the inverse of the number of time ticks (cache\n       operations,
    currently) that cause the combined recency-frequency of a block in cache\n       to
    be halved.\n    </description>\n  </property>\n  <property>\n    <name>hive.llap.cache.allow.synthetic.fileid</name>\n
    \   <value>true</value>\n    <description>\n      Whether LLAP cache should use
    synthetic file ID if real one is not available. Systems\n      like HDFS, Isilon,
    etc. provide a unique file/inode ID. On other FSes (e.g. local\n      FS), the
    cache would not work by default because LLAP is unable to uniquely track the\n
    \     files; enabling this setting allows LLAP to generate file ID from the path,
    size and\n      modification time, which is almost certain to identify file uniquely.
    However, if you\n      use a FS without file IDs and rewrite files a lot (or are
    paranoid), you might want\n      to avoid this setting.\n    </description>\n
    \ </property>\n  <property>\n    <name>hive.llap.cache.defaultfs.only.native.fileid</name>\n
    \   <value>true</value>\n    <description>\n      Whether LLAP cache should use
    native file IDs from the default FS only. This is to\n      avoid file ID collisions
    when several different DFS instances are in use at the same\n      time. Disable
    this check to allow native file IDs from non-default DFS.\n    </description>\n
    \ </property>\n  <property>\n    <name>hive.llap.orc.gap.cache</name>\n    <value>true</value>\n
    \   <description>\n      Whether LLAP cache for ORC should remember gaps in ORC
    compression buffer read\n      estimates, to avoid re-reading the data that was
    read once and discarded because it\n      is unneeded. This is only necessary
    for ORC files written before HIVE-9660.\n    </description>\n  </property>\n  <property>\n
    \   <name>hive.llap.io.use.fileid.path</name>\n    <value>true</value>\n    <description>\n
    \     Whether LLAP should use fileId (inode)-based path to ensure better consistency
    for the\n      cases of file overwrites. This is supported on HDFS.\n    </description>\n
    \ </property>\n  <property>\n    <name>hive.llap.io.encode.enabled</name>\n    <value>true</value>\n
    \   <description>\n      Whether LLAP should try to re-encode and cache data for
    non-ORC formats. This is used\n      on LLAP Server side to determine if the infrastructure
    for that is initialized.\n    </description>\n  </property>\n  <property>\n    <name>hive.llap.io.encode.formats</name>\n
    \   <value>org.apache.hadoop.mapred.TextInputFormat,</value>\n    <description>\n
    \     The table input formats for which LLAP IO should re-encode and cache data.\n
    \     Comma-separated list.\n    </description>\n  </property>\n  <property>\n
    \   <name>hive.llap.io.encode.alloc.size</name>\n    <value>256Kb</value>\n    <description>\n
    \     Expects a byte size value with unit (blank for bytes, kb, mb, gb, tb, pb).\n
    \     Allocation size for the buffers used to cache encoded data from non-ORC
    files. Must\n      be a power of two between hive.llap.io.allocator.alloc.min
    and\n      hive.llap.io.allocator.alloc.max.\n    </description>\n  </property>\n
    \ <property>\n    <name>hive.llap.io.encode.vector.serde.enabled</name>\n    <value>true</value>\n
    \   <description>Whether LLAP should use vectorized SerDe reader to read text
    data when re-encoding.</description>\n  </property>\n  <property>\n    <name>hive.llap.io.encode.vector.serde.async.enabled</name>\n
    \   <value>true</value>\n    <description>Whether LLAP should use async mode in
    vectorized SerDe reader to read text data.</description>\n  </property>\n  <property>\n
    \   <name>hive.llap.io.encode.slice.row.count</name>\n    <value>100000</value>\n
    \   <description>\n      Row count to use to separate cache slices when reading
    encoded data from row-based\n      inputs into LLAP cache, if this feature is
    enabled.\n    </description>\n  </property>\n  <property>\n    <name>hive.llap.io.encode.slice.lrr</name>\n
    \   <value>true</value>\n    <description>\n      Whether to separate cache slices
    when reading encoded data from text inputs via MR\n      MR LineRecordRedader
    into LLAP cache, if this feature is enabled. Safety flag.\n    </description>\n
    \ </property>\n  <property>\n    <name>hive.llap.io.orc.time.counters</name>\n
    \   <value>true</value>\n    <description>Whether to enable time counters for
    LLAP IO layer (time spent in HDFS, etc.)</description>\n  </property>\n  <property>\n
    \   <name>hive.llap.io.vrb.queue.limit.base</name>\n    <value>50000</value>\n
    \   <description>\n      The default queue size for VRBs produced by a LLAP IO
    thread when the processing is\n      slower than the IO. The actual queue size
    is set per fragment, and is adjusted down\n      from the base, depending on the
    schema.\n    </description>\n  </property>\n  <property>\n    <name>hive.llap.io.vrb.queue.limit.min</name>\n
    \   <value>10</value>\n    <description>\n      The minimum queue size for VRBs
    produced by a LLAP IO thread when the processing is\n      slower than the IO
    (used when determining the size from base size).\n    </description>\n  </property>\n
    \ <property>\n    <name>hive.llap.io.share.object.pools</name>\n    <value>false</value>\n
    \   <description>Whether to used shared object pools in LLAP IO. A safety flag.</description>\n
    \ </property>\n  <property>\n    <name>hive.llap.auto.allow.uber</name>\n    <value>false</value>\n
    \   <description>Whether or not to allow the planner to run vertices in the AM.</description>\n
    \ </property>\n  <property>\n    <name>hive.llap.auto.enforce.tree</name>\n    <value>true</value>\n
    \   <description>Enforce that all parents are in llap, before considering vertex</description>\n
    \ </property>\n  <property>\n    <name>hive.llap.auto.enforce.vectorized</name>\n
    \   <value>true</value>\n    <description>Enforce that inputs are vectorized,
    before considering vertex</description>\n  </property>\n  <property>\n    <name>hive.llap.auto.enforce.stats</name>\n
    \   <value>true</value>\n    <description>Enforce that col stats are available,
    before considering vertex</description>\n  </property>\n  <property>\n    <name>hive.llap.auto.max.input.size</name>\n
    \   <value>10737418240</value>\n    <description>Check input size, before considering
    vertex (-1 disables check)</description>\n  </property>\n  <property>\n    <name>hive.llap.auto.max.output.size</name>\n
    \   <value>1073741824</value>\n    <description>Check output size, before considering
    vertex (-1 disables check)</description>\n  </property>\n  <property>\n    <name>hive.llap.skip.compile.udf.check</name>\n
    \   <value>false</value>\n    <description>\n      Whether to skip the compile-time
    check for non-built-in UDFs when deciding whether to\n      execute tasks in LLAP.
    Skipping the check allows executing UDFs from pre-localized\n      jars in LLAP;
    if the jars are not pre-localized, the UDFs will simply fail to load.\n    </description>\n
    \ </property>\n  <property>\n    <name>hive.llap.allow.permanent.fns</name>\n
    \   <value>true</value>\n    <description>Whether LLAP decider should allow permanent
    UDFs.</description>\n  </property>\n  <property>\n    <name>hive.llap.execution.mode</name>\n
    \   <value>none</value>\n    <description>\n      Expects one of [auto, none,
    all, map, only].\n      Chooses whether query fragments will run in container
    or in llap\n    </description>\n  </property>\n  <property>\n    <name>hive.llap.object.cache.enabled</name>\n
    \   <value>true</value>\n    <description>Cache objects (plans, hashtables, etc)
    in llap</description>\n  </property>\n  <property>\n    <name>hive.llap.io.decoding.metrics.percentiles.intervals</name>\n
    \   <value>30</value>\n    <description>\n      Comma-delimited set of integers
    denoting the desired rollover intervals (in seconds)\n      for percentile latency
    metrics on the LLAP daemon IO decoding time.\n      hive.llap.queue.metrics.percentiles.intervals\n
    \   </description>\n  </property>\n  <property>\n    <name>hive.llap.io.threadpool.size</name>\n
    \   <value>10</value>\n    <description>Specify the number of threads to use for
    low-level IO thread pool.</description>\n  </property>\n  <property>\n    <name>hive.llap.daemon.service.principal</name>\n
    \   <value/>\n    <description>The name of the LLAP daemon's service principal.</description>\n
    \ </property>\n  <property>\n    <name>hive.llap.daemon.keytab.file</name>\n    <value/>\n
    \   <description>The path to the Kerberos Keytab file containing the LLAP daemon's
    service principal.</description>\n  </property>\n  <property>\n    <name>hive.llap.webui.spnego.keytab</name>\n
    \   <value/>\n    <description>\n      The path to the Kerberos Keytab file containing
    the LLAP WebUI SPNEGO principal.\n      Typical value would look like /etc/security/keytabs/spnego.service.keytab.\n
    \   </description>\n  </property>\n  <property>\n    <name>hive.llap.webui.spnego.principal</name>\n
    \   <value/>\n    <description>\n      The LLAP WebUI SPNEGO service principal.
    Configured similarly to\n      hive.server2.webui.spnego.principal\n    </description>\n
    \ </property>\n  <property>\n    <name>hive.llap.task.principal</name>\n    <value/>\n
    \   <description>\n      The name of the principal to use to run tasks. By default,
    the clients are required\n      to provide tokens to access HDFS/etc.\n    </description>\n
    \ </property>\n  <property>\n    <name>hive.llap.task.keytab.file</name>\n    <value/>\n
    \   <description>\n      The path to the Kerberos Keytab file containing the principal
    to use to run tasks.\n      By default, the clients are required to provide tokens
    to access HDFS/etc.\n    </description>\n  </property>\n  <property>\n    <name>hive.llap.zk.sm.connectionString</name>\n
    \   <value/>\n    <description>ZooKeeper connection string for ZooKeeper SecretManager.</description>\n
    \ </property>\n  <property>\n    <name>hive.llap.zk.sm.session.timeout</name>\n
    \   <value>40s</value>\n    <description>\n      Expects a time value with unit
    (d/day, h/hour, m/min, s/sec, ms/msec, us/usec, ns/nsec), which is msec if not
    specified.\n      ZooKeeper session timeout for ZK SecretManager.\n    </description>\n
    \ </property>\n  <property>\n    <name>hive.llap.zk.registry.user</name>\n    <value/>\n
    \   <description>\n      In the LLAP ZooKeeper-based registry, specifies the username
    in the Zookeeper path.\n      This should be the hive user or whichever user is
    running the LLAP daemon.\n    </description>\n  </property>\n  <property>\n    <name>hive.llap.zk.registry.namespace</name>\n
    \   <value/>\n    <description>\n      In the LLAP ZooKeeper-based registry, overrides
    the ZK path namespace. Note that\n      using this makes the path management (e.g.
    setting correct ACLs) your responsibility.\n    </description>\n  </property>\n
    \ <property>\n    <name>hive.llap.daemon.acl</name>\n    <value>*</value>\n    <description>The
    ACL for LLAP daemon.</description>\n  </property>\n  <property>\n    <name>hive.llap.daemon.acl.blocked</name>\n
    \   <value/>\n    <description>The deny ACL for LLAP daemon.</description>\n  </property>\n
    \ <property>\n    <name>hive.llap.management.acl</name>\n    <value>*</value>\n
    \   <description>The ACL for LLAP daemon management.</description>\n  </property>\n
    \ <property>\n    <name>hive.llap.management.acl.blocked</name>\n    <value/>\n
    \   <description>The deny ACL for LLAP daemon management.</description>\n  </property>\n
    \ <property>\n    <name>hive.llap.plugin.acl</name>\n    <value>*</value>\n    <description>The
    ACL for LLAP plugin AM endpoint.</description>\n  </property>\n  <property>\n
    \   <name>hive.llap.plugin.acl.blocked</name>\n    <value/>\n    <description>The
    deny ACL for LLAP plugin AM endpoint.</description>\n  </property>\n  <property>\n
    \   <name>hive.llap.remote.token.requires.signing</name>\n    <value>true</value>\n
    \   <description>\n      Expects one of [false, except_llap_owner, true].\n      Whether
    the token returned from LLAP management API should require fragment signing.\n
    \     True by default; can be disabled to allow CLI to get tokens from LLAP in
    a secure\n      cluster by setting it to true or 'except_llap_owner' (the latter
    returns such tokens\n      to everyone except the user LLAP cluster is authenticating
    under).\n    </description>\n  </property>\n  <property>\n    <name>hive.llap.daemon.delegation.token.lifetime</name>\n
    \   <value>14d</value>\n    <description>\n      Expects a time value with unit
    (d/day, h/hour, m/min, s/sec, ms/msec, us/usec, ns/nsec), which is sec if not
    specified.\n      LLAP delegation token lifetime, in seconds if specified without
    a unit.\n    </description>\n  </property>\n  <property>\n    <name>hive.llap.management.rpc.port</name>\n
    \   <value>15004</value>\n    <description>RPC port for LLAP daemon management
    service.</description>\n  </property>\n  <property>\n    <name>hive.llap.auto.auth</name>\n
    \   <value>false</value>\n    <description>Whether or not to set Hadoop configs
    to enable auth in LLAP web app.</description>\n  </property>\n  <property>\n    <name>hive.llap.daemon.rpc.num.handlers</name>\n
    \   <value>5</value>\n    <description>Number of RPC handlers for LLAP daemon.</description>\n
    \ </property>\n  <property>\n    <name>hive.llap.plugin.rpc.num.handlers</name>\n
    \   <value>1</value>\n    <description>Number of RPC handlers for AM LLAP plugin
    endpoint.</description>\n  </property>\n  <property>\n    <name>hive.llap.daemon.work.dirs</name>\n
    \   <value/>\n    <description>\n      Working directories for the daemon. This
    should not be set if running as a YARN\n      Service. It must be set when not
    running on YARN. If the value is set when\n      running as a YARN Service, the
    specified value will be used.\n    </description>\n  </property>\n  <property>\n
    \   <name>hive.llap.daemon.yarn.shuffle.port</name>\n    <value>15551</value>\n
    \   <description>YARN shuffle port for LLAP-daemon-hosted shuffle.</description>\n
    \ </property>\n  <property>\n    <name>hive.llap.daemon.yarn.container.mb</name>\n
    \   <value>-1</value>\n    <description>llap server yarn container size in MB.
    Used in LlapServiceDriver and package.py</description>\n  </property>\n  <property>\n
    \   <name>hive.llap.daemon.queue.name</name>\n    <value/>\n    <description>Queue
    name within which the llap application will run. Used in LlapServiceDriver and
    package.py</description>\n  </property>\n  <property>\n    <name>hive.llap.daemon.container.id</name>\n
    \   <value/>\n    <description>ContainerId of a running LlapDaemon. Used to publish
    to the registry</description>\n  </property>\n  <property>\n    <name>hive.llap.daemon.nm.address</name>\n
    \   <value/>\n    <description>\n      NM Address host:rpcPort for the NodeManager
    on which the instance of the daemon is running.\n      Published to the llap registry.
    Should never be set by users\n    </description>\n  </property>\n  <property>\n
    \   <name>hive.llap.daemon.shuffle.dir.watcher.enabled</name>\n    <value>false</value>\n
    \   <description>TODO doc</description>\n  </property>\n  <property>\n    <name>hive.llap.daemon.am.liveness.heartbeat.interval.ms</name>\n
    \   <value>10000ms</value>\n    <description>\n      Expects a time value with
    unit (d/day, h/hour, m/min, s/sec, ms/msec, us/usec, ns/nsec), which is msec if
    not specified.\n      Tez AM-LLAP heartbeat interval (milliseconds). This needs
    to be below the task timeout\n      interval, but otherwise as high as possible
    to avoid unnecessary traffic.\n    </description>\n  </property>\n  <property>\n
    \   <name>hive.llap.am.liveness.connection.timeout.ms</name>\n    <value>10000ms</value>\n
    \   <description>\n      Expects a time value with unit (d/day, h/hour, m/min,
    s/sec, ms/msec, us/usec, ns/nsec), which is msec if not specified.\n      Amount
    of time to wait on connection failures to the AM from an LLAP daemon before\n
    \     considering the AM to be dead.\n    </description>\n  </property>\n  <property>\n
    \   <name>hive.llap.am.use.fqdn</name>\n    <value>true</value>\n    <description>Whether
    to use FQDN of the AM machine when submitting work to LLAP.</description>\n  </property>\n
    \ <property>\n    <name>hive.llap.am.liveness.connection.sleep.between.retries.ms</name>\n
    \   <value>2000ms</value>\n    <description>\n      Expects a time value with
    unit (d/day, h/hour, m/min, s/sec, ms/msec, us/usec, ns/nsec), which is msec if
    not specified.\n      Sleep duration while waiting to retry connection failures
    to the AM from the daemon for\n      the general keep-alive thread (milliseconds).\n
    \   </description>\n  </property>\n  <property>\n    <name>hive.llap.task.scheduler.timeout.seconds</name>\n
    \   <value>60s</value>\n    <description>\n      Expects a time value with unit
    (d/day, h/hour, m/min, s/sec, ms/msec, us/usec, ns/nsec), which is sec if not
    specified.\n      Amount of time to wait before failing the query when there are
    no llap daemons running\n      (alive) in the cluster.\n    </description>\n  </property>\n
    \ <property>\n    <name>hive.llap.daemon.num.executors</name>\n    <value>4</value>\n
    \   <description>\n      Number of executors to use in LLAP daemon; essentially,
    the number of tasks that can be\n      executed in parallel.\n    </description>\n
    \ </property>\n  <property>\n    <name>hive.llap.mapjoin.memory.oversubscribe.factor</name>\n
    \   <value>0.2</value>\n    <description>\n      Fraction of memory from hive.auto.convert.join.noconditionaltask.size
    that can be over subscribed\n      by queries running in LLAP mode. This factor
    has to be from 0.0 to 1.0. Default is 20% over subscription.\n    </description>\n
    \ </property>\n  <property>\n    <name>hive.llap.memory.oversubscription.max.executors.per.query</name>\n
    \   <value>3</value>\n    <description>\n      Used along with hive.llap.mapjoin.memory.oversubscribe.factor
    to limit the number of executors from\n      which memory for mapjoin can be borrowed.
    Default 3 (from 3 other executors\n      hive.llap.mapjoin.memory.oversubscribe.factor
    amount of memory can be borrowed based on which mapjoin\n      conversion decision
    will be made). This is only an upper bound. Lower bound is determined by number
    of\n      executors and configured max concurrency.\n    </description>\n  </property>\n
    \ <property>\n    <name>hive.llap.mapjoin.memory.monitor.check.interval</name>\n
    \   <value>100000</value>\n    <description>\n      Check memory usage of mapjoin
    hash tables after every interval of this many rows. If map join hash table\n      memory
    usage exceeds (hive.auto.convert.join.noconditionaltask.size * hive.hash.table.inflation.factor)\n
    \     when running in LLAP, tasks will get killed and not retried. Set the value
    to 0 to disable this feature.\n    </description>\n  </property>\n  <property>\n
    \   <name>hive.llap.daemon.am-reporter.max.threads</name>\n    <value>4</value>\n
    \   <description>\n      Maximum number of threads to be used for AM reporter.
    If this is lower than number of\n      executors in llap daemon, it would be set
    to number of executors at runtime.\n    </description>\n  </property>\n  <property>\n
    \   <name>hive.llap.daemon.rpc.port</name>\n    <value>0</value>\n    <description>The
    LLAP daemon RPC port.</description>\n  </property>\n  <property>\n    <name>hive.llap.daemon.memory.per.instance.mb</name>\n
    \   <value>4096</value>\n    <description>The total amount of memory to use for
    the executors inside LLAP (in megabytes).</description>\n  </property>\n  <property>\n
    \   <name>hive.llap.daemon.xmx.headroom</name>\n    <value>5%</value>\n    <description>\n
    \     The total amount of heap memory set aside by LLAP and not used by the executors.
    Can\n      be specified as size (e.g. '512Mb'), or percentage (e.g. '5%'). Note
    that the latter is\n      derived from the total daemon XMX, which can be different
    from the total executor\n      memory if the cache is on-heap; although that's
    not the default configuration.\n    </description>\n  </property>\n  <property>\n
    \   <name>hive.llap.daemon.vcpus.per.instance</name>\n    <value>4</value>\n    <description>The
    total number of vcpus to use for the executors inside LLAP.</description>\n  </property>\n
    \ <property>\n    <name>hive.llap.daemon.num.file.cleaner.threads</name>\n    <value>1</value>\n
    \   <description>Number of file cleaner threads in LLAP.</description>\n  </property>\n
    \ <property>\n    <name>hive.llap.file.cleanup.delay.seconds</name>\n    <value>300s</value>\n
    \   <description>\n      Expects a time value with unit (d/day, h/hour, m/min,
    s/sec, ms/msec, us/usec, ns/nsec), which is sec if not specified.\n      How long
    to delay before cleaning up query files in LLAP (in seconds, for debugging).\n
    \   </description>\n  </property>\n  <property>\n    <name>hive.llap.daemon.service.hosts</name>\n
    \   <value/>\n    <description>\n      Explicitly specified hosts to use for LLAP
    scheduling. Useful for testing. By default,\n      YARN registry is used.\n    </description>\n
    \ </property>\n  <property>\n    <name>hive.llap.daemon.service.refresh.interval.sec</name>\n
    \   <value>60s</value>\n    <description>\n      Expects a time value with unit
    (d/day, h/hour, m/min, s/sec, ms/msec, us/usec, ns/nsec), which is sec if not
    specified.\n      LLAP YARN registry service list refresh delay, in seconds.\n
    \   </description>\n  </property>\n  <property>\n    <name>hive.llap.daemon.communicator.num.threads</name>\n
    \   <value>10</value>\n    <description>Number of threads to use in LLAP task
    communicator in Tez AM.</description>\n  </property>\n  <property>\n    <name>hive.llap.plugin.client.num.threads</name>\n
    \   <value>10</value>\n    <description>Number of threads to use in LLAP task
    plugin client.</description>\n  </property>\n  <property>\n    <name>hive.llap.daemon.download.permanent.fns</name>\n
    \   <value>false</value>\n    <description>Whether LLAP daemon should localize
    the resources for permanent UDFs.</description>\n  </property>\n  <property>\n
    \   <name>hive.llap.task.scheduler.am.registry</name>\n    <value>llap</value>\n
    \   <description>AM registry name for LLAP task scheduler plugin to register with.</description>\n
    \ </property>\n  <property>\n    <name>hive.llap.task.scheduler.am.registry.principal</name>\n
    \   <value/>\n    <description>The name of the principal used to access ZK AM
    registry securely.</description>\n  </property>\n  <property>\n    <name>hive.llap.task.scheduler.am.registry.keytab.file</name>\n
    \   <value/>\n    <description>The path to the Kerberos keytab file used to access
    ZK AM registry securely.</description>\n  </property>\n  <property>\n    <name>hive.llap.task.scheduler.node.reenable.min.timeout.ms</name>\n
    \   <value>200ms</value>\n    <description>\n      Expects a time value with unit
    (d/day, h/hour, m/min, s/sec, ms/msec, us/usec, ns/nsec), which is msec if not
    specified.\n      Minimum time after which a previously disabled node will be
    re-enabled for scheduling,\n      in milliseconds. This may be modified by an
    exponential back-off if failures persist.\n    </description>\n  </property>\n
    \ <property>\n    <name>hive.llap.task.scheduler.node.reenable.max.timeout.ms</name>\n
    \   <value>10000ms</value>\n    <description>\n      Expects a time value with
    unit (d/day, h/hour, m/min, s/sec, ms/msec, us/usec, ns/nsec), which is msec if
    not specified.\n      Maximum time after which a previously disabled node will
    be re-enabled for scheduling,\n      in milliseconds. This may be modified by
    an exponential back-off if failures persist.\n    </description>\n  </property>\n
    \ <property>\n    <name>hive.llap.task.scheduler.node.disable.backoff.factor</name>\n
    \   <value>1.5</value>\n    <description>\n      Backoff factor on successive
    blacklists of a node due to some failures. Blacklist times\n      start at the
    min timeout and go up to the max timeout based on this backoff factor.\n    </description>\n
    \ </property>\n  <property>\n    <name>hive.llap.task.scheduler.preempt.independent</name>\n
    \   <value>false</value>\n    <description>\n      Whether the AM LLAP scheduler
    should preempt a lower priority task for a higher pri one\n      even if the former
    doesn't depend on the latter (e.g. for two parallel sides of a union).\n    </description>\n
    \ </property>\n  <property>\n    <name>hive.llap.task.scheduler.num.schedulable.tasks.per.node</name>\n
    \   <value>0</value>\n    <description>\n      The number of tasks the AM TaskScheduler
    will try allocating per node. 0 indicates that\n      this should be picked up
    from the Registry. -1 indicates unlimited capacity; positive\n      values indicate
    a specific bound.\n    </description>\n  </property>\n  <property>\n    <name>hive.llap.task.scheduler.locality.delay</name>\n
    \   <value>0ms</value>\n    <description>\n      Expects a time value with unit
    (d/day, h/hour, m/min, s/sec, ms/msec, us/usec, ns/nsec), which is msec if not
    specified.\n      The time should be in between -1 msec (inclusive) and 9223372036854775807
    msec (inclusive).\n      Amount of time to wait before allocating a request which
    contains location information, to a location other than the ones requested. Set
    to -1 for an infinite delay, 0for no delay.\n    </description>\n  </property>\n
    \ <property>\n    <name>hive.llap.daemon.task.preemption.metrics.intervals</name>\n
    \   <value>30,60,300</value>\n    <description>\n      Comma-delimited set of
    integers denoting the desired rollover intervals (in seconds)\n       for percentile
    latency metrics. Used by LLAP daemon task scheduler metrics for\n       time taken
    to kill task (due to pre-emption) and useful time wasted by the task that\n       is
    about to be preempted.\n    </description>\n  </property>\n  <property>\n    <name>hive.llap.daemon.task.scheduler.wait.queue.size</name>\n
    \   <value>10</value>\n    <description>LLAP scheduler maximum queue size.</description>\n
    \ </property>\n  <property>\n    <name>hive.llap.daemon.wait.queue.comparator.class.name</name>\n
    \   <value>org.apache.hadoop.hive.llap.daemon.impl.comparator.ShortestJobFirstComparator</value>\n
    \   <description>\n      The priority comparator to use for LLAP scheduler priority
    queue. The built-in options\n      are org.apache.hadoop.hive.llap.daemon.impl.comparator.ShortestJobFirstComparator
    and\n      .....FirstInFirstOutComparator\n    </description>\n  </property>\n
    \ <property>\n    <name>hive.llap.daemon.task.scheduler.enable.preemption</name>\n
    \   <value>true</value>\n    <description>\n      Whether non-finishable running
    tasks (e.g. a reducer waiting for inputs) should be\n      preempted by finishable
    tasks inside LLAP scheduler.\n    </description>\n  </property>\n  <property>\n
    \   <name>hive.llap.task.communicator.connection.timeout.ms</name>\n    <value>16000ms</value>\n
    \   <description>\n      Expects a time value with unit (d/day, h/hour, m/min,
    s/sec, ms/msec, us/usec, ns/nsec), which is msec if not specified.\n      Connection
    timeout (in milliseconds) before a failure to an LLAP daemon from Tez AM.\n    </description>\n
    \ </property>\n  <property>\n    <name>hive.llap.task.communicator.listener.thread-count</name>\n
    \   <value>30</value>\n    <description>The number of task communicator listener
    threads.</description>\n  </property>\n  <property>\n    <name>hive.llap.task.communicator.connection.sleep.between.retries.ms</name>\n
    \   <value>2000ms</value>\n    <description>\n      Expects a time value with
    unit (d/day, h/hour, m/min, s/sec, ms/msec, us/usec, ns/nsec), which is msec if
    not specified.\n      Sleep duration (in milliseconds) to wait before retrying
    on error when obtaining a\n      connection to LLAP daemon from Tez AM.\n    </description>\n
    \ </property>\n  <property>\n    <name>hive.llap.daemon.web.port</name>\n    <value>15002</value>\n
    \   <description>LLAP daemon web UI port.</description>\n  </property>\n  <property>\n
    \   <name>hive.llap.daemon.web.ssl</name>\n    <value>false</value>\n    <description>Whether
    LLAP daemon web UI should use SSL.</description>\n  </property>\n  <property>\n
    \   <name>hive.llap.client.consistent.splits</name>\n    <value>true</value>\n
    \   <description>Whether to setup split locations to match nodes on which llap
    daemons are running, instead of using the locations provided by the split itself.
    If there is no llap daemon running, fall back to locations provided by the split.
    This is effective only if hive.execution.mode is llap</description>\n  </property>\n
    \ <property>\n    <name>hive.llap.validate.acls</name>\n    <value>true</value>\n
    \   <description>\n      Whether LLAP should reject permissive ACLs in some cases
    (e.g. its own management\n      protocol or ZK paths), similar to how ssh refuses
    a key with bad access permissions.\n    </description>\n  </property>\n  <property>\n
    \   <name>hive.llap.daemon.output.service.port</name>\n    <value>15003</value>\n
    \   <description>LLAP daemon output service port</description>\n  </property>\n
    \ <property>\n    <name>hive.llap.daemon.output.stream.timeout</name>\n    <value>120s</value>\n
    \   <description>\n      Expects a time value with unit (d/day, h/hour, m/min,
    s/sec, ms/msec, us/usec, ns/nsec), which is sec if not specified.\n      The timeout
    for the client to connect to LLAP output service and start the fragment\n      output
    after sending the fragment. The fragment will fail if its output is not claimed.\n
    \   </description>\n  </property>\n  <property>\n    <name>hive.llap.daemon.output.service.send.buffer.size</name>\n
    \   <value>131072</value>\n    <description>Send buffer size to be used by LLAP
    daemon output service</description>\n  </property>\n  <property>\n    <name>hive.llap.daemon.output.service.max.pending.writes</name>\n
    \   <value>8</value>\n    <description>\n      Maximum number of queued writes
    allowed per connection when sending data\n       via the LLAP output service to
    external clients.\n    </description>\n  </property>\n  <property>\n    <name>hive.llap.external.splits.temp.table.storage.format</name>\n
    \   <value>orc</value>\n    <description>\n      Expects one of [default, text,
    orc].\n      Storage format for temp tables created using LLAP external client\n
    \   </description>\n  </property>\n  <property>\n    <name>hive.llap.external.splits.order.by.force.single.split</name>\n
    \   <value>true</value>\n    <description>\n      If LLAP external clients submits
    ORDER BY queries, force return a single split to guarantee reading\n      data
    out in ordered way. Setting this to false will let external clients read data
    out in parallel\n      losing the ordering (external clients are responsible for
    guaranteeing the ordering)\n    </description>\n  </property>\n  <property>\n
    \   <name>hive.llap.enable.grace.join.in.llap</name>\n    <value>false</value>\n
    \   <description>Override if grace join should be allowed to run in llap.</description>\n
    \ </property>\n  <property>\n    <name>hive.llap.hs2.coordinator.enabled</name>\n
    \   <value>true</value>\n    <description>\n      Whether to create the LLAP coordinator;
    since execution engine and container vs llap\n      settings are both coming from
    job configs, we don't know at start whether this should\n      be created. Default
    true.\n    </description>\n  </property>\n  <property>\n    <name>hive.llap.daemon.logger</name>\n
    \   <value>query-routing</value>\n    <description>\n      Expects one of [query-routing,
    rfa, console].\n      logger used for llap-daemons.\n    </description>\n  </property>\n
    \ <property>\n    <name>hive.llap.output.format.arrow</name>\n    <value>true</value>\n
    \   <description>Whether LLapOutputFormatService should output arrow batches</description>\n
    \ </property>\n  <property>\n    <name>hive.trigger.validation.interval</name>\n
    \   <value>500ms</value>\n    <description>\n      Expects a time value with unit
    (d/day, h/hour, m/min, s/sec, ms/msec, us/usec, ns/nsec), which is msec if not
    specified.\n      Interval for validating triggers during execution of a query.
    Triggers defined in resource plan will get\n      validated for all SQL operations
    after every defined interval (default: 500ms) and corresponding action\n      defined
    in the trigger will be taken\n    </description>\n  </property>\n  <property>\n
    \   <name>hive.spark.use.op.stats</name>\n    <value>true</value>\n    <description>\n
    \     Whether to use operator stats to determine reducer parallelism for Hive
    on Spark.\n      If this is false, Hive will use source table stats to determine
    reducer\n      parallelism for all first level reduce tasks, and the maximum reducer
    parallelism\n      from all parents for all the rest (second level and onward)
    reducer tasks.\n    </description>\n  </property>\n  <property>\n    <name>hive.spark.use.ts.stats.for.mapjoin</name>\n
    \   <value>false</value>\n    <description>\n      If this is set to true, mapjoin
    optimization in Hive/Spark will use statistics from\n      TableScan operators
    at the root of operator tree, instead of parent ReduceSink\n      operators of
    the Join operator.\n    </description>\n  </property>\n  <property>\n    <name>hive.spark.optimize.shuffle.serde</name>\n
    \   <value>false</value>\n    <description>\n      If this is set to true, Hive
    on Spark will register custom serializers for data types\n      in shuffle. This
    should result in less shuffled data.\n    </description>\n  </property>\n  <property>\n
    \   <name>hive.spark.client.future.timeout</name>\n    <value>60s</value>\n    <description>\n
    \     Expects a time value with unit (d/day, h/hour, m/min, s/sec, ms/msec, us/usec,
    ns/nsec), which is sec if not specified.\n      Timeout for requests from Hive
    client to remote Spark driver.\n    </description>\n  </property>\n  <property>\n
    \   <name>hive.spark.job.monitor.timeout</name>\n    <value>60s</value>\n    <description>\n
    \     Expects a time value with unit (d/day, h/hour, m/min, s/sec, ms/msec, us/usec,
    ns/nsec), which is sec if not specified.\n      Timeout for job monitor to get
    Spark job state.\n    </description>\n  </property>\n  <property>\n    <name>hive.spark.client.connect.timeout</name>\n
    \   <value>1000ms</value>\n    <description>\n      Expects a time value with
    unit (d/day, h/hour, m/min, s/sec, ms/msec, us/usec, ns/nsec), which is msec if
    not specified.\n      Timeout for remote Spark driver in connecting back to Hive
    client.\n    </description>\n  </property>\n  <property>\n    <name>hive.spark.client.server.connect.timeout</name>\n
    \   <value>90000ms</value>\n    <description>\n      Expects a time value with
    unit (d/day, h/hour, m/min, s/sec, ms/msec, us/usec, ns/nsec), which is msec if
    not specified.\n      Timeout for handshake between Hive client and remote Spark
    driver.  Checked by both processes.\n    </description>\n  </property>\n  <property>\n
    \   <name>hive.spark.client.secret.bits</name>\n    <value>256</value>\n    <description>Number
    of bits of randomness in the generated secret for communication between Hive client
    and remote Spark driver. Rounded down to the nearest multiple of 8.</description>\n
    \ </property>\n  <property>\n    <name>hive.spark.client.rpc.threads</name>\n
    \   <value>8</value>\n    <description>Maximum number of threads for remote Spark
    driver's RPC event loop.</description>\n  </property>\n  <property>\n    <name>hive.spark.client.rpc.max.size</name>\n
    \   <value>52428800</value>\n    <description>Maximum message size in bytes for
    communication between Hive client and remote Spark driver. Default is 50MB.</description>\n
    \ </property>\n  <property>\n    <name>hive.spark.client.channel.log.level</name>\n
    \   <value/>\n    <description>Channel logging level for remote Spark driver.
    \ One of {DEBUG, ERROR, INFO, TRACE, WARN}.</description>\n  </property>\n  <property>\n
    \   <name>hive.spark.client.rpc.sasl.mechanisms</name>\n    <value>DIGEST-MD5</value>\n
    \   <description>Name of the SASL mechanism to use for authentication.</description>\n
    \ </property>\n  <property>\n    <name>hive.spark.client.rpc.server.address</name>\n
    \   <value/>\n    <description>The server address of HiverServer2 host to be used
    for communication between Hive client and remote Spark driver. Default is empty,
    which means the address will be determined in the same way as for hive.server2.thrift.bind.host.This
    is only necessary if the host has multiple network addresses and if a different
    network address other than hive.server2.thrift.bind.host is to be used.</description>\n
    \ </property>\n  <property>\n    <name>hive.spark.client.rpc.server.port</name>\n
    \   <value/>\n    <description>A list of port ranges which can be used by RPC
    server with the format of 49152-49222,49228 and a random one is selected from
    the list. Default is empty, which randomly selects one port from all available
    ones.</description>\n  </property>\n  <property>\n    <name>hive.spark.dynamic.partition.pruning</name>\n
    \   <value>false</value>\n    <description>\n      When dynamic pruning is enabled,
    joins on partition keys will be processed by writing\n      to a temporary HDFS
    file, and read later for removing unnecessary partitions.\n    </description>\n
    \ </property>\n  <property>\n    <name>hive.spark.dynamic.partition.pruning.max.data.size</name>\n
    \   <value>104857600</value>\n    <description>Maximum total data size in dynamic
    pruning.</description>\n  </property>\n  <property>\n    <name>hive.spark.dynamic.partition.pruning.map.join.only</name>\n
    \   <value>false</value>\n    <description>\n      Turn on dynamic partition pruning
    only for map joins.\n      If hive.spark.dynamic.partition.pruning is set to true,
    this parameter value is ignored.\n    </description>\n  </property>\n  <property>\n
    \   <name>hive.spark.use.groupby.shuffle</name>\n    <value>true</value>\n    <description>Spark
    groupByKey transformation has better performance but uses unbounded memory.Turn
    this off when there is a memory issue.</description>\n  </property>\n  <property>\n
    \   <name>hive.spark.job.max.tasks</name>\n    <value>-1</value>\n    <description>\n
    \     The maximum number of tasks a Spark job may have.\n      If a Spark job
    contains more tasks than the maximum, it will be cancelled. A value of -1 means
    no limit.\n    </description>\n  </property>\n  <property>\n    <name>hive.spark.stage.max.tasks</name>\n
    \   <value>-1</value>\n    <description>\n      The maximum number of tasks a
    stage in a Spark job may have.\n      If a Spark job stage contains more tasks
    than the maximum, the job will be cancelled. A value of -1 means no limit.\n    </description>\n
    \ </property>\n  <property>\n    <name>hive.reorder.nway.joins</name>\n    <value>true</value>\n
    \   <description>Runs reordering of tables within single n-way join (i.e.: picks
    streamtable)</description>\n  </property>\n  <property>\n    <name>hive.merge.nway.joins</name>\n
    \   <value>true</value>\n    <description>Merge adjacent joins into a single n-way
    join</description>\n  </property>\n  <property>\n    <name>hive.log.every.n.records</name>\n
    \   <value>0</value>\n    <description>\n      Expects value bigger than 0.\n
    \     If value is greater than 0 logs in fixed intervals of size n rather than
    exponentially.\n    </description>\n  </property>\n  <property>\n    <name>hive.msck.path.validation</name>\n
    \   <value>throw</value>\n    <description>\n      Expects one of [throw, skip,
    ignore].\n      The approach msck should take with HDFS directories that are partition-like
    but contain unsupported characters. 'throw' (an exception) is the default; 'skip'
    will skip the invalid directories and still repair the others; 'ignore' will skip
    the validation (legacy behavior, causes bugs in many cases)\n    </description>\n
    \ </property>\n  <property>\n    <name>hive.msck.repair.batch.size</name>\n    <value>3000</value>\n
    \   <description>\n      Batch size for the msck repair command. If the value
    is greater than zero,\n       it will execute batch wise with the configured batch
    size. In case of errors while\n      adding unknown partitions the batch size
    is automatically reduced by half in the subsequent\n      retry attempt. The default
    value is 3000 which means it will execute in the batches of 3000.\n    </description>\n
    \ </property>\n  <property>\n    <name>hive.msck.repair.batch.max.retries</name>\n
    \   <value>4</value>\n    <description>\n      Maximum number of retries for the
    msck repair command when adding unknown partitions.\n       If the value is greater
    than zero it will retry adding unknown partitions until the maximum\n      number
    of attempts is reached or batch size is reduced to 0, whichever is earlier.\n
    \     In each retry attempt it will reduce the batch size by a factor of 2 until
    it reaches zero.\n      If the value is set to zero it will retry until the batch
    size becomes zero as described above.\n    </description>\n  </property>\n  <property>\n
    \   <name>hive.server2.llap.concurrent.queries</name>\n    <value>-1</value>\n
    \   <description>The number of queries allowed in parallel via llap. Negative
    number implies 'infinite'.</description>\n  </property>\n  <property>\n    <name>hive.tez.enable.memory.manager</name>\n
    \   <value>true</value>\n    <description>Enable memory manager for tez</description>\n
    \ </property>\n  <property>\n    <name>hive.hash.table.inflation.factor</name>\n
    \   <value>2.0</value>\n    <description>Expected inflation factor between disk/in
    memory representation of hash tables</description>\n  </property>\n  <property>\n
    \   <name>hive.log.trace.id</name>\n    <value/>\n    <description>Log tracing
    id that can be used by upstream clients for tracking respective logs. Truncated
    to 64 characters. Defaults to use auto-generated session id.</description>\n  </property>\n
    \ <property>\n    <name>hive.mm.avoid.s3.globstatus</name>\n    <value>true</value>\n
    \   <description>Whether to use listFiles (optimized on S3) instead of globStatus
    when on S3.</description>\n  </property>\n  <property>\n    <name>hive.conf.restricted.list</name>\n
    \   <value>hive.security.authenticator.manager,hive.security.authorization.manager,hive.security.metastore.authorization.manager,hive.security.metastore.authenticator.manager,hive.users.in.admin.role,hive.server2.xsrf.filter.enabled,hive.security.authorization.enabled,hive.distcp.privileged.doAs,hive.server2.authentication.ldap.baseDN,hive.server2.authentication.ldap.url,hive.server2.authentication.ldap.Domain,hive.server2.authentication.ldap.groupDNPattern,hive.server2.authentication.ldap.groupFilter,hive.server2.authentication.ldap.userDNPattern,hive.server2.authentication.ldap.userFilter,hive.server2.authentication.ldap.groupMembershipKey,hive.server2.authentication.ldap.userMembershipKey,hive.server2.authentication.ldap.groupClassKey,hive.server2.authentication.ldap.customLDAPQuery,hive.privilege.synchronizer,hive.privilege.synchronizer.interval,hive.spark.client.connect.timeout,hive.spark.client.server.connect.timeout,hive.spark.client.channel.log.level,hive.spark.client.rpc.max.size,hive.spark.client.rpc.threads,hive.spark.client.secret.bits,hive.spark.client.rpc.server.address,hive.spark.client.rpc.server.port,hive.spark.client.rpc.sasl.mechanisms,bonecp.,hive.druid.broker.address.default,hive.druid.coordinator.address.default,hikari.,hadoop.bin.path,yarn.bin.path,spark.home</value>\n
    \   <description>Comma separated list of configuration options which are immutable
    at runtime</description>\n  </property>\n  <property>\n    <name>hive.conf.hidden.list</name>\n
    \   <value>javax.jdo.option.ConnectionPassword,hive.server2.keystore.password,fs.s3.awsAccessKeyId,fs.s3.awsSecretAccessKey,fs.s3n.awsAccessKeyId,fs.s3n.awsSecretAccessKey,fs.s3a.access.key,fs.s3a.secret.key,fs.s3a.proxy.password,dfs.adls.oauth2.credential,fs.adl.oauth2.credential</value>\n
    \   <description>Comma separated list of configuration options which should not
    be read by normal user like passwords</description>\n  </property>\n  <property>\n
    \   <name>hive.conf.internal.variable.list</name>\n    <value>hive.added.files.path,hive.added.jars.path,hive.added.archives.path</value>\n
    \   <description>Comma separated list of variables which are used internally and
    should not be configurable.</description>\n  </property>\n  <property>\n    <name>hive.spark.rsc.conf.list</name>\n
    \   <value>hive.spark.optimize.shuffle.serde,hive.spark.client.future.timeout</value>\n
    \   <description>\n      Comma separated list of variables which are related to
    remote spark context.\n      Changing these variables will result in re-creating
    the spark session.\n    </description>\n  </property>\n  <property>\n    <name>hive.query.timeout.seconds</name>\n
    \   <value>0s</value>\n    <description>\n      Expects a time value with unit
    (d/day, h/hour, m/min, s/sec, ms/msec, us/usec, ns/nsec), which is sec if not
    specified.\n      Timeout for Running Query in seconds. A nonpositive value means
    infinite. If the query timeout is also set by thrift API call, the smaller one
    will be taken.\n    </description>\n  </property>\n  <property>\n    <name>hive.exec.input.listing.max.threads</name>\n
    \   <value>0</value>\n    <description>\n      Expects a byte size value with
    unit (blank for bytes, kb, mb, gb, tb, pb).\n      The size should be in between
    0Pb (inclusive) and 1Kb (inclusive).\n      Maximum number of threads that Hive
    uses to list file information from file systems (recommended &gt; 1 for blobstore).\n
    \   </description>\n  </property>\n  <property>\n    <name>hive.query.reexecution.enabled</name>\n
    \   <value>true</value>\n    <description>Enable query reexecutions</description>\n
    \ </property>\n  <property>\n    <name>hive.query.reexecution.strategies</name>\n
    \   <value>overlay,reoptimize</value>\n    <description>\n      comma separated
    list of plugin can be used:\n        overlay: hiveconf subtree 'reexec.overlay'
    is used as an overlay in case of an execution errors out\n        reoptimize:
    collects operator statistics during execution and recompile the query after a
    failure\n    </description>\n  </property>\n  <property>\n    <name>hive.query.reexecution.stats.persist.scope</name>\n
    \   <value>query</value>\n    <description>\n      Expects one of [query, hiveserver,
    metastore].\n      Sets the persistence scope of runtime statistics\n        query:
    runtime statistics are only used during re-execution\n        hiveserver: runtime
    statistics are persisted in the hiveserver - all sessions share it\n        metastore:
    runtime statistics are persisted in the metastore as well\n    </description>\n
    \ </property>\n  <property>\n    <name>hive.query.reexecution.max.count</name>\n
    \   <value>1</value>\n    <description>Maximum number of re-executions for a single
    query.</description>\n  </property>\n  <property>\n    <name>hive.query.reexecution.always.collect.operator.stats</name>\n
    \   <value>false</value>\n    <description>If sessionstats are enabled; this option
    can be used to collect statistics all the time</description>\n  </property>\n
    \ <property>\n    <name>hive.query.reexecution.stats.cache.batch.size</name>\n
    \   <value>-1</value>\n    <description>If runtime stats are stored in metastore;
    the maximal batch size per round during load.</description>\n  </property>\n  <property>\n
    \   <name>hive.query.reexecution.stats.cache.size</name>\n    <value>100000</value>\n
    \   <description>Size of the runtime statistics cache. Unit is: OperatorStat entry;
    a query plan consist ~100.</description>\n  </property>\n  <property>\n    <name>hive.query.results.cache.enabled</name>\n
    \   <value>true</value>\n    <description>If the query results cache is enabled.
    This will keep results of previously executed queries to be reused if the same
    query is executed again.</description>\n  </property>\n  <property>\n    <name>hive.query.results.cache.nontransactional.tables.enabled</name>\n
    \   <value>false</value>\n    <description>If the query results cache is enabled
    for queries involving non-transactional tables.Users who enable this setting should
    be willing to tolerate some amount of stale results in the cache.</description>\n
    \ </property>\n  <property>\n    <name>hive.query.results.cache.wait.for.pending.results</name>\n
    \   <value>true</value>\n    <description>Should a query wait for the pending
    results of an already running query, in order to use the cached result when it
    becomes ready</description>\n  </property>\n  <property>\n    <name>hive.query.results.cache.directory</name>\n
    \   <value>/tmp/hive/_resultscache_</value>\n    <description>Location of the
    query results cache directory. Temporary results from queries will be moved to
    this location.</description>\n  </property>\n  <property>\n    <name>hive.query.results.cache.max.entry.lifetime</name>\n
    \   <value>3600s</value>\n    <description>\n      Expects a time value with unit
    (d/day, h/hour, m/min, s/sec, ms/msec, us/usec, ns/nsec), which is sec if not
    specified.\n      Maximum lifetime in seconds for an entry in the query results
    cache. A nonpositive value means infinite.\n    </description>\n  </property>\n
    \ <property>\n    <name>hive.query.results.cache.max.size</name>\n    <value>2147483648</value>\n
    \   <description>Maximum total size in bytes that the query results cache directory
    is allowed to use on the filesystem.</description>\n  </property>\n  <property>\n
    \   <name>hive.query.results.cache.max.entry.size</name>\n    <value>10485760</value>\n
    \   <description>Maximum size in bytes that a single query result is allowed to
    use in the results cache directory</description>\n  </property>\n  <property>\n
    \   <name>hive.notification.event.poll.interval</name>\n    <value>60s</value>\n
    \   <description>\n      Expects a time value with unit (d/day, h/hour, m/min,
    s/sec, ms/msec, us/usec, ns/nsec), which is sec if not specified.\n      How often
    the notification log is polled for new NotificationEvents from the metastore.A
    nonpositive value means the notification log is never polled.\n    </description>\n
    \ </property>\n  <property>\n    <name>hive.notification.event.consumers</name>\n
    \   <value>org.apache.hadoop.hive.ql.cache.results.QueryResultsCache$InvalidationEventConsumer</value>\n
    \   <description>Comma-separated list of class names extending EventConsumer,to
    handle the NotificationEvents retreived by the notification event poll.</description>\n
    \ </property>\n  <property>\n    <name>hive.blobstore.supported.schemes</name>\n
    \   <value>s3,s3a,s3n</value>\n    <description>Comma-separated list of supported
    blobstore schemes.</description>\n  </property>\n  <property>\n    <name>hive.blobstore.use.blobstore.as.scratchdir</name>\n
    \   <value>false</value>\n    <description>Enable the use of scratch directories
    directly on blob storage systems (it may cause performance penalties).</description>\n
    \ </property>\n  <property>\n    <name>hive.blobstore.optimizations.enabled</name>\n
    \   <value>true</value>\n    <description>\n      This parameter enables a number
    of optimizations when running on blobstores:\n      (1) If hive.blobstore.use.blobstore.as.scratchdir
    is false, force the last Hive job to write to the blobstore.\n      This is a
    performance optimization that forces the final FileSinkOperator to write to the
    blobstore.\n      See HIVE-15121 for details.\n    </description>\n  </property>\n</configuration>\n"
  mapred-site.xml: "<?xml version=\"1.0\"?>\n<?xml-stylesheet type=\"text/xsl\" href=\"configuration.xsl\"?>\n<!--\n
    \ Licensed under the Apache License, Version 2.0 (the \"License\");\n  you may
    not use this file except in compliance with the License.\n  You may obtain a copy
    of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\n  Unless
    required by applicable law or agreed to in writing, software\n  distributed under
    the License is distributed on an \"AS IS\" BASIS,\n  WITHOUT WARRANTIES OR CONDITIONS
    OF ANY KIND, either express or implied.\n  See the License for the specific language
    governing permissions and\n  limitations under the License. See accompanying LICENSE
    file.\n-->\n\n<!-- Put site-specific property overrides in this file. -->\n\n<configuration>\n<property>\n<name>mapreduce.map.log.level</name>\n<value>OFF</value>\n</property>\n<property>\n<name>mapreduce.reduce.log.level</name>\n<value>OFF</value>\n</property>\n
    <property>\n       <name>mapreduce.framework.name</name>\n       <value>yarn-tez</value>\n
    \  </property>\n<property>\n\t<name>mapreduce.client.submit.file.replication</name>\n\t<value>3</value>\n\t<final>false</final>\n</property>\n<property>\n\t<name>mapreduce.app-submission.cross-platform</name>\n\t<value>true</value>\n</property>\n<property>\n
    \ <name>yarn.app.mapreduce.am.env</name>\n  <value>HADOOP_MAPRED_HOME=/opt/hadoop</value>\n</property>\n<property>\n
    \ <name>yarn.app.mapreduce.am.log.level</name>\n  <value>ERROR</value>\n</property>\n<property>\n
    \ <name>mapreduce.map.env</name>\n  <value>HADOOP_MAPRED_HOME=/opt/hadoop</value>\n</property>\n<property>\n
    \ <name>mapreduce.reduce.env</name>\n  <value>HADOOP_MAPRED_HOME=/opt/hadoop</value>\n</property>\n<property>\n\t<name>mapreduce.jobhistory.address</name>\n\t<value>fom-hadoop-02.fritz.box:10201</value>\n</property>\n<property>\n\t<name>mapreduce.jobhistory.webapp.address</name>\n\t<value>fom-hadoop-02.fritz.box:19888</value>\n</property>\n<property>\n
    \   <name>mapreduce.job.counters.max</name>\n    <value>500</value>\n</property>\n<property>\n
    \ <name>mapreduce.map.memory.mb</name>\n  <value>1024</value>\n</property>\n<property>\n
    \ <name>mapreduce.reduce.memory.mb</name>\n  <value>1024</value>\n</property>\n</configuration>\n"
  tez-site.xml: "<?xml version=\"1.0\"?>\n<!--\n  Licensed under the Apache License,
    Version 2.0 (the \"License\");\n  you may not use this file except in compliance
    with the License.\n  You may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\n
    \ Unless required by applicable law or agreed to in writing, software\n  distributed
    under the License is distributed on an \"AS IS\" BASIS,\n  WITHOUT WARRANTIES
    OR CONDITIONS OF ANY KIND, either express or implied.\n  See the License for the
    specific language governing permissions and\n  limitations under the License.
    See accompanying LICENSE file.\n-->\n\n<?xml-stylesheet type=\"text/xsl\" href=\"configuration.xsl\"?>\n\n<!--
    Put site-specific property overrides in this file. -->\n\n<configuration>\n\n<property>\n
    \ <name>tez.lib.uris</name>\n  <value>hdfs://fom-hadoop-01.fritz.box:9000/apps/tez-0.9.2/tez-0.9.2.tar.gz</value>
    \n</property>\n<property>\n  <description>Enable Tez to use the Timeline Server
    for History Logging</description>\n  <name>tez.history.logging.service.class</name>\n
    \ <value>org.apache.tez.dag.history.logging.ats.ATSHistoryLoggingService</value>\n</property>\n<property>\n
    \ <description>URL for where the Tez UI is hosted</description>\n  <name>tez.tez-ui.history-url.base</name>\n
    \ <value>http://fom-hadoop-02.fritz.box:8080/tez-ui/</value>\n</property>\n\n</configuration>\n"
  yarn-site.xml: "<?xml version=\"1.0\"?>\n<!--\n  Licensed under the Apache License,
    Version 2.0 (the \"License\");\n  you may not use this file except in compliance
    with the License.\n  You may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\n
    \ Unless required by applicable law or agreed to in writing, software\n  distributed
    under the License is distributed on an \"AS IS\" BASIS,\n  WITHOUT WARRANTIES
    OR CONDITIONS OF ANY KIND, either express or implied.\n  See the License for the
    specific language governing permissions and\n  limitations under the License.
    See accompanying LICENSE file.\n-->\n<configuration>\n\n<!-- Site specific YARN
    configuration properties -->\n\n<property>\n\t<name>yarn.nodemanager.vmem-pmem-ratio</name>\n\t<value>5</value>\n</property>\n<property>\n\t<name>yarn.scheduler.minimum-allocation-mb</name>\n\t<value>1024</value>\n</property>\n<property>\n\t<name>yarn.timeline-service.store-class</name>\n\t<value>org.apache.hadoop.yarn.server.timeline.MemoryTimelineStore</value>\n</property>\n<property>\n\t<name>yarn.resourcemanager.scheduler.class</name>\n\t<value>org.apache.hadoop.yarn.server.resourcemanager.scheduler.fair.FairScheduler</value>\n</property>\n
    <property>\n <name>yarn.resourcemanager.hostname</name>\n <value>fom-hadoop-02.fritz.box</value>\n
    </property>\n <property>\n\t <name>yarn.nodemanager.aux-services</name>\n\t <value>mapreduce_shuffle</value>\n
    </property>\n\n <property>\n  <description>Indicate to clients whether Timeline
    service is enabled or not.\n  If enabled, the TimelineClient library used by end-users
    will post entities\n  and events to the Timeline server.</description>\n  <name>yarn.timeline-service.enabled</name>\n
    \ <value>true</value>\n</property>\n<property>\n\t<name>yarn.timeline-service.hostname</name>\n\t<value>fom-hadoop-02.fritz.box</value>\n</property>\n<property>\n\t
    <name>yarn.log.server.url</name>\n\t<value>http://fom-hadoop-02.fritz.box:19888/jobhistory/logs</value>\n</property>\n<property>\n\t<name>yarn.log-aggregation-enable</name>\n\t<value>true</value>\n</property>\n\n<property>\n
    \ <description>The setting that controls whether yarn system metrics is\n  published
    on the timeline server or not by RM.</description>\n  <name>yarn.system-metrics-publisher.enabled</name>\n
    \ <value>true</value>\n</property>\n<property>\n  <description>Indicate to clients
    whether to query generic application\n  data from timeline history-service or
    not. If not enabled then application\n  data is queried only from Resource Manager.</description>\n
    \ <name>yarn.timeline-service.generic-application-history.enabled</name>\n  <value>true</value>\n</property>\n\n
    <property>\n\t <name>yarn.resourcemanager.nodes.exclude-path</name>\n\t <value>/opt/hadoop/etc/hadoop/yarn.exclude</value>\n
    </property>\n<property>\n \t<name>tez.lib.uris</name>\n \t<value>hdfs://fom-hadoop-01.fritz.box:9000/apps/tez-0.9.2/tez-0.9.2.tar.gz</value>\n</property>\n<property>\n<name>yarn.timeline-service.http-cross-origin.enabled</name>\n<value>true</value>\n</property>\n<property>\n
    \ <description>Publish YARN information to Timeline Server</description>\n  <name>
    yarn.resourcemanager.system-metrics-publisher.enabled</name>\n  <value>true</value>\n</property>\n<property>\n<name>yarn.timeline-service.http-cross-origin.allowed-origins</name>
    \t\n<value>*</value>\n</property>\n </configuration>\n"
kind: ConfigMap
metadata:
  creationTimestamp: null
  name: hadoop
